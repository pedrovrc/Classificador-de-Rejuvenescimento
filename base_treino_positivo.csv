"Andrey Semashev wrote: > The main motivation for introducing the new implementation is adding > conversions to/from std::string_view, which were proposed to Boost.Utility > and rejected a while ago: > > https://github.com/boostorg/utility/pull/51 The scenario being addressed here is that of a Boost library that does not require C++17, yet its users want to use std::string_view when interacting with the library. That is, the library API is string_view api_function( string_view str ); and some of the end users aren't on C++17 and will use the library-provided string_view, and others are on C++17 and want to use std::string_view, both to pass it as an argument to `api_function`, and to store its result. Currently, if the library uses boost::string_view, it can't receive std::string_view arguments. This is fixable by adding an additional overload that takes a `std::string_view`, but other use cases now become ambiguous, and need to be addressed separately either by yet more additional overloads, or by templating some of the overloads, which is fragile. And, this doesn't solve the problem of the return value. No matter what is returned, some of the users will not be able to store the return value in their preferred string_view. A string_view type that converts from and to std::string_view solves this problem, as the API above now works for both passing, and storing the result into, `std::string_view`. boost::core::string_view is this type. The alternative is for every library that has the above problem to supply its own string_view, which will be a copy of boost::core::string_view. This is exactly why Core was created - to factor out duplicate functionality. (Before you suggest that the library should use boost::string_view under C++14 and std::string_view under C++17, note that this makes it impossible to build the library under C++14 and use it from C++17, which is a common scenario when using the system-provided Boost package.)"
"On 2/22/23 3:10 PM, Glen Fernandes via Boost-announce wrote: > Furthermore, as Boost release managers we support authors exercising > this freedom, and do not intend to impose any restrictions on what > language support they must maintain. I believe that traditionally, new boost libraries have been required to compile and pass tests using that the latest version of C++. I don't believe that similar requirements on pre-existing boost libraries as C++ evolves ... or am I wrong about this? If a library stops working because it depends upon something that has been deprecated, should the library be suspended from being in boost? I gather not. I'm not advocating for this. I think the stated policy is correct as it stands, but that leaves a few questions unanswered. Generally, library maintainers want their code to survive and usually maintenance is not a huge time suck. If no maintainer is sufficiently interested to follow this policy or if the library is hard to maintain, maybe it's time it should be set aside. Robert Ramey"
"On 2022-05-08 at 11:31, Christopher Kormanyos via Boost wrote: > >> Even though 14 has lotsof bug fixes, >> the only real key advanced featureis>> relaxed constexpr constraints >> and digit separators. > I apologize for my perhaps unwisely chosen(or even wrong) wording. > >> I'd say that polymorphic lambdas, lambda> capture initializers, return type deduction,> decltype(auto) are all more important> and really felt. > ... And I do respect this comment. > But I'm not quite ready to give upon eleven just yet... > > Let's argue the controversial C++11/14baseline issue from a purely service-oriented,product-management point of view. > Boost has a deep symbiosis with C++11and vice-versa. There are clients usingBoost with C++11. > To drop C++11 from a product/servicepoint of view should only be allowed ifa viable option is provided --- freelyand easily obtained --- for those clientsusing Boost with C++11. > So I would say, prove to the clients,prove to ourselves what this optionactually is. Which option will allowclients stuck on C++11 (maybe notby choice) to continue to use Boostwithout C++11 support? It can also be argued that we might do some clients a disservice instead of a service. If the new features are *that* useful for the library authors, would they not be equally useful for the clients' code? By supporting old compilers and standards we let them procrastinate for another couple of years. Is that good? Or should we encourage them to move on? Perhaps a gentle push is all they need? "New and improved" is often used in product-marketing. Why not here? > One possibility comes to mind:Freeze at 1.80 if you need C++11,but I don't like this option. > > Kind regards, Chris > >"
"We could maybe solve the publicity issue by having the implementation become a typedef when the header is available. This creates ABI issues when linking against binary archives but at least maintains API compatibility, i.e. a user who wrote a function taking boost::compat::latch can pass a std::latch in C++20 mode. >From my own experiences, this seems to be in line with what users actually want, where Boost's polyfills become their stdlib counterparts when available. No one's said anything about the quality of the implementation or the tests, which is worrisome to me. - Christian"
"On 30/12/2020 15:04, Edward Diener via Boost wrote: > On 12/30/2020 7:20 AM, Paul A Bristow via Boost wrote: >> Boost.Math has a documented minimum requirement of C++11 (but many >> library functions, distributions etc still work with C++03, and some >> new library items require C++17, and some are likely to require C++20 >> very soon). >> >> I'm sorry that this doesn't fit neatly into your schema â˜¹ > > I think then 'cxxstd' should be '11' for Boost.Math. Does this also > need to be set for any of: > > Math Common Factor > Math Octonian > Math Quaternion > Math/Special Functions > Math/Statistical Distributions All of them come under Boost.Math, and all are moving to C++11 in the next release (OK, so here and there stuff may work in C++03, but it won't be tested any more). Likewise Multiprecision is moving to actively require C++11 in the next release. Also Regex will deprecate C++03 in the next release - it will continue to work for a bit but the future is C++11. HTH, John. > > ? > >> >> Paul >> >> >>> -----Original Message----- >>> From: Boost <boost-bounces_at_[hidden]> On Behalf Of Edward >>> Diener via Boost >>> Sent: 30 December 2020 04:23 >>> To: boost_at_[hidden] >>> Cc: Edward Diener <eldiener_at_[hidden]> >>> Subject: [boost] C++11 on up Boost libraries >>> >>> In my effort to set the meta information of 'cxxstd' for the >>> appropriate >>> C++11 on up libraries, my PRs for these libraries have been kindly >>> merged to 'develop' by the library maintainers: >>> >>> beast >>> callable_traits >>> context >>> convert >>> coroutine2 >>> fiber >>> geometry >>> gil >>> hana >>> histogram >>> hof >>> json >>> leaf >>> mp11 >>> nowide >>> outcome >>> pfr >>> process >>> safe_numerics >>> static_string >>> stl_interfaces >>> variant2 >>> yap >>> >>> If anyone knows of any other current library which is a C++11 on up >>> library, please tell me. My testing showed that all other Boost >>> libraries will work in C++03 mode, but maybe I missed some other >>> library >>> which is a C++11 on up library. >>> >>> Needless to say other libraries have noted their attention to move from >>> C++03 to C++11 in the near future. If any library does change the C++ >>> mode necessary to use that library, I hope the maintainer(s) of that >>> library will update the 'cxxstd' meta information appropriately. >>> >>> If we can get the website to work properly using the 'cxxstd' meta >>> information, end-users should be able to know immediately whether a >>> Boost library is usable depending on the C++ standard mode their are >>> using. >>> >>> >>> _______________________________________________ >>> Unsubscribe & other changes: >>> http://lists.boost.org/mailman/listinfo.cgi/boost >> >> >> _______________________________________________ >> Unsubscribe & other changes: >> http://lists.boost.org/mailman/listinfo.cgi/boost >> > > > > _______________________________________________ > Unsubscribe & other changes: > http://lists.boost.org/mailman/listinfo.cgi/boost"
"Vinnie Falco wrote: > I'm considering bumping up the C++ language requirement for Boost.URL > from C++11 to C++14. > 3. Do you know of any regional or global metrics on who _cannot_ use > libraries which require C++14? There were questions about what C++ versions people were able to use in the recent C++ developer survey: https://isocpp.org/files/papers/CppDevSurvey-2022-summary.pdf Moving from C++11 to C++14 reduces the percentage of respondents who can use "pretty much all" of the features of that version from 89.9% to 82.9%. Personally, my only limitation is what Apple's clang derivative supports; currently it lacks some C++20 features. Regards, Phil."
"On 2/4/23 15:08, Peter Dimov via Boost wrote: > Greetings, > > I have a novel idea, let's drop C++03 support. > > The reasons to do that have been explicated already > a number of times, e.g. in > > https://pdimov.github.io/articles/phasing_out_cxx03.html#_ongoing_costs_of_maintaining_c03_support > > but in brief: > > * C++03 is 20 years old. > * A number of intra-Boost dependencies can be > eliminated by using the standard equivalent of > Boost components. This will help Boost to become > "more modular". > * Variadic templates allow us to remove the uses > of Preprocessor and MPL, which are the primary > contributor to slow Boost compilation times. > * Almost no new C++03 development occurs in > Boost at this point, so C++03 users do not need > to upgrade their Boost. > > To that end, I propose the following: > > Boost release 1.82.0 is announced as the last one > with C++03 support. If critical problems are found > in it post-release, we will issue 1.82.1, 1.82.2 and > so on, as appropriate (as C++03 users will not be > able to just upgrade to 1.83.) For this to be possible, a separate set of branches need to be created for each library and the superproject. Possibly, CI scripts needs to be updated to test the new branches. Also, I suggest we name the first Boost version that requires C++11 as Boost 2.0 and the C++03-compatible releases continue to be 1.x. The compiled binaries for 2.x should be named differently from 1.x, i.e. add a new tag in 2.x binaries. This will make it easier for downstream consumers to ship 2.x and 1.x releases side by side, should it be needed. Point releases may not be convenient for downstream since, for example, Debian dev packages for Boost are named as libboost-math1.74-dev (no point version). > Boost release 1.83.0 is announced to require C++11 > at minimum. This means compilers that have all the > C++11 standard headers, and support all the C++11 > syntactic constructs and keywords without issuing > errors. (E.g. VS2013 doesn't qualify because it doesn't > support the `constexpr` or `noexcept` keywords.) For gcc, the minimum version would be 4.8.1: https://gcc.gnu.org/projects/cxx-status.html#cxx11 For clang, it's 3.3: https://clang.llvm.org/cxx_status.html#cxx11"
"> - Which library/ies are you maintaining? (I assume this isn't some > sort of private information - otherwise ignore the question) Too many ;) Math, Multiprecision, Regex, Type_traits, Config > - Would you like to unconditionally use c++11 features if you would > not have to worry about this breaking boost internal users? Multiprecision: Builds with 03, but already makes fairly heavy C++11 use, and C++11 or later is really required for full functionality. C++03 support requires little maintenance other than some #ifdef's for rvalue refs etc.Â Fairly heavy use of noexcept is also used, but IMO this is an untestable abomination anyway.Â Generalised constexpr in C++14 is more useful than C++11, along with really robust SFINAE and enable_if support (in theory this is C++11-ish, but there are many early C++11 compilers which choke on the code, along with more recent C++03 compilers which handle things fine). Math: historically needs nothing that isn't in C++03.Â Constexpr support has been gradually added to parts of the library, but is easy to macro-ise around.Â Recently, some new components have been added which are more like C++14 as they really need generalised lambdas to work well.Â The nicest feature to have would be constexpr-if, but that's C++17. TypeTraits: All the old C++98 cruft is still there, I don't intend to ever change it, and if someone files a bug against say VC7.1, the answer will be "upgrade your compiler".Â There are C++11,14 and 17 isms throughout added to support newer features in new compilers. Many traits only work correctly post C++11.Â The whole thing could probably be greatly simplified post C++11, but I don't see much gain from going through and ripping out the old code.Â For folks that want to read the source, I try to keep the "modern"/conforming implementation first in the file, at least in new code. Regex: was obviously designed when C++98 was still being formulated ;)Â Rvalue refs are the only C++11 feature that's nice to have, other things like C++17's string_view support will gradually get added in time no doubt. > > - Would you like to unconditionally use c++11 features if you would > not have to worry about this breaking any users? Not especially, though I dare say I would just to save a few #ifdef's in new code. > > - Would you deprecate your library completely if there were no > boost-internal users and your current dependencies required > c++11 (e.g. because your library has been merged into the c++11 > standard library anyway) No.Â While regex is in the std, I believe Boost.Regex continues to offer useful enhancements. Type_traits is an interesting one - if people stop using it, then deprecation might be an option. > > - Are you yourself using any boost library (in an up-to-date version) > in a c++03, non-boost project? No. > > - Do you have any Idea if the latest versions of your library is > used by any important/significant number of c++02 projects? > [It is only important if *you* consider those projects important > and or the number significant] No.Â Generally I get more bug reports relating to very recent C++ versions that I haven't quite caught up with yet.Â Of course these are mature libraries, so the C++03 side of things should be pretty stable. HTH, John."
"On 8/02/2023 01:06, Kostas Savvidis wrote: > I would add to the reasons the complete absense of any messages of protest on this list from projects that use boost with a 03-only compiler. > That is, assuming, > A) such projects exist and, > B) they do upgrade to new boost versions instead of being stuck on some version which came out at a time when their project originated. FWIW, as I said the last five times this topic came up, while I do indeed have some projects stuck on C++03 (and even older!) compilers, they're also permanently pegged to older Boost versions, and I don't forsee any reason to upgrade them in the future. I would imagine most others in a similar situation have similar views, though I might be wrong. Anyone required to use an old compiler is probably targeting an entire old ecosystem, that would naturally have old versions of all dependencies, including Boost. The rest probably could upgrade compiler flags if given a sufficient nudge. So I fully support existing libraries dropping C++03, especially if that might make them more likely to use C++11 or higher features where currently they might be avoiding them. All my "current" projects target C++17 at present. I'm less inclined towards dropping libraries entirely (though not strongly opposed -- if no willing maintainer comes forward after a specific library is put into the crosshairs, perhaps it deserves to die) or "Boost 2.0", but then that wasn't Peter's proposal anyway."
"Iâ€™m Matt Borland, who many might recognize from my work in Boost.Math and fewer might know from Boost.Multiprecision. Iâ€™m putting the finishing touches on a new library that I hope will become part of Boost, after a successful formal review. This library is essentially already part of C++17 and later but in the Boost tradition we wish to provide it for users and other Boost libraries that want to fully support C++14 or C++11. What does charconv do? It converts a character sequence into a number (from_chars) or converts a number into a character sequence (to_chars). This is similar to strtod and printf with a few key differences. First and most important is a roundtrip guarantee. That is a number converted into a character sequence, and then back into a number will be identical to the starting value. Second, you can easily specify an input/output format with a chars_format argument, and also provide a target precision. Third, it is much easier to check for errors. Strtod has a few different ways of reporting different errors whereas the results of to_chars returns an error code from errno. Using this is no different from POSIX where you check for 0 and then move on. We use errno rather than std::error_code as specified in the standard. This allows us to avoid including <system_error> and is more ergonomic. Lastly, charconv is significantly more performant than strtod and printf. We utilize algorithms derived from Daniel Lemireâ€™s â€œNumber Parsing at a Gigabyte per Secondâ€ and Junkey Jeonâ€™s Dragonbox. You can read about those here: https://arxiv.org/abs/2101.11408 https://github.com/jk-jeon/dragonbox And here are a number of example snippets: https://develop.charconv.cpp.al/ As of now the library supports all built-in integer types, signed and unsigned __int128, float, and double. I am striving to add support for long doubles (64, 80, and 128-bit) to both from_chars and to_chars. With these in hand I have a mind to experiment with integrating this into Boost.JSON, which for lack of a better phrase, sure could use a bit of help with its conversions between IEEE floats and decimal strings. This will also help with checking our validation, accuracy, and performance. If you want to check out the library it is here: [https://github.com/cppalliance/charconv](https://github.com/CPPAlliance/charconv) It is designed to be built and used in the Boost superproject. This means that if you want to clone it, you should place the repository in the libs/charconv directory of your local superproject. Feel free to hammer on it, and report any errors or performance issues that you run into. Also if you find the docs could use improvement please open an issue so that we can address it. These will help us ensure that we have the highest quality product before attempting to pass a formal review for inclusion in Boost. Thank you for your time. Matt Borland"
"On Tue, Aug 28, 2018, 14:37 Mike Dev via Boost <boost_at_[hidden]> wrote: <...> > - Which library/ies are you maintaining? (I assume this isn't some > sort of private information - otherwise ignore the question) > Any, Conversion, DLL, LexicalCast, Stacktrace, TypeIndex, Variant. - Would you like to unconditionally use c++11 features if you would > not have to worry about this breaking boost internal users? > This could be usefull for Variant - it will make the library slightly smaller and well maintainable. But not much better. - Would you like to unconditionally use c++11 features if you would > not have to worry about this breaking any users? > Same as above. - Would you deprecate your library completely if there were no > boost-internal users and your current dependencies required > c++11 (e.g. because your library has been merged into the c++11 > standard library anyway) > Not for c++11. - Are you yourself using any boost library (in an up-to-date version) > in a c++03, non-boost project? > No. - Do you have any Idea if the latest versions of your library is > used by any important/significant number of c++02 projects? > [It is only important if *you* consider those projects important > and or the number significant] > There are plenty. =======Please quote till here ====================================== > Actually, I'd like to go further than you propose. There's a plenty of request to use C++17 classes in the Boost libraries I maintain. So my idea is to start a new fork/branch of Boost that requires C++17 compatible compiler. This will allow library developers to use modern features, experiment with them and invent cool things. This will allow me to drop Any and Variant. This will also allow me to * significantly improve/rewrite LexicalCast and drop the std::locale dependency that insanely slows down the runtime * implemet a DLL library that uses std::filesystem::path and std::system_error without unnecessary dependencies on Boost For the remaining libraries I'll be able to drop Config, TypeTriats and some other dependencies. This will improve compile times and reduce LOC to maintain. Best regards and thank you for your time > > Mike >"
"I've been toying around with a pull request that was entered against boost::range to support integration of boost range_v2 and C++20 ranges to see how flexible it would be: https://github.com/boostorg/range/pull/123 I have a need to continue to use boost::any_range in some of our interfaces, but it would be nice to switch to using C++20 ranges under the covers. A lot of it seems to work well with the type definitions from the pull request, but I'm running into an issue with concept check on line 228 or any_iterator_wrapper.hpp specifically when using the transform adaptor. I don't have the same issue with boost::adaptors::transformed. What has me confused is that I think that the result views::transform should be forward traversal, but I'm not really clear on exactly why it is failing. I created a test if anyone wants to play around with it in a compiler and help me understand what is going on: https://godbolt.org/z/1hMsofbrv Switching between the two commented out base_range declarations will get you different results. Here is the code for anyone that just wants to look at it here: #include <boost/range.hpp> #include <boost/range/adaptors.hpp> #include <boost/range/any_range.hpp> #include <ranges> #if 1 namespace boost::range_detail { template< std::ranges::common_range C > struct range_mutable_iterator< C > { typedef std::ranges::iterator_t< C > type; }; template< std::ranges::common_range C > struct range_const_iterator_helper< C > { typedef std::ranges::iterator_t< C const > type; }; } #endif int main() { std::vector<int> vec(5, 0); auto mul2 = [](int i) { return i * 2; }; auto base_range = vec | std::views::transform(mul2); //auto base_range = vec | boost::adaptors::transformed(mul2); boost::any_range<int, boost::forward_traversal_tag> new_range = base_range; }"
"> Gesendet: Montag, 26. Oktober 2020 um 11:41 Uhr > Von: "Mateusz Loskot via Boost" <boost_at_[hidden]> > > On Mon, 26 Oct 2020 at 11:17, Mike via Boost <boost_at_[hidden]> wrote: > > > E.g. I think the first c++17 bits have been implemented in > > gcc 6 and gcc 7 had mostly complete support, but it took > > till gcc 9 before the standard library gained support for pmr > > and to_chars is - to the bestof my knowledge - still not > > implemented for floating point types even in g++-10/11. > > One of motivations is to drop support for GCC 5, > It just seem simpler to assume C++17 as requirement > with comment that some compilers w/ partial C++17 > support may still work. The problem I see is: If you are pedantic, then there isn't a complete c++17 toolchain on linux yet. So unless you are saying, all current version of gcc/clang/libstdc++ "may still work" but are not really supported, you need to be more specific in what you require and support. Where support means (to me) "Will be regularly tested and will continue to work for the next couple of releases/years". > It may also be possible to list required C++17 features > per Boost (GIL) release, but that list may change > in any next release, obviously. I wouldn't go there, because it isn't easy to actually verify that the documented features and the used features stay in sync and as a user, I also wouldn't appreaciate that mode, because at that point it would probably be easier for me to just try to compile your library and tests rather than corss-check the feature sets of my toolchain and your list manually. Just give me a stable lower bound on the officially supported toolchain and language versions. Of course all that doesn't mean that you can't add a note like "Other toolchains may work too" of course, but that is pretty much always the case anyway. Best Mike > > Best regards, > -- > Mateusz Loskot, http://mateusz.loskot.net > > _______________________________________________ > Unsubscribe & other changes: http://lists.boost.org/mailman/listinfo.cgi/boost >"
"Hi, Recently, a new implementation of string_view was introduced in Boost.Core: https://github.com/boostorg/core/blob/d5bd40e5280487fb29a108eb42e6c4f0bef690d8/include/boost/core/string_view.hpp Most of you probably know there is also a string_view implementation in Boost.Utility: https://github.com/boostorg/utility/blob/05e0d1688dcfcd3fdd65bdb6884b7edd1ad2c93c/include/boost/utility/string_view.hpp The main motivation for introducing the new implementation is adding conversions to/from std::string_view, which were proposed to Boost.Utility and rejected a while ago: https://github.com/boostorg/utility/pull/51 Another notable deviation of boost::core::string_view from std::string_view and boost::string_view is that it only accepts the character type in template parameters and not char_traits. This choice was made to simplify implementation. I have concerns that introducing yet another string_view type (3rd in Boost, after boost::string_ref and boost::string_view, not counting std::string_view) is not good for the ecosystem and interoperability, as this will require adding explicit support in some code bases. One example that I readilly have is Boost.Log: https://github.com/boostorg/log/blob/4c54e4ca4c31f18ce2e451e8d0abf88054242d57/include/boost/log/utility/formatting_ostream.hpp#L558-L710 std::string_view was supposed to make user's code simpler by removing the need to provide a multitude of function overloads accepting string arguments. boost::string_view (and boost::string_ref before it) was a prototype implementation before introduction of std::string_view and served a similar purpose. In the age with std::string_view, boost::string_view is still useful as a drop-in replacement for std::string_view to lower C++ requirements in libraries and projects, like this: #if !defined(BOOST_NO_CXX17_HDR_STRING_VIEW) using std::basic_string_view; using std::string_view; using std::string_view; #else using boost::basic_string_view; using boost::string_view; using boost::string_view; #endif Introducing boost::core::string_view, which is not a drop-in replacement, does not make users' code simpler as it requires adding yet another set of overloads and specializations to users' APIs. I should stress that I'm not opposing because I don't want to make changes to Boost.Log, I'm opposing because I don't think those changes will be for the better, and because I view this as potentially destructive to the wide adoption of one common string_view type (be it std::string_view or boost::string_view, depending on the conventions taken in the project) to accept string arguments. Please, express your opinions on this matter, in particular: - Do you think it is good/ok/bad to have yet another string_view in Boost? - Is it ok that boost::core::string_view is not a drop-in replacement for std::string_view? Should it be changed to be one? - Should we, perhaps, do something with boost::string_view from Boost.Utility? Deprecate? - Should we reopen the discussion to add conversion to/from std::string_view to boost::string_view, which led to this fork? Perhaps, hold a vote to make this change as widely requested? - Any other course of action or thoughts? Thanks. PS: This post was made after an initial discussion in this commit: https://github.com/boostorg/core/commit/95924b1329da49e70c9c8485b87e066895db2d64"
"> It doesn't really matter how many dependencies Boost.Thread adds. What > matters is how expensive <boost/thread/latch.hpp> is. Personally, I > would have no problem depending on it, if I really needed this component. One problem here is that Thread is effectively unmaintained. In general, I'm not a huge fan of depending on libraries like this in my own tests because Unordered has a very strict set of flags and many Boost libraries won't clear the same bar. I remember in the past having a test dependency on one of the bigger Boost libraries and it wasn't exactly painless. I can't remember now if it was Container or Filesystem. Boost.Compat has utility in that it's essentially just a collection of substitutes for all the goodies the committee added that could've been in C++11. This benefits both authors and users massively, instead of purporting that anyone should rely on an unmaintained lib. - Christian"
"On 8/29/18 09:40, Mike Dev via Boost wrote: >> -----Original Message----- >> From: Glen Fernandes <glen.fernandes_at_[hidden]> >> Sent: Thursday, August 30, 2018 12:23 AM >> >> On Wed, Aug 29, 2018 at 11:59 AM Mike Dev wrote: >>> In any case. If you want to create a c++17 version of your libraries >>> (in particular LexicalCast) I'll support you however I can. Wonder >>> what the chances are for such a modernized library to be accepted into >>> boost. >> >> Boost has C++14+ libraries (like Hana), that require C++14 or higher. >> Boost has C++11+ libraries (like MP11, Fiber, CallableTraits), that >> require C++11 or higher. >> >> Any new library proposed for Boost can be C++17+ (i.e. require C++17 or higher). > > Sure, I'm aware of all that, but there are very few instances of a library v2. > If it doesn't bring significantly new functionality on the table (just modernized > internals and some additions) - would it really be accepted? > It would not be denied and in the past there has been direct encouragement to some authors to do just this. While there might not be significant functionality additions there are often interface improvements."
"On 04.02.23 14:34, Andrey Semashev via Boost wrote: > Is the goal to drop C++03 or unmaintained Boost libraries? Those are two > different goals. > > Personally, I don't think dropping any Boost libraries, even > unmaintained ones, benefits our users. Especially not, if it is > impossible to use Boost 2.x and 1.x in the same code base. And I suspect > that we don't want to mess with changing namespaces and macro names, > which means 1.x and 2.x are mutually exclusive in the same code base. I think if we're going to break backwards compatibility anyway, we might as well go all out and get rid of some of the cruft that has accumulated in Boost that is no longer relevant in a C++11+ world. I am thinking in particular of Boost libraries that exist only to emulate C++11 features in C++03, like Boost.Foreach. I generally favor backwards compatibility, but I also favor a single clean cut over a long drawn-out process of libraries slowly breaking due to no longer being maintained."
"I'd like to query the Boost community as to whether certain legacy features of Boost.System are in use; namely, (1) everything guarded by BOOST_SYSTEM_ENABLE_DEPRECATED and (2) the cygwin_error.hpp, linux_error.hpp, or windows_error.hpp headers. Does anyone use these, and for what purpose? I'm thinking of dropping the deprecated features. In addition, does anyone use boost::throws()? I'm thinking of at least discouraging its use in the documentation, if not deprecating it outright."
"Hi, We're discussing [1] to start switching GIL to C++17 in the near future and, following Peter Dimov's policy on phasing out C++XY support [2], we'd like to: 1. Declare C++11 support deprecated in 1.75 (December 2020) 2. Drop C++11 support in 1.77 (?) (August 2021) Could anyone help us validate and confirm that it's a good plan or are we overlooking any policies from Boost's release perspective? [1] https://lists.boost.org/boost-gil/2020/10/0465.php [2] https://pdimov.github.io/articles/phasing_out_cxx03.html Best regards,"
"On Tue, 28 Aug 2018 at 16:10, Andrey Semashev via Boost < boost_at_[hidden]> wrote: > ... If the answer is yes to the former question then this is quite a lot > of > work (e.g. in case of Boost.Log) and may even need redesigning some > parts of the library. > C++ is a major schism from C++98, this might entail re-design. You are hitting the core point of "let's drop C++03 support", you cannot and should not muddle on, it needs a re-think and a reset. This mostly relates to Boost.Atomic and the answer is absolutely not. > Boost.Atomic offers extended functionality compared to std::atomic, it > is a potential playground for future extensions that may end up in the > standard library. Then the right way forward, IMO, is to create boost::atomic v2 and bring v1 back to the std. One of the problems people run into is that things are quite similar, but not the same. v2 can then support, and continue to support the non-std features (and be a play-ground for new features). degski"
"> What "publicity issue"? Sorry for being ambiguous here. I meant the idea that Compat types shouldn't appear in public interfaces. In general, a user is going to want to use Compat because they still want to or must support C++11 while still using modern C++ types and practices. It helps users the most to permit and encourage Compat types in interfaces with the understanding that they become typedefs when the appropriate library support is there. To this end, a user can write a C++11 library using `boost::compat::span` and then seamlessly transition to using it with `std::span` in C++20 mode. In my experience, this is what most people expect and want from a compat library like what's being proposed. And because pre-C++20 has so much developer market share, I think there's tremendous value in a library like Compat. - Christian"
"Sorry for all the bad line-breaks in my previous message. I don't have access to a properly configured email client right now. This should be easier to read: ====== Original Message ============== Please, let's not derail the discussion just after some consensus has emerged and just before it actually produces actionable items. Let's not make the better the enemy of the good here. I made the suggestion to commonly drop c++03 support in the hope that it would actually lead to some code simplifications and reduced coupling between the boost libraries - even if only in their implementation (if someone wanted to do a real c++14 reboot of their library, no one is/was stopping them anyway). >From the survey, I'd say interest in actually applying c++11 features in libraries that a currently supporting 03 is already relatively low, but big enough that I believe this will actually lead to some changes other than just changing the default test settings. That is with a standard almost universally supported by compilers in use today. Even though the move from 11 to 14 is much less dramatic, c++14 support is less wide spread and outside of the big three, there are many compilers where even the most recent version doesn't support c++14, so I just don't see people that are currently maintaining c++03 support in their libraries suddenly starting to use c++14. All this doesn't preclude a discussion about if and when to move to c++14 or a general policy about LTS versions and the like, but please keep it separate unless you are really, really confident it will lead to something actionable earlier than what is currently proposed. I have lots of Ideas, how boost could be reformed and/or modernized but in the end it comes down to convince the individual library maintainers to actually do something. I think the current proposal will at least spark some action. Let the announcement to move to cmake be a warning sign about realistic expectations about the evolution of boost. Maybe I'm aiming too low, but again, if you want more, please open a separate thread and most likely, whatever you come up with there will not be mutually exclusive with what is proposed here. Regarding the test settings: If c++11 is supposed to be the lowest official supported version then that is what should be tested Anything else doesn't make sense (you can't claim to support c++11 if you don't test if it actually works there). In any case, as was mentioned before, for the announcement itself we don't need give any specifics about something that is going to happen 1-1,5 years from now. How about something like " c++03 mode/compilation will no longer be tested / part off the general test/suit"? Best Mike"
"On Mon, Oct 26, 2020 at 8:23 PM Robert Ramey via Boost < boost_at_[hidden]> wrote: > > Just out of curiosity, what new features and/or benefits (if any) will > moving to conformance with C++17 add? > just writing from the top of my head(will write details later), using C++17 GIL can be a stand-alone library."
"On 10/26/2020 11:49 AM, Mateusz Loskot via Boost wrote: > On Mon, 26 Oct 2020 at 16:16, Mike via Boost <boost_at_[hidden]> wrote: >>> Gesendet: Montag, 26. Oktober 2020 um 11:41 Uhr >>> Von: "Mateusz Loskot via Boost" <boost_at_[hidden]> >>> On Mon, 26 Oct 2020 at 11:17, Mike via Boost <boost_at_[hidden]> wrote: >>> >>>> E.g. I think the first c++17 bits have been implemented in >>>> gcc 6 and gcc 7 had mostly complete support, but it took >>>> till gcc 9 before the standard library gained support for pmr >>>> and to_chars is - to the bestof my knowledge - still not >>>> implemented for floating point types even in g++-10/11. >>> >>> One of motivations is to drop support for GCC 5, >>> It just seem simpler to assume C++17 as requirement >>> with comment that some compilers w/ partial C++17 >>> support may still work. >> >> The problem I see is: If you are pedantic, then there >> isn't a complete c++17 toolchain on linux yet. > > GIL will not require feature-complete C++17 compiler > We should be good with the last of the GCC 6 kind [1] > or we may require GCC 7. The specifics will be decided > as we go, as contributors will require. > The deal is to announce C++11 phasing out early/now, > to let ourselves time, at least two releases, but in > practices it will be longer before we bump required > compiler versions high. Worrying about gcc6 and/or gcc7, when the current release is gcc 10.2, seems a bit silly to me. I am not saying the current release(s) of gcc, clang, and vc++ are perfect in their support for C++17, but they should be good enough for any library wanting to target C++17. BTW wanting to target C++17 because it is "sexier", as opposed to having some feature(s) which the library wants to use, does not seem like a good reason to target any C++ level. I assume GIL wants to target C++17 because of the latter."
"Quick announcement: I'm planning on dropping C++98 support for Boost.Locale. I.e. require e.g. Rvalue references and std::unique_ptr to reduce maintenance effort. If anyone knows a reason to not do that please respond to https://github.com/boostorg/locale/issues/90 As per suggestion from Peter I'll add a warning for the upcoming release and will drop support in the next if there isn't anything in particular. Especially recent ICU headers already requiring C++11 is enough of a reason to not stick to the old stuff. Regards"
"Currently, `boost::throw_exception(x)` automatically throws an exception derived from `x` that (1) injects a boost::exception base class if there's none, and (2) injects a base class that enables boost::exception_ptr support (boost::current_exception and boost::rethrow_exception.) This is convenient, but the downside is the amount of generated code, e.g. https://godbolt.org/z/5T8T8GEqP (422 lines) compared to https://godbolt.org/z/1zr1odf7n (36 lines.) This is not the end of the world as this code is only generated once per exception type, not on every call to throw_exception, but it's still unpleasant to see. It so happens that boost::exception_ptr has recently acquired the ability to work under C++11 without the need for the supporting base class, by using the standard std::exception_ptr infrastructure. So if we also remove the automatic injection of boost::exception as a base class, and ask users to derive their exceptions from it if they desire having it as a base, it's possible to simplify boost::throw_exception considerably. The normal call now can be almost the same as the naked throw, https://godbolt.org/z/WssWzfrfW (47 lines.) And if BOOST_THROW_EXCEPTION is used, which still adds the source location (file/line/function) to the exception, the result is 97 lines. (https://godbolt.org/z/nETnqrsx8) However, there is a downside. Due to the way std::exception_ptr works under GCC/Clang (and all compilers using the same ABI), the exception is never copied, not when it's captured with std::current_exception (and consequently boost::current_exception), nor when it's rethrown with boost/std::rethrow_exception. This causes problems if an exception is captured, rethrown, caught and modified, then rethrown again using the same exception_ptr. The second rethrow throws the modified exception. This problem can be seen in https://godbolt.org/z/K9eh71ovP. So... what do we do? Should I go ahead with these changes to throw_exception (having a macro to revert to the old behavior, of course)? Or is that too much of a break? We can of course offer the same functionality as part of Boost.Exception, like boost::exception::raise, or similar, but would that be enough to offset the inconvenience?"
"On 8/28/18 8:40 AM, degski via Boost wrote: > On Tue, 28 Aug 2018 at 17:54, Robert Ramey via Boost <boost_at_[hidden]> > wrote: > >> ... upgrading working code from C++03 to C++11 isn't going >> to add any benefit, so there it's more attractive to spend one's efforts >> somewhere else. >> > > You don't think that move semantics have had a significant impact on C++ > then? Maybe it has not affected BS, and you seem to say there are no > benefits to be had from move semantics in BS. Is that really really true? > > degski > Actually, I think the the impact of move semantics on performance of well written existing code is minimal. On new code which uses more types as values it's helpful. Of course if the library were written today, it would all the new stuff. I don't think it would be faster (unless it were made header only) but it would likely have have half the number of lines of code (or less). But the years long slog to address corner cases, workarounds for compiler bugs and standard library bugs, etc. And there would be design changes which would also create a bunch of ripple effects. So it would really end up as a whole re-write. Robert Ramey"
">> On 7/13/21 9:41 PM, Oliver Kowalke via Boost wrote: >>> Hi, >>> does boost still support Cpp03 or is Cpp11 the min. standard? >> There is no single answer to that. Every library maintainer decides for himself. You can have a look at the documentation on https://www.boost.org/doc/libs/ which lists the C++ min. level that libraries require. Some are missing, you may check their respective docu and/or open an issue in their repos. To summarize: - Libraries decide on their own what they require - If Boost.X uses Boost.Y and Boost.Y requires C++11, then so does Boost.X (obviously) - Many libraries enable additional features on newer standards - The level listed on the above page list the minimum required for the library to compile/work at all FWIW: Using C++03 in 2021 is an anachronism. Seriously: Save yourself the pain and go to C++11 at least."
"I did the same thing with smart_ptr, allowing for a transition between boost and std in the Apache Thrift project going from C++03 to C++11. Unfortunately it was a bunch of trial and error as no macro seemed to cover it completely. https://github.com/apache/thrift/blob/master/lib/cpp/src/thrift/stdcxx.h - Jim On Sun, Sep 10, 2017 at 8:28 PM, Niall Douglas via Boost < boost_at_[hidden]> wrote: > On 10/09/2017 20:07, Glen Fernandes via Boost wrote: > > On Sun, Sep 10, 2017 at 1:30 PM, Robert Ramey via Boost wrote: > >> How do I get ready for C++17? > >> > >> I have a piece of code which requires C++14. I want to use something > from > >> C++17 but I also want my code to work now. So I have > >> > >> #if C++14 being used > >> namespace std { > >> // implement C++ function > >> } > > > > Don't define those things inside namespace std. Instead: > > > > namespace boost { > > namespace yours { > > namespace detail { > > #if /* C++17 thing available */ > > using std::thing; > > #else > > /* Define thing yourself */ > > #endif > > } } } > > > > And then use boost::yours::detail::thing in your library. > > And here is an example of use of exactly that technique which uses > std::optional if available with the current compiler's configuration, > otherwise a conforming optional<T> implementation: > > https://github.com/ned14/quickcpplib/blob/master/include/optional.hpp > > Niall > > -- > ned Productions Limited Consulting > http://www.nedproductions.biz/ http://ie.linkedin.com/in/nialldouglas/ > > > _______________________________________________ > Unsubscribe & other changes: http://lists.boost.org/ > mailman/listinfo.cgi/boost >"
"> On May 10, 2023, at 5:42 PM, Dominique Devienne <ddevienne_at_[hidden]> wrote: > > On Wed, May 10, 2023 at 4:01â€¯PM Matt Borland via Boost <boost_at_[hidden]> wrote: > >> [...] We use errno rather than std::error_code as specified in the standard. > > Hi. Sounded like a good candidate for Boost.Compat (or Boost.Polyfill), > discussed recently, until that sentence. I'm lucky enough to be able to use > C++17 at work, but if I was on C++11, I'd tend to use such a library until > I could use the std one, so deviations like this would complicate adoption > because moving to std would then be harder. My $0.02. â€”DD Dominique, Thanks for the response. We discussed Boost.Compat but decided it is outside of the scope. For instance <latch> is what set off the discussion and it can be implemented in ~100 LOC. This implementation of charconv will be around 10k LOC so it should be in its own library. If the demand signal is to use std::error_code instead of errno we can make the change. Matt"
"On 8/28/18 10:21 AM, degski via Boost wrote: > On Tue, 28 Aug 2018 at 19:06, Robert Ramey via Boost <boost_at_[hidden]> > wrote: > >> Actually, I think the the impact of move semantics on performance of >> well written existing code is minimal. On new code which uses more >> types as values it's helpful. >> > > I don't think it has anything to do with whether the code is well written, > copying a pointer f.e. is not the same as copying a whole array of data, > because that could [should be] be the difference between move assignment > and copy assignment. right. One who is thinking about what he's doing is not going to copy a whole array of data if he's using C++03. But since C++11 makes it efficient, he may. So compiling C++03 code with a C++11 compiler isn't going to make a difference. > > Of course if the library were written today, it would all the new stuff. >> I don't think it would be faster (unless it were made header only) but >> it would likely have have half the number of lines of code (or less). >> > > Header only is of no interest, whatsoever, in terms of performance, that's > not how things work (inlining could be affected, but that's about it, I > would say) LOL - inlining IS the essential difference with a header only library. It would eliminate one move in the serialization libary. And that would double the speed. This is why a C++11 serialization library (cereal) is twice as fast as boost serialization and other libraries. >> But the years long slog to address corner cases, workarounds for >> compiler bugs and standard library bugs, etc. And there would be design >> changes which would also create a bunch of ripple effects. So it would >> really end up as a whole re-write. >> > > Yes, it's a major job, hence all the resentment. It's not just resentment - there's just no benefit to it. > > degski >"
"On 2/23/23 19:27, Peter Dimov via Boost wrote: > > No, core library maintainers can't just go ahead and make their libraries C++20. > They wouldn't be core library maintainers if they did things like that. The moral... obligation (I'm not sure this is the right word) to your users to continue supporting the old C++ standards remains the same regardless of what we do or don't announce Boost-wide. Even if the release managers decided to announce that the next Boost release no longer supports C++03, I would still be reluctant to remove said support from my libraries, as long as I know there are C++03 users. That is until I'm no longer willing to support it, at which point, again, it doesn't matter what release managers say. For this reason I find proposals like this pretty much moot, sorry."
