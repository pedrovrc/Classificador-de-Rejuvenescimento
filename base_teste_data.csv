"Hello, * Problem description The constants do not work with the C++23 FP types. * general hint To prevent (more) warnings it is useful to introduce this macro: #if defined(__STDCPP_FLOAT128_T__) #define BOOST_FLOATMAX_SUFFIX F128 #elif defined(BOOST_CSTDFLOAT_FLOAT128_NATIVE_TYPE) #define BOOST_FLOATMAX_SUFFIX Q #else #define BOOST_FLOATMAX_SUFFIX L #endif * question In constants the namespaces float/double/long_double_constant+detail are created type dependent (in case the value constexpr can be requested). If the value cannot be requested constexpr the conversion is finally done by boost::lexical_cast. But the implementation is very complex. I have a better one - but I may have missed things. If so - which would they be? * My solution (BOOST_MAKE_MATH_CONSTANT) see constants_more.hpp, advantages: - works with all FP types - compatible to the existing implementation CONSTANT<Type>() - is clear/understandable (comments) - may need only one additional namespace static_constants (and not 4) - provides the constants additionally as CONSTANT_v (constexpr) or static_constants::CONSTANT_v (not constexpr) (if possible) What is your opinion? Are there still errors in it? It would be even nicer if boost::lexical_cast and/or boost::math::tools::convert_from_string were constexpr. This would further simplify the implementation. thx + regards Gero"
"James King wrote: > I thought Peter Dimov got it right from the comment I saw earlier. > The project would no longer spend time and effort on qualifying or testing > C++03 compatibility. CI builds and the test matrix would no longer > specifically test C++03. The default language level for b2 builds would be C++11. Sounds right. All of these above is a much more useful statement to make to users. > Individual repository maintainers could attempt to continue to qualify > for C++03 however once an upstream dependency begins to include > C++11 code, that effort would have to give way. If an upstream dependency only works in C++11 and above, and the library maintainer wants to support C++03, they can either: A) Drop the dependency and still support C++03 B) Drop C++03 support But again it will be up to that library maintainer. > As a developer both working on and > consuming boost I would appreciate the permission to start using C++11 > without fear. You will be able to start using C++11 in the libraries that you maintain, without fear. You won't be able to force another library maintainer to let you use C++11 unconditionally in their library if they want to support C++03 users. Glen"
"On Thu, May 5, 2022 at 10:59 AM Mateusz Loskot via Boost <boost_at_[hidden]> wrote: > > On Thu, 5 May 2022 at 16:26, Kostas Savvidis via Boost > <boost_at_[hidden]> wrote: > > [...] > > In other words, boost needs to shrink not grow. > > I mostly agree, but I'd say Boost needs to undergo a restructurisation to > remain attractive to all generations of developers, maintainers and users. > > I can't see it happen unless we have separate superprojects: > > github.com/boostorg/boost (require>=C++17) > github.com/boostorg/boost11 (>=C++11 ) > > and, if still relevant, perhaps: > > github.com/boostorg/boost03 > > As a maintainer, I'd like to be free to maintain a library > only for e.g. boostorg/boost and forget about > boostorg/boost11, or let new maintainer to take it > over there. About shrinking boost: I see no reason to have separate superprojects for different language levels. Why not simply have a concerted effort to remove C++03 support? If people still are using C++03 then they can use an older release of Boost until they make the transition. Stop testing it, stop saying it works, and allow C++11 in those libraries. The savings to CI time alone would be quite profound. I would like to see the floor move to C++11 at this point. In cases where the standard library has implemented something like what boost delivers in the C++11 standard, then it would also be reasonable to drop those boost libraries because, again, people can use an older release of Boost until they make the transition. If the project regularly claimed support for 3 back-revisions of language then with C++23 is released, C++20, C++17, C++14 would be "officially" supported and C++11 would be dropped. That simply means it is no longer tested or fixes made; people can use an older boost version until they make the transition. Having a hard-and-fast rule like this makes things way more predictable for all of us and all the consumers. About C++ in general (20/50 yrs): In comparison to other languages, C++ package management still seems like it is struggling. I guess you can use conan and cmake together but I haven't done enough to know how easy or difficult it is to do, and it looks like there are platform specific instructions for either. Having worked with python, javascript, perl and rust as well, the package management systems have their warts but generally make it a lot easier to consume external work and release work to others. It is a significant weakness in the ecosystem. - Jim"
"On 8/28/18 4:37 AM, Mike Dev via Boost wrote: > =======Please quote from here ====================================== > > - Which library/ies are you maintaining? (I assume this isn't some > sort of private information - otherwise ignore the question) Boost Serialization > > - Would you like to unconditionally use c++11 features if you would > not have to worry about this breaking boost internal users? There is no value to these features at this point > > - Would you like to unconditionally use c++11 features if you would > not have to worry about this breaking any users? > > - Would you deprecate your library completely if there were no > boost-internal users and your current dependencies required > c++11 (e.g. because your library has been merged into the c++11 > standard library anyway) hmmm - normally I just respond to bug reports. If there are no users there would be no such reports so probably nothing would happen. > > - Are you yourself using any boost library (in an up-to-date version) > in a c++03, non-boost project? within the boost serialization library or in other projects? In any case, I just incorporate an std header if there is one, next I select a boost header, and finally I write it myself. > > - Do you have any Idea if the latest versions of your library is > used by any important/significant number of c++02 projects? > [It is only important if *you* consider those projects important > and or the number significant] I have no idea how frequently the boost serialization library is used. I'm sort of thinking it's more than 25 times. But I have not statistics on this. I would love to know this. ==== The one thing that might happen in the future is that BS depends upon some other boost library which gets "upgraded" to C++11 so that BS is no longer compatible with C++03. But this seems unlikely. Boost libraries don't get much maintenance. Once it works and passes all tests, no one messes with it. upgrading working code from C++03 to C++11 isn't going to add any benefit, so there it's more attractive to spend one's efforts somewhere else. Robert Ramey"
"El 28/08/2018 a las 13:37, Mike Dev via Boost escribiÃ³: > - Which library/ies are you maintaining? (I assume this isn't some > sort of private information - otherwise ignore the question) MultiIndex and Flyweight (I also maintain PolyCollection, but this is C++11 from scratch). > - Would you like to unconditionally use c++11 features if you would > not have to worry about this breaking boost internal users? > > - Would you like to unconditionally use c++11 features if you would > not have to worry about this breaking any users? Yes. But I find these questions slightly misleading: If I don't have to worry *at all* about the consequences of using something, of course I'd be willing to use should it come handy. In practice, I fix bugs and add features respecting the C++03 baseline because I *do worry* about breaking my users. If something can't be written or it's too hard to emulate in C++03, I do it in C++1x and guard the code for backwards compatibility (for example, see https://www.boost.org/doc/libs/develop/libs/multi_index/doc/tutorial/key_extraction.html#key ). > - Would you deprecate your library completely if there were no > boost-internal users and your current dependencies required > c++11 (e.g. because your library has been merged into the c++11 > standard library anyway) If any of my dependencies upgraded to require C++11+ I'd make an effort to replace it or, if the dependency is isolated within one particular feature, guard this feature to protect C++03 users and move on. If the thing became unmaintainable then I'd be forced to require C++11 myself: in practical terms, I see this scenario quite unlikely. My dependencies are: assert bind config container_hash core detail foreach integer interprocess iterator move mpl parameter preprocessor serialization smart_ptr static_assert throw_exception tuple type_traits utility which are either basically frozen (bind, foreach, mpl, preprocessor, etc.) or are designed with backwards compatibility in mind (move, config). From time to time I find a dependency has broken in an old compiler (e.g. MultiIndex currently breaks in MSVC 7.1 due to a problem with Integer: https://tinyurl.com/yavmhudg ). If the compiler is really really old I usually do nothing except when some actual user files a ticket. > - Are you yourself using any boost library (in an up-to-date version) > in a c++03, non-boost project? No. > - Do you have any Idea if the latest versions of your library is > used by any important/significant number of c++02 projects? > [It is only important if *you* consider those projects important > and or the number significant] I maintain a private record of projects/companies using MultiIndex that currently has ~300 entries, including, to drop some names: PowerDNS, CERN, Industrial Light & Magic, Autodesk, Amazon, MongoDB, Adobe, Baidu, BMW, Apple, Bitcoin. I assume real figures can be easily much higher (these are only projects I found on Internet). I don't know for sure, but I'd be surprised if all/most of these guys have already migrated their codebases to C++11. I don't know if they stick to an older version of Boost or regualrly update. For Flyweight I see very little use. Best regards, JoaquÃn M LÃ³pez MuÃ±oz"
"On 6/05/2022 12:08, James E. King III wrote: > I for one would enjoy updating Boost.CI and the 16 Boost libraries > that I maintain to stop running C++03 tests through CI and stop > claiming support for utterly ancient EOL compilers, as well as > language levels. As far as I was aware, it was already agreed several years back that maintainers of individual "leaf" libraries could decide to stop supporting pre-C++11 pretty much whenever they like (one or two versions of deprecation warning appreciated), and that new libraries did not need to be backwards compatible. It's a little murkier for libraries that are depended on by other libraries; there you had to get consensus from the downstream library maintainers to stop supporting pre-C++11 too, either simultaneously or earlier. I would personally argue that it makes sense now to move that forward to C++14 rather than C++11, but I don't think that's actually been formally discussed yet. There's a certain amount of resistance to "forcing changes" on libraries that don't really get touched year-to-year, because changes require work and have potential to introduce bugs. While there are some benefits to rewriting older code to remove workarounds and use more modern patterns (making future maintainability easier), there is still merit in that reluctance. But agreeing to stop supporting C++03 does not necessarily require code changes -- the absolute minimum would be to just stop running the CI for it, and an only slightly higher bar would be to change the build settings to refuse to compile. (Although some people are reluctant to go even that far -- if they're not actually changing the library to take advantage of C++11 then there's no technical reason why it wouldn't compile under C++03, so why block it? But there can be non-technical reasons why this may still be a good idea.) There's also some complexity in what "stopping supporting C++03" means, even if the maintainer does want to make code changes. Like it or not, there are differences between std:: and boost:: classes even where those largely intersect (e.g. threading, smart pointers, optional) and some have features or support that the other lacks. But even where functionality is sufficiently identical, swapping is an API-breaking change that will require edits to all downstream code -- probably trivial ones, and which the compiler will readily identify for you, but still there nonetheless. And there's a certain reluctance (rightly or wrongly) to impose that as well. There was an attempt a while ago to make this the end-user's responsibility to choose between the implementations via macros and policy templates, but it didn't really catch on (and I'm not convinced that it should). Given that C++ itself is largely backwards compatible (and despite the trash-talk I and others often give it for using the wrong defaults for everything as a result, this is a good thing); it's usually not hard to migrate an application code-base from C++03 to at least compiling without issue in C++14 or beyond, even if not taking advantage of new features or idioms. So it should not be a difficult barrier to say "hey, update to C++ab or this library will stop working". Applications and compilers already have to cope with a mixture of different standard levels intersecting."
"On 29/08/2018 20:51, Andrey Semashev wrote: > On 08/29/18 04:00, Gavin Lambert wrote: >> On 29/08/2018 01:09, Andrey Semashev wrote: >>> For example, if I'm currently using Boost.Move or boost::shared_ptr, >>> does this mean I have to port my code to native rvalue references and >>> std::shared_ptr? >> >> AFAIK, migrating from Boost.Move to native references is largely >> invisible to external C++11 consumers, so as a maintainer you could >> decide to leave the existing code (for reduced churn) or replace it >> (for code simplicity), mostly at your own whim or even piecemeal. > > It is almost invisible for users, but it's not for maintainers. Like I > said, if I want to keep my code base consistent (and I do) I would have > to perform the full transition. That is what I said. Although some people might prefer to keep BOOST_MOVABLE_BUT_NOT_COPYABLE and BOOST_COPYABLE_AND_MOVABLE, which are nicely descriptive; unlike most of the other macros, which are just cruft when you know you're using C++11."
"On Thu, Feb 23, 2023 at 11:27 AM Peter Dimov via Boost < boost_at_[hidden]> wrote: > No, core library maintainers can't just go ahead and make their libraries > C++20. > They wouldn't be core library maintainers if they did things like that. > > Either Boost library authors who depend on others can reach those agreements via discussions on the list, or they can't. I believe they will act sensibly without enforcement. i.e. Whatever the permissions on paper, I doubt core library maintainers would drop C++14 or C++17 any time soon. I know I won't. In any case the release managers are not going to impose a minimum language standard on those libraries. Glen"
"Hi, promote_args from <boost/math/tools/promotion.hpp> not works with new/extended C++23 FP-types https://godbolt.org/z/13fq8a3d7 The problem might be the outdated "manual variadic" implementation for C++03. Well, according to the documentation (https://www.boost.org/doc/libs/1_81_0), boost::math requires C++11 anyway; with a switch to C++11 it also works (std::common_type). This issue also affects some implementations in boost::math::policies. PS: We have (at least) 3 different definitions for the *same* boost::float128(_type/_t) type 1) <boost/config.hpp>: boost::float128_type 2) <boost/math/cstdfloat/cstdfloat_types.hpp>/<boost/math/cstdfloat/cstdfloat_cmath.hpp>: BOOST_CSTDFLOAT_FLOAT128_NATIVE_TYPE/float128_t 3) <boost/math/tools/config.hpp>: BOOST_MATH_FLOAT128_TYPE :-( thx Gero"
"Am 10.03.23 um 22:39 schrieb Matt Borland: > > >> On Mar 10, 2023, at 1:11 PM, Gero Peterhoff via Boost <boost_at_[hidden]> wrote: >> >> Hello, >> * Problem description >> The constants do not work with the C++23 FP types. >> >> * general hint >> To prevent (more) warnings it is useful to introduce this macro: >> #if defined(__STDCPP_FLOAT128_T__) >> #define BOOST_FLOATMAX_SUFFIX F128 >> #elif defined(BOOST_CSTDFLOAT_FLOAT128_NATIVE_TYPE) >> #define BOOST_FLOATMAX_SUFFIX Q >> #else >> #define BOOST_FLOATMAX_SUFFIX L >> #endif >> >> * question >> In constants the namespaces float/double/long_double_constant+detail are created type dependent (in case the value constexpr can be requested). If the value cannot be requested constexpr the conversion is finally done by boost::lexical_cast. >> But the implementation is very complex. I have a better one - but I may have missed things. >> If so - which would they be? >> >> * My solution (BOOST_MAKE_MATH_CONSTANT) >> see constants_more.hpp, advantages: >> - works with all FP types >> - compatible to the existing implementation CONSTANT<Type>() >> - is clear/understandable (comments) >> - may need only one additional namespace static_constants (and not 4) >> - provides the constants additionally as CONSTANT_v (constexpr) or static_constants::CONSTANT_v (not constexpr) (if possible) >> >> What is your opinion? Are there still errors in it? >> >> It would be even nicer if boost::lexical_cast and/or boost::math::tools::convert_from_string were constexpr. This would further simplify the implementation. >> >> thx + regards >> Gero >> >> >> _______________________________________________ >> Unsubscribe & other changes: http://lists.boost.org/mailman/listinfo.cgi/boost >> <config_more.hpp><cstdfloat_types_more.hpp><constants_more.hpp><OpenPGP_signature.sig> > > > Gero, > > As John and I have said before we are aware that C++23 fixed width floating point types will break Boost.Math. We have a type promotion system for built-in types that will fail because we do not have any code paths for those types yet. GCC 13 will be released in the next month or two and then we can throughly test and fix these issues. > But I had already pointed out some time ago (when it was clear that there will be extended FP types) that there will probably be problems with boost. My request to prepare boost for this was unfortunately not followed. > For the constants lexical_cast is almost never used. If we are operating with arbitrary precision arithmetic typically the types have string/char* constructors, (e.g. GMP, Boost.Multiprecision, etc.) so lexical_cast is not needed. You would also likely end up having to calculate the constant at runtime which we support (see boost/math/constants/calculate_constants.hpp). If you would like you can open a PR with your changes on our GitHub. Without the tests being run it is hard to tell if there are errors outside of the obvious. > For the Boost.Multiprecision.* types, the constants cannot be represented constexpr - which ultimately reverts the calculation to lexical_cast or type-specific conversions. Probably you could make the Boost.Multiprecision.cpp_* types constexpr (which would be timely) and thus also a conversion string->float (in lexical_cast/convert_from_string/calculate_constants, the types themselves (constructor, assign, ...), etc). However, I think you should replace/rename BOOST_DEFINE_MATH_CONSTANT with my BOOST_MAKE_MATH_CONSTANT (if error-free), so that it works for now. > Matt"
"On 29/08/2018 01:09, Andrey Semashev wrote: > For example, if I'm currently using Boost.Move or boost::shared_ptr, > does this mean I have to port my code to native rvalue references and > std::shared_ptr? AFAIK, migrating from Boost.Move to native references is largely invisible to external C++11 consumers, so as a maintainer you could decide to leave the existing code (for reduced churn) or replace it (for code simplicity), mostly at your own whim or even piecemeal. (Having said that, Boost.Move does provide some code-readability improvements for people not trained to recognise non-move vs. move-only vs. move+copy based on constructor existence -- assuming you don't mind macros.) (Of course, it's a breaking change for C++03 consumers, but presumably you wouldn't care about them any more at that point.) Migrating from boost::shared_ptr to std::shared_ptr is a different story; while the types are similar they are not identical (Boost has more features). Where only used in private members it's an ABI break, but probably an insignificant one. Where used in public members it is a significant change that would require user code to change as well. Which isn't to say that you shouldn't do it -- particularly if you don't need the extra features of boost::shared_ptr -- but it may require more thought and/or caution. (You make this same point later yourself in regard to Boost.Atomic.)"
"Edward Diener wrote: > Other than not removing useful Boost libraries which support c++03 as > well as all subsequent C++ standard levels, and not telling people that > they can not use such libraries in c++03 mode if they actually want to > do so, I am perfectly willing to let others, including yourself, decide > the best way in which support for c++03 in Boost is reduced. My argument > has always been that putting a generalized statement on the website, > without explaining what it actually entails as far as using Boost l> ibraries is concerned, is going to lead to confusion and puzzlement > from end-users and endless questions. What can it possibly cost to > actually explain of what "Boost dropping support for c++03" actually > consists, when it is finally decided what Boost is going to do in this > area ? If it is a matter of correct grammar or exposition in the > explanation, I will gladly volunteer to write it if no one else wants to > do so. +1. It sounds like what we're going to communicate to users is that Boost library authors or maintainers are no longer required to make their libraries support C++03. Which sounds fine to me. I don't think library maintainers should be confined by users (even if the users are other Boost libraries) if they don't want to be. Any Boost library maintainers that wish to continue supporting their C++03 users will do so. Any other Boost library maintainers that depend on such libraries can drop the dependency on those libraries. Glen"
"James E. King III wrote: > I may not understand the concerns there, but in general what I was > suggesting was: > > 1. Stop testing C++03 in CI > 2. Stop advertising C++03 support in repositories > 3. Make it clear that C++11 is required to use boost >= 1.8X > 4. Close issues that involve C++03 specifically (likely not that many) > 5. Allow repositories to accept C++11 compliant pull requests > 6. Come up with a project-wide rule, for example that boost will > support 3 back-revisions of C++ so the future is more predictable. > > Libraries do not need to immediately rework themselves. > > They simply no longer need to consider it broken when C++03 > no longer builds properly. I agree with Jim's points above. This was my exact suggestion in the past, that we need to drop C++03 globally at the Boost level, and I only wrote up the policy by which individual libraries can do so https://pdimov.github.io/articles/phasing_out_cxx03.html when we failed to reach a consensus on the above points. The arguments in https://pdimov.github.io/articles/phasing_out_cxx03.html#_ongoing_costs_of_maintaining_c03_support still stand. At this point we might as well move straight to C++14, it being the default on most not-yet-dead distros (with the notable exception of CentOS 7, I suppose.)"
"On Fri, May 6, 2022 at 4:36 AM Niall Douglas via Boost <boost_at_[hidden]> wrote: > > > On 06/05/2022 09:10, John Maddock via Boost wrote: > > > Personally, there's little in C++14 that makes that move attractive for > > me. C++17 yes (for if constexpr). There may be a few libraries which > > could use the enhanced constexpr support in C++14, but otherwise I'm not > > sure how much practical difference this makes. On the other hand, C++14 > > is the current baseline for current compilers, so I have no objection to > > making this the current Boost baseline as well! > > C++ 14 has a *lot* of bugfixes over C++ 11. > > These won't matter to you until they do, and when they do, they are most > frustrating. > > I note that when GCC and clang changed their default C++ standard they > jumped from 03 to 14. They did not choose 11 at any point. I find that > revealing. > > Looking around at other compilers, the only one which ever stopped at 11 > as the default was hipcc. > > https://gist.github.com/ax3l/53db9fa8a4f4c21ecc5c4100c0d93c94 > > 17 is also a fine default, which it is for GCC 11 onwards. Our work > codebase was 17 right up until this week, when we expect to transition > to 20 as the minimum. And I can then rip out lots of preprocessor > macros, woohoo! > > Niall It would still be useful to have a plan going forward, where Boost as a whole follows a predictable pattern. It sounds like people would be more amenable to saying Boost will support the current and previous two language levels at a given release. In particular this means those will be the language levels that are tested for viability. I was originally recommending 3, but it's possible there is a consensus around 2. That means today, C++20, 17, 14 would be supported in whatever release adopted this strategy. Do we have an online tool for voting on proposals to assist? - Jim"
"AMDG On 08/29/2018 10:13 AM, Mike Dev via Boost wrote: > > Well, there have been some voices (here and in the related thread) that > claimed that using c++11 would be of no value for some libraries and I was > wondering if this is a common opinion. > It depends on the library. For Boost.Random, maintaining C++03 compatibility is not a significant burden, and C++11 doesn't make much difference. Boost.TypeErasure, on the other hand, is #ifdefed so heavily that it's essentially two completely independent libraries that happen to share the same API. Note that I do intend to remove the C++03 code path, when I get around to it, and this is entirely consistent with Boost policy. In Christ, Steven Watanabe"
"On 23/02/2023 14:29, Glen Fernandes wrote: > On Thu, Feb 23, 2023 at 9:28 AM Niall Douglas via Boost > <boost_at_[hidden] <mailto:boost_at_[hidden]>> wrote: > > To ensure I'm understanding correctly, this means that a core library > everybody else depends upon could declare it is dropping support for > C++ > 17 as that is old, and thereafter all dependent libraries by definition > would require C++ 20 as a minimum? > > Correct. The "everybody else" would be given notice two Boost releases > (6 months) in advance to fork what they want into their own libraries to > maintain compatibility with older standards. I know I've been a strong advocate for a Boost 2.0 which required a minimum of C++ 11 in the past (and I still am), but I'm finding the above freedom a touch too free. Core libraries going to C++ 11 works for me. Core libraries going newer than C++ 11 I'm finding not helpful for a major use case for Boost, which is "whatever the oldest supported RHEL's compiler is". RHEL 7 EOLs in June 2024 and it comes with GCC 4.8. I - and I am sure many if not most Boost users would like Boost core libraries to keep working on GCC 4.8 until June 2024. After that, rock on with GCC 8, which is what RHEL 8 ships with, and it defaults to C++ 14. I assume if a core library announces it intends to go past C++ 11 in the next year if enough people complain here its maintainer could be persuaded to hold off until the end of 2023? Niall"
"> On Apr 25, 2022, at 18:40, William Linkmeyer via Boost <boost_at_[hidden]> wrote: > > What is the simplest, most relevant library or feature â€” or library improvement â€” that C++ or Boost is missing? > There might be many nice things to have. But, I would argue that what Boost needs is a trimming and deprecation of ancient stuff. There are a million reasons why this cannot be done tomorrow, but if we are talking about a roadmap for 20 and 50 years then it might be a good time to think about it. First and foremost, adopt a timeframe now to get rid of stuff that has been later implemented in the standard library. I do not accept that the standard library is not good enough, as has been heard also in this thread, if that is indeed the conclusion then it's indeed time to get together for a beer, cry and hug, and switch to Python. Second, that such and such library will be deprecated by 2030 - and threaten that other libraries will de deprecated if they cannot get rid of the dependency (mpl!). In other words, boost needs to shrink not grow. Maybe someone should make a boost-lite with no ancient dependencies and weighting 10MB max? I conjecture that it would do magic to adoption by smaller sized projects. Cheers, Kostas"
"> a) __STDCPP_FLOAT80_T__ > With C++23 we get std::floatN_t-types, which are displayed by the macros __STDCPP_FLOATn_T__. However I miss __STDCPP_FLOAT80_T__, which has its justification/relevance. One could retrofit this > #if defined(BOOST_CSTDFLOAT_FLOAT80_NATIVE_TYPE) > #define __STDCPP_FLOAT80_T__ > namespace std > { > using float80_t = boost::float80_t; > } > #endif > Would this be useful/wanted like this? From the proposal the fixed width types are not allowed to be typedefs of the existing types https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html#extended. Sections 5.3 - 5.5 also cover a whole host of conversion rules that would be unsupported. I do not believe this is something we can do at the library level. > b) complex-functions > Since C++11 there are the functions abs, asin/h, acos/h, atan/h. These are also defined in boost/math/complex.hpp. But now with 1.82 boost::math is based on C++14, which makes these manual implementations obsolete -> boost/math/complex.hpp can be removed. These functions are all explicitly marked deprecated, but we do not have a timeline for removal. > c) constexpr > I want to upgrade some functions in boost::math. How should/can I handle constexpr there? My problem is: > - in gcc almost all math functions are constexpr > - otherwise only some math functions with C++23 are constexpr > Now it would be suboptimal not to use constexpr just because it is currently not in the standard. > - If I don't define the additional functions as constexpr or stick strictly to the standard, performance might be wasted, which I don't want. > - Can I simply define the additional functions with constexpr/BOOST_CXX14_CONSTEXPR? In case of an error there will be the standard-error "not constexpr". All of the cmath functions that are specified to be constexpr in C++23 can be used with C++17 here: https://github.com/boostorg/math/tree/develop/include/boost/math/ccmath. If you would like to submit PRs for additional functions they are welcome. With the transcendental functions accuracy quickly becomes an issue: https://members.loria.fr/PZimmermann/papers/accuracy.pdf > d) implementation > In https://www.boost.org/doc/libs/1_82_0_beta1/libs/math/doc/html/math_toolkit/special_tut/special_tut_impl.html you describe how to implement a new math function. Is this still up to date or is it necessary for simple functions? E.g. cot -> 1/tan. That is generally correct. If this is for the implementation of constexpr cmath functions I would follow the implementations that can be found in the linked ccmath folder. Matt"
"Hello, with the planned changes of the dependencies of the boost libraries to newer C++-standards, I would like to ask how this is planned for boost::TypeTraits. 1) In my opinion it would make sense to remove all TypeTraits that are already in the standard, and only provide those that do not exist in the standard (yet). Of course, this depends on the planned minimum standard for boost::TypeTraits. 2) If, on the other hand, boost::TypeTraits is to continue to work with C++03 (for which there may be reasons), however, quite a few adjustments must be made (for newer C++-standards) and bugs must be fixed. Examples: a) - no inline-variables are provided for C++17 (if useful), e.g. is_arithmetic_v - no concepts are provided for C++20 (if useful), e.g. arithmetic - that's why I already asked how to do this best without coming into (name)conflicts with existing structures/namespaces/etc. b) bugs - e.g. is_integral does not contain char8_t (if available) Probably my remarks also apply to other libraries, possibly TypeErasure, TypeIndex, TTI ... All this has to be reworked fundamentally and consolidated if necessary. best regards Gero"
"> But I don't understand why you are against it. After all, there is > BOOST_CXX14_CONSTEXPR (BOOST_CXX17/20_CONSTEXPR are still missing - > but I already offered that). So we have an expressive scheme > BOOST_CXXnn_CONSTEXPR that is unambiguous and readable. C++14 lifted some major constraints on what can be in a constexpr function compared to C++11. Most notably support for more than just a return statement. Being able to differentiate that is useful in practice. > For example, std::round in C++23 is constexpr The CXXyy part in the Boost.Config macros refers to the language level support. While std::round is at library level. So a compiler supporting C++14 constexpr syntax might not have a std library where std::round is constexpr even if it claims C++23 support. So the better way here would be a more focused macro combining the language level of the constexpr feature and the library support of what that specific function is using. Hence a possible BOOST_CXX23_CONSTEXPR is misleading: It doesn't refer to the language level anymore. And if you bind that to availability of constexpr std::round the next user may want to use it with another std:: function which is supposed to be constexpr in C++23 but due to a std library defect is not yet. Hence the distinction between library level and language level feature macros. However IIRC some C++ standard added support of (temporary) allocations in constexpr functions. That would be worth a dedicated feature macro as that change fits the idea described above. I hope that helps, Alex"
"Greetings, I have a novel idea, let's drop C++03 support. The reasons to do that have been explicated already a number of times, e.g. in https://pdimov.github.io/articles/phasing_out_cxx03.html#_ongoing_costs_of_maintaining_c03_support but in brief: * C++03 is 20 years old. * A number of intra-Boost dependencies can be eliminated by using the standard equivalent of Boost components. This will help Boost to become "more modular". * Variadic templates allow us to remove the uses of Preprocessor and MPL, which are the primary contributor to slow Boost compilation times. * Almost no new C++03 development occurs in Boost at this point, so C++03 users do not need to upgrade their Boost. To that end, I propose the following: Boost release 1.82.0 is announced as the last one with C++03 support. If critical problems are found in it post-release, we will issue 1.82.1, 1.82.2 and so on, as appropriate (as C++03 users will not be able to just upgrade to 1.83.) Boost release 1.83.0 is announced to require C++11 at minimum. This means compilers that have all the C++11 standard headers, and support all the C++11 syntactic constructs and keywords without issuing errors. (E.g. VS2013 doesn't qualify because it doesn't support the `constexpr` or `noexcept` keywords.) This proposal should ultimately be approved and implemented by the Boost release managers; their opinions are particularly appreciated."
"Glen Fernandes wrote: > On Fri, May 6, 2022 at 4:42 AM Peter Dimov wrote: > > > > > John Maddock wrote: > > > > Personally, there's little in C++14 that makes that move > > > > attractive for me. C++17 yes (for if constexpr). There may be a > > > > few libraries which could use the enhanced constexpr support in > > > > C++14, but otherwise I'm not sure how much practical difference this > makes. > > > > > > Apart from usable constexpr, polymorphic lambdas are the other big thing. > > > > Oh, deduced return types, too. > > Deduced return types and C++14 relaxed constexpr are of more importance to > me than C++17 if-constexpr. > > To reach more users, 14 seems more appealing than 17. Although by now the > big distributions ship with at least GCC8 which supports most of the C++17 > core language but formally still only experimental support for the C++17 > library... I'd say that the important standard conformance level is the compiler's default one, because that's what all the distro's packages use (and what `b2` uses if not given `cxxstd`, which is how Boost is being built today.) >From this standpoint, moving to C++14 is actually easier than moving to C++11, because the build procedure doesn't have to change (except for people still on GCC 5 or Clang 5 who will need to add cxxstd=14 unless we make this the default.)"
"On Tue, 28 Aug 2018 at 17:04, Andrey Semashev via Boost < boost_at_[hidden]> wrote: > ... would be equivalent to std::atomic? > For that specific reason, yes. So, when your organization then eventually in 2030 (or so) moves to a compiler and STL that supports std::atomic, atomic is guaranteed to work without issue, while at the same time you can provide the play-ground you might like to have. degski"
"On Thu, Feb 23, 2023 at 9:28 AM Niall Douglas via Boost < boost_at_[hidden]> wrote: > To ensure I'm understanding correctly, this means that a core library > everybody else depends upon could declare it is dropping support for C++ > 17 as that is old, and thereafter all dependent libraries by definition > would require C++ 20 as a minimum? > Correct. The "everybody else" would be given notice two Boost releases (6 months) in advance to fork what they want into their own libraries to maintain compatibility with older standards. Glen"
"On 08/28/18 14:37, Mike Dev via Boost wrote: > > - Which library/ies are you maintaining? (I assume this isn't some > sort of private information - otherwise ignore the question) I maintain Boost.Log, Boost.Atomic and Boost.WinAPI. I also participate in Boost.Core, Boost.Iterator maintenance for some components. > - Would you like to unconditionally use c++11 features if you would > not have to worry about this breaking boost internal users? > > - Would you like to unconditionally use c++11 features if you would > not have to worry about this breaking any users? Yes and no to both points. Yes because it would obviously make my code simpler and cleaner. No because I don't think it is as simple as that. For example, if I'm currently using Boost.Move or boost::shared_ptr, does this mean I have to port my code to native rvalue references and std::shared_ptr? If no, should I require future contributions to still rely on these components? If the answer to the latter question is no then this makes a mess of the library code and I wouldn't want that. If the answer is yes to the former question then this is quite a lot of work (e.g. in case of Boost.Log) and may even need redesigning some parts of the library. > - Would you deprecate your library completely if there were no > boost-internal users and your current dependencies required > c++11 (e.g. because your library has been merged into the c++11 > standard library anyway) This mostly relates to Boost.Atomic and the answer is absolutely not. Boost.Atomic offers extended functionality compared to std::atomic, it is a potential playground for future extensions that may end up in the standard library. As I understand, the same is true wrt. other Boost libraries that were adopted by the standard. > - Are you yourself using any boost library (in an up-to-date version) > in a c++03, non-boost project? Not me myself, but I'm aware of such projects. I have a reverse case, where I'm using Boost.Atomic in a C++17 project and not planning to switch to std::atomic. > - Do you have any Idea if the latest versions of your library is > used by any important/significant number of c++02 projects? > [It is only important if *you* consider those projects important > and or the number significant] I don't know what projects those are, but I receive support requests about Boost.Log regularly. Those requests often mention C++11+ constructs. Boost.Atomic - not so much, but it is also a much lesser and more specialized library with a counterpart in the standard library."
"*Boost library authors and maintainers are free to drop support for old C++ standards in their libraries, at any time. * This includes libraries that other Boost libraries depend on. It even includes core libraries like Boost.Core or Boost.Static_Assert. We ask that maintainers do the right thing by all our users (which may include other Boost libraries) by announcing a future breakage *at least two Boost releases in advance*. When that eventual release time arrives, if Boost libraries are broken in older standards modes due to another Boost library dropping support, it will not block the Boost release. This means that we do not need to announce "Boost is dropping C++03" because Boost doesn't "support C++03" now as it is. It means that you, maintainer of Boost.X, should realize that you are free to announce that "Boost.X is dropping C++XY in version 1.Z" as you see fit. Boost in its infancy thrived because its libraries were on the cutting edge. Boost libraries today should similarly not be confined simply because other Boost libraries have chosen to depend on them. Furthermore, as Boost release managers we support authors exercising this freedom, and do not intend to impose any restrictions on what language support they must maintain. We will add a page to the Boost website stating the above formally. -- The release team (Glen Fernandes, Marshall Clow)"
"Got it, thank you very much for the detailed explanation and guidance. On Wed, Jun 23, 2021 at 2:08 PM Andrey Semashev via Boost < boost_at_[hidden]> wrote: > On 6/23/21 8:39 PM, Nicholas Neumann via Boost wrote: > > I've got two different rotating file logs that point to the same > directory > > (with different file name patterns). Is this in general just a bad idea? > > They end up sharing the same file_collector, which seems wrong, so > perhaps > > that is a clue that I shouldn't have my logs set up like this. > > > > In production I've got a service that compresses, archives, and manages > the > > size of the logs. But in dev, I don't, so the number of files in the > > directory slowly grew. But the startup time for my program grew much > > faster. On windows the scan_for_files function in the collector has a > loop > > that is O(mn), where m is the number of files in the directory, and n is > > the number that matched in previous calls to the scan_for_files function > > > > This means the scan_for_files for the first rotating file log in the > > directory has no issue (n is 0), but the second can be problematic. It > > iterates over the files in the directory and for each file in the > > directory, it calls filesystem::equivalent on all of the matches from > > previous scan_for_files calls. On windows, filesystem::equivalent is > > particularly heavy, opening handles to both files. > > > > Thoughts? Is the two file logs getting the same collector the real issue? > > Or is it my pointing two file logs to the same directory? I see some ways > > to mitigate the slowdown in scan_for_files - e.g., filesystem::equivalent > > could be called after all of the method/match_pattern check, but the two > > file logs sharing the same collector feels like the real issue. > > One file collector per target directory is the intended behavior - that > is what allows to maintain limits on the log files to keep. > > That you have to call scan_for_files separately for each sink is > unfortunate, but necessary, since each sink uses its own filename > pattern, and needs to initialize its own file counter value. > > So, in the nutshell, what you're seeing is the expected behavior, and > expected performance cost. It could probably be optimized if Boost.Log > used POSIX API and WinAPI directly, but (a) that would not eliminate the > fundamental O(M*N) complexity of scanning and (b) Boost.Log is using > Boost.Filesystem precisely to avoid dealing with the underlying API > directly, as there are quite a few portability quirks. > > My recommendation to you is to limit the number of files you keep in the > target directory to a reasonable value. > > _______________________________________________ > Unsubscribe & other changes: > http://lists.boost.org/mailman/listinfo.cgi/boost >"
"Jonathan Wakely wrote: > > Quite the contrary, I think we need to respect compiler switches, but not > > library settings. Anyway, this is only important if we can get gcc to > > reliable report -pthread presense. > > Which should happen for 3.4.1. That's good. Did gcc developers decided to add this? Do you have link to email thread (if any)? - Volodya"
"On Jul 20, 2014, at 1:58 AM, Rainer Deyke <rainerd_at_[hidden]> wrote: > On 18.07.2014 17:01, Marshall Clow wrote: >> Boost release 1.56.0 beta 1 is now available from SourceForge > > I'm experiencing problems cross-compiling Boost 1.56.0b1 (host Linux > Mint 17 x86_64, target x86_64-w64-mingw32), and I think this is due to > the build system not picking up my user-config.jam. In Boost 1.55.0, I > placed my user-config.jam in <boost_root>/tools/build/v2, and it worked. > In Boost 1.56.0b1 this directory no longer exists, so I tried placing > my user-config.jam in <boost_root>/tools/build and in > <boost_root>/tools/build/example where the example user-config.jam is > located. Neither of these seem to work, i.e. the invoked compiler is the native compiler g++ and not the cross-compiler specified in user-config.jam. Try putting user-config.jam into tools/build/src and see if it finds it there. If not, you can run b2 —debug-configuration and it will output where it searches for user-config.jam (and other components). — Noel"
"There haven't been much news on Boost.Process lately which doesn't mean though that nothing is happening. I've been working on a Boost.Asio extension which can be used to wait asynchronously for Windows processes - see https://github.com/BorisSchaeling/asio. This was already supported by Boost.Process 0.4 but the implementation was heavily criticized. The code has been moved now to Boost.Asio (or at least I hope it will - I'm in contact with Chris :) and provides a new Windows I/O object called object_handle. The implementation is now based on the Windows function RegisterWaitForSingleObject(). The new I/O object can not only be used to wait for processes. It can also be used to wait for events, mutexes, semaphores etc. As it's not process-related anymore, it makes sense to ship the code with Boost.Asio (where we have already similar Windows I/O objects called random_access_handle and stream_handle - object_handle fits in nicely). Once I'm done with this, a major critical point should have been resolved. I'll go back then to Boost.Process code and help Jeff to finish https://github.com/JeffFlinn/boost-process. I'm not sure how far we are there. But as I don't remember any major obstacles, I'm confident that there are none. :) Boris"
"Another CVS challenged voice In lieu of a zip file , I would vote for inclusion on the basis of previous use of the io state savers Keith Burton"
"Hi, I see I opened an interesting discussion, but my original question was way more inocent. I just wanted to format my code before sending it for review :) I agree for templates and even for long conditions it is better to be flexible. I only expected very basic things to be declared like, how many spaces for indentation, braces positions (next line or same line), underscore_separated_names and not camelCase. Since there is nothing, I will write one for my project and include it in the review as an starting point. Best regards, Damian 2018-01-23 4:23 GMT-05:00 Niall Douglas via Boost <boost_at_[hidden]>: > > *Please* do not mess up the source code. Some of us believe that there > > is an art involved to writing beautiful code. The white space formatting > > of heavy template code, macros, and EDSL's makes the code understandable > > to humans > > > > Clang-format and other such tools destroy readability and understanding > > in many code bases. Don't believe me? Take a look at well written Proto, > > Spirit, MSM, or MPL/Fusion heavy sources written by someone who believes > > that code should be beautiful. Now run it through your favorite > > format-tool and observe the horrible mess that emerges. > > Best of course is that you write your source with clang-format always > running, that way you can poke it as you go to not mess up formatting > where appropriate. > > But I have "ported" legacy codebases to clang-format in the past. It > takes a few days, but thereafter it can be cronjobbed and never again do > things like tabs or failure to follow the style guide ever occur again. > In this situation, stick is much better than carrot. Give developers > zero choice on formatting, then the problem becomes not a problem. > > Niall > > -- > ned Productions Limited Consulting > http://www.nedproductions.biz/ http://ie.linkedin.com/in/nialldouglas/ > > > _______________________________________________ > Unsubscribe & other changes: http://lists.boost.org/ > mailman/listinfo.cgi/boost >"
"> Message du 05/04/11 06:08 > De : "Phil Bouchard" > A : boost_at_[hidden] > Copie Ã : > Objet : [boost] [shifted_ptr] Review Request > > Greetings, > > For those who are not aware in 2008 I wrote a memory manager running in > real-time so that heap objects are being destructed instantly. A quick > introduction can be found here: > https://svn.boost.org/svn/boost/sandbox/shifted_ptr/libs/smart_ptr/doc/ShiftedPointer.ppt > > The library still needs more documentation but we can see the simplicity > of its usage in its examples found in the sandbox. Here's a quick copy > & paste compilation of the examples: > $ svn co http://svn.boost.org/svn/boost/sandbox/shifted_ptr > $ cd shifted_ptr/libs/smart_ptr/example > $ make shifted_ptr_test1 > $ make t100_test1 > $ ./shifted_ptr_test1 > $ ./t100_test1 > > "shifted_ptr_test1" shows its versatility and simplicity while > "t100_test1" shows a more complicated application on a neural network. > > I would like to request a review while I add the necessary documentation > for a better support. Hi Phil, it is a shame that you have not had the time since 2 years to make the documentation. If you add Jamfiles and a complete tests sheet this will encourage others to look at you library. It is clear that in the current state the library is not ready for review. Best, Vicente"
"On Sat, Jun 24, 2017 at 2:01 PM, Rob Stewart <rstewart_at_[hidden]> wrote: > That means cv.wait() is only an interruption point under certain > circumstances. > cv.wait is already only an interruption point only if the predicate is false to begin with. My preferred behavior would, in some ways, maintain that relationship. If you make the predicate true and signal, then interrupt, and the user has not yet begun to wait, they will encounter a true predicate and never be interrupted. If they have begun to wait (under the current behavior), it is undefined whether they will be interrupted."
"--- Brian Braatz <brianb_at_[hidden]> wrote: > /// Testing remove > > { > typedef vector<Y, char, long, X, bool, > double> mpl_vec; > BOOST_TEST((fusion::remove(mpl_vec(), > identity<X>()) > == tuple<Y, char, long, bool, > double>())); > BOOST_TEST((fusion::remove(mpl_vec(), > identity<Y>()) > == tuple<char, long, X, bool, > double>())); > BOOST_TEST((fusion::remove(mpl_vec(), > identity<long>()) > == tuple<Y, char, X, bool, double>())); > } > > > My question is how does the above WORK? > What caught my attention is the char,long,bool, and > double have undefined > values in them. The mpl::vector doesn't have any values in it, never mind undefined ones. (See later) > Is it that when performing a ==, if one is comparing > a mpl sequence the > equality is based solely on TYPE? (is that what is > going on?) No thats not correct. Fusion can iterate over an MPL sequence, even though that sequence does not have values in it. To do this when a fusion iterator over an MPL is dereferenced, it returns a default constructed value of the current element type. So for example mpl::vector<int,char> can be thought of as a sequence containing elements int() and char(). So operator == checks the sequences are the same size, then creates fusion iterators to iterate over the sequence, and compares all the (default constructed) values. Hope that helps. Cheers Dan ___________________________________________________________ To help you stay safe and secure online, we've developed the all new Yahoo! Security Centre. http://uk.security.yahoo.com"
"Currently the threading library does not support for handling situations where a thread might be blocked on IO, in a platform independant way. While it is possible to write (low level) IO such as networking code that has the ability to be unblockable, the lack of an uniform interface seems unfortunate. Say thread B currently is blocking on a (third party) IO library. Now thread A needs to abandon thread B. How should this be done? Possible options are: 1) A schedules a cancel request to B 2) A calls a certain function of the IO library that, given a thread ID is able to unblock the current operation. Ad 1) this is currently not supported by boost thread, and given the rather controversial discussion about correct semantics in the past, it is unlikely to happen soon. Ad 2) This puts a lot of burden onto the user of the library. Interfaces also are likely to be different for various IO libs. Desirable would be a (free) function, say "alert(thread-id)" that is given the thread-id of B. When called by thread A, whatever is necessary to wake up the thread B will be done. The point is that my proposed library does not do the real actions, but only supply a framework that will allow the IO library to register a function to be called when it is time to break out of IO. To find out whether this is feasible I wrote a prototype implementation and an example to demonstrate the use of the interface. (Altough currently only available for MSVC.) My approach is two step. The first of which even might be interesting for a library on its own. 1) A "thdmbrptr" thread member pointer lib The intent of this library is to allow two threads to establish a shared memory space, without requiring the user code to pass any information. This basically does work like a thread local storage from inside the thread: boost::thread_member_ptr<myclass> pmyclass; All functions known from thread_specific_ptr are available, and so is semantics from inside the thread. Besides this another thread can get access to the data by: pmyclass[th]->foo(); where "th" is a thread id (or boost::thread*) and "foo()" is a function of "myclass". The lifetime of the myclass instance is managed by a shared_ptr. One reference is held by the thread (by means of a tss), a second is held by the boost::thread object that created the thread, and additional references might be held by other threads that obtained it by "*pmyclass[th]". 2) An "alert" lib The alert lib has two functions and a class object. alert(boost::thread* th) . . . to alert a thread bool alerted() . . . to find out (and reset) the alerted state of a thread class alerter . . . a class that will be instantiated on the stack. The constructor registers a (IO - ) lib defined function, The destructor unregisters this function. Some additional notes: I have been able to write a prototype implementation that 1) does not need any change to the current boost::thread 2) does not contain platform dependant code since it is built entirely on top of other boost libs. Altough it would by surely desirable to modify boost::thread to give a cleaner interface and improve performance. (Given the alert-ability of threads, a cancellation might later be built on top of it.) If it turns out, that there is interest in my proposal I will upload my files into the "vault". Thank you for your attention, Roland"
"On Saturday 22 May 2010 09:37:58 joel falcou wrote: > Ravi wrote: > > Is the code for NT2 (presented at BoostCon 2010) publicly available? > > currently no more than this. We're currently refurbishign the old code > (which is perfectly functionnal IIRC) > and movign to git "soon". If you're itnerested, I can add you to my "ppl > to conatc when it's ready" list Please do. Does the old code have all the bells and whistles mentioned in your BoostCon slides? Those slides were very interesting leading me to want to look at the code. Regards, Ravi"
"Hey Hartmut, I've got a workaround, like so: If you forward declare the construct() overloads for the different primitive Attribute types, gcc seems to not greedily match this one (the current error): template <typename Attribute, typename Iterator> inline void construct(Attribute& attr, Iterator const& first, Iterator const& last) { attr = Attribute(first, last); } and instead to wait for this one (correct): template <typename Iterator> inline void construct(unsigned int& attr, Iterator const& first, Iterator const& last) { Iterator first_ = first; parse(first_, last, uint_, attr); } So I've got local mods of adding #include <boost/spirit/home/qi/detail/construct_fwd.hpp> to the top of assign_to.hpp, and the construct_fwd.hpp is attached. I don't entirely get it, but I do like the looks of this: troy_at_uranium:~/Projects/boost/trunk/libs/spirit/example/lex % gcc -o example4 example4.cpp -I . -I ../../../.. -lstdc++ troy_at_uranium:~/Projects/boost/trunk/libs/spirit/example/lex % ./example4 assignment statement to: a if expression: variable assignment statement to: b if expression: 2 assignment statement to: c assignment statement to: d if expression: x while expression: 10 assignment statement to: variable ------------------------- Parsing succeeded ------------------------- Bye... :-) Best, -t"
"From: "Dan Gohman" <gohmandj_at_[hidden]> > Here are a few updates for SGI/IRIX/MIPSpro support. > > I've written an implementation of lightweight_mutex for > IRIX/MIPSpro which use IRIX's special atomic operations. The file > can be included when the preprocessor symbol __sgi is defined. > > boost/detail/lwm_irix.hpp Done, thanks. I added your name to the copyright in lwm_irix.hpp, BTW."
"Le 16/03/15 20:40, Steven Watanabe a écrit : > AMDG > > On 03/16/2015 01:21 PM, John Maddock wrote: >> >> What about the warning from execution_monitor.cpp saying that /EHa *is* >> required? >> > > Is this on master or develop? On develop _set_se_translator > is guarded by #if BOOST_WORKAROUND(BOOST_MSVC, <= 1310) > > In Christ, > Steven Watanabe > Hi This is also the point to which we got with Gennadiy. Since we cannot be sure, we did not made any change until we can create appropriate tests for these kind of exceptions. The _set_se_translator definitely needs /EHa, but MSVC 1310 is Visual 2003 sp1, and I believe that there is no test agent for that compiler anymore. The MSDN documentation (https://msdn.microsoft.com/en-us/library/1deeycx5.aspx) states that managed code needs /EHa. This is a valid use of boost.test. To my understanding it also means that removing this option would break the currently existing test using managed code to work properly with the boost.test that is built out of the box. Regards, Raffi Enficiaud"
"Klaim wrote: >>No, I mean that I'll be opposed to visiting 4 different issue trackers > for 4 different components I maintain. I want to see a single list of > issues on my plate, so that I can prioritise them together. > > Isn't it more a issue tracking problem? TRAC is well known to be able to > manage only 1 project (that will change with coming versions) > I've used RedMine to compare with TRAC, it allows managing hierarchies of > projects and having cross-project ticket requests too. > I'm not advocating for a change to RedMine but just that TRAC could be > updated (later not now) to manage libraries as different projects (that can > share the same repo or not). I'm saying this because I know that the > component field alone isn't powerful enough when it comes to managing > different modules or libraries inside the same organisation. It's better > used to say if the ticket is about documentation or not for example. > That said, I'm talkign about features not available yet in TRAC and I don't > know exactly the cost of moving a big tracker database to another one, so > ignore my humble comment as you wish :) I have heard positive comments about Redmine, too, exactly concerning its ability to work with multiple projects better than Trac. However, I don't have practical experience with it, so whether it is better than Trac enough to migrate is something we should determine when/if Dean or something else posts a specific proposal to move from Trac. - Volodya"
"> bounces_at_[hidden]] De la part de Ion Gaztañaga > > -> Hard formatting: printf/scanf are much easier to use and they don't > need several hundred of function calls to do their job. The operator<< > overloading is also a problem if each call needs some internal locking. > A formatting syntax that can minimize the locking needs would be a good > choice. I would be really happy with a type-safe printf (variadic > templates to the rescue). > You can limit the need of locking call pretty easily, even with operator <<. You just need to use a temporary object which unlock the mutex when destroyed: Class stream; Class OStreamObj { Public: Explicit OStreamObj(stream& s): m_stream (s) { m_stream.lock(); } OStreamObj(const OStreamObj& o); // somethings smart ~OStreamObj() { m_stream.unlock(); } Private: stream& m_stream; }; Class stream { Public: Void Lock(); Void Unlock(); Private: Mutex m_mutex; }; Template< class T > Inline OStreamObj Operator<<(stream& s, const T& t) { OStreamObj oso(s); Oso << t; Return Oso; } // all the overload of << are on OStreamObj Inline OStreamObj& Operator<<( OStreamObj& oso, int i) { Oso.put_int(i); Return Oso; } Somethings like this (probably with a counter one the mutex or other c++ tricks to avoid the lock unlock of the first copy). I use the same kind of tricks for automatically putting a std::endl at the end of my logging primitive. struct AutoEndLine { AutoEndLine(std::ostream& os):m_ostream(os) {} ~AutoEndLine() { m_ostream << std::endl; } template< class T > AutoEndLine& operator<< (const T& e) { m_ostream<<e; return *this; } operator std::ostream&() { return m_ostream; } private: std::ostream& m_ostream; }; #define LOG if(IS_LOG_ACTIVATE) ::CT::AutoEndLine(::std::cout)<< "LOG: " There is some advantage to operator << or %, for example, I like to do: LOG << "foo " << foo; ASSERT(f!=NULL) << "Error"; DEBUG << "bar"; With #define DEBUG if(debug_active) LOG << "Debug: " Or somethings like this. Anyways, I don't think this is a good argument against <<. Even if I agree with you on all the point of your previous post."
"Am 01.11.2016 um 08:15 schrieb Gavin Lambert: > On 1/11/2016 13:34, Klemens Morgenstern wrote: >> No, I am not. Since you have streams, they must have a handle so I need >> to be able to duplicate pipes. Hence I could just close a duplicate, >> which doesn't do a thing to help with the problem. > > If you're creating a stream around the handle then the stream should > own the handle -- you can duplicate it if you need to (eg. to change > inheritance or security) but then close the original. Or to put it a > different way, the handle should be moved into the stream, not copied. > > It's generally a bad idea to have more than one handle pointing at the > same thing. It's unavoidable for design reasons as given in this case: pipe p; opstream os(p); ipstream is(p); os << 42; int i; is >> i; And I cannot only pass half of the pipe to opstream or ipstream, because: pipe p; ipstream is(p); child c("foo", std_out> is);//here I need the handle > > So for stdout for example, you get a "read handle" and a "write > handle" when the pipe is constructed. You move the read handle to the > ipstream, and the write handle to the STARTUPINFO; after CreateProcess > returns (and before you try to use the read handle) you close the > write handle. Now the only handle to the pipe that the parent has is > the read handle in the ipstream. No duplication. > > > Here is some very dumb code that demonstrates pipes working as expected: > > LPCWSTR name = L"\\\\.\\pipe\\testpipe"; > HANDLE hRead = CreateNamedPipeW(name, > PIPE_ACCESS_INBOUND | > FILE_FLAG_FIRST_PIPE_INSTANCE | FILE_FLAG_OVERLAPPED, > PIPE_TYPE_BYTE | > PIPE_READMODE_BYTE | PIPE_WAIT, > 1, 0, 0, 10000, NULL); > assert(hRead != INVALID_HANDLE_VALUE); > > SECURITY_ATTRIBUTES inherit = { sizeof(SECURITY_ATTRIBUTES), NULL, > TRUE }; > HANDLE hWrite = CreateFileW(name, GENERIC_WRITE | SYNCHRONIZE, 0, > &inherit, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); > assert(hWrite != INVALID_HANDLE_VALUE); > > STARTUPINFOW si = { sizeof(STARTUPINFOW) }; > si.dwFlags = STARTF_USESTDHANDLES; > si.hStdOutput = hWrite; > PROCESS_INFORMATION pi; > wchar_t cmdLine[] = L"cmd /c ver"; > assert(FALSE != CreateProcessW(NULL, cmdLine, NULL, NULL, TRUE, > CREATE_NO_WINDOW, NULL, NULL, &si, &pi)); > > CloseHandle(hWrite); > CloseHandle(pi.hThread); > > OVERLAPPED ovl = { 0 }; > ovl.hEvent = CreateEvent(NULL, TRUE, TRUE, NULL); > char buffer[2048]; > DWORD len; > > bool reading = false; > while (WaitForSingleObject(pi.hProcess, 0) != WAIT_OBJECT_0) > { > if (!reading) > { > ReadFile(hRead, buffer, sizeof(buffer), NULL, &ovl); > reading = true; > } > if (WaitForSingleObject(ovl.hEvent, 100) == WAIT_OBJECT_0) > { > reading = false; > if (GetOverlappedResult(hRead, &ovl, &len, FALSE)) > { > std::cout << std::string(buffer, len); > } > else > { > DWORD error = GetLastError(); > if (error != ERROR_BROKEN_PIPE) > { > std::cerr << "Error " << GetLastError() << std::endl; > } > break; > } > } > } > if (reading) > { > if (GetOverlappedResult(hRead, &ovl, &len, TRUE)) > { > std::cout << std::string(buffer, len); > } > } > CloseHandle(pi.hProcess); > CloseHandle(ovl.hEvent); > CloseHandle(hRead); > > So if you're not getting the same behaviour, then you've probably lost > a handle somewhere that needed to be closed (perhaps the move bugs?). > This code won't deadlock if the process finishes, although since it's > faking asynchrony it will deadlock if it does a blocking wait for > termination without finishing the read. > > Perhaps the most important observation is that if you comment out the > CloseHandle(hWrite), then it *will* deadlock. > Alright I'm starting to doubt my sanity. I'm quite certain I tested that, even before I've written the async_pipe class etc. and I tried to get some clear information out of the msdn about that. And I thought this was strange behaviour, but only for the named pipes. I have no clue what I did wrong, because I could reproduce what you said using asnyc_pipe just now. Nevertheless, I am very happy I've been wrong, thank you so much. That is the on part where I wasn't very confident about the library, I'll add the feature after the review, since that also needs a lot of testing. So the behaviour that will be implemented then is quite simply: if you use a pipe or pstream with a process the unused side will be closed (also on error) and if necessary (on posix) it'll set some flags. If you want to avoid the automatic closing for whatever reason, you can just duplicate the pipe: ipstream p; pipe p2 = p.pipe(); //duplicate child c("foo", std_out > p2); int i; p >> i; //going for the deadlock And that would of course also mean, that you'd have a close pipe after this: pipe p; child c1("foo", std_out>p); child c2("bar", std_in < p); It'll also be closed on error, so we have consistent behaviour, if some decides to do that: std::error_code ec; ipstream is; child c("invalid-file", std_out > is, ec); int i; is >> i; I hope that makes sense, if the library passes the review, I will fix that before it goes into boost."
"AMDG John Maddock wrote: > Folks, I'm trying to decide how to fix this bug report: > https://svn.boost.org/trac/boost/ticket/2011 > > Basically what should: > remove_pointer<int (foo::*)>::type be? > Should it produce an int, or have no effect? > TR1 explicitly says that it has no effect, so I guess I vote to stick > with that behaviour. Agreed. > In which case, anyone object to a remove_member_pointer trait that > transforms: Nope. I've needed this in the past and wondered why it wasn't present. > It's also tempting to add a "member_object" trait at the same time > that transforms: Good idea. In Christ, Steven Watanabe"
"You're right, summary page just have been updated. Thank you."
"----- Original Message ----- From: <jjphatt_at_[hidden]> To: <boost_at_[hidden]> Sent: Tuesday, May 01, 2001 11:44 AM Subject: [boost] Boost.Python: Defining python attributes using C++ get(), set() methods? > Howdy folks, > > Has anyone thought about supporting the use of C++ get() and set() > methods to define Python attributes? Some other Python/C++ tools > allow you to do this, and it's really helpful. This is already supported. > A C++ class representing an ideal gas in a reservoir: > > class Gas > { > // Get the temperature of the gas. > double getTemperature() const; > > // Set the temperature of the gas. > void setTemperature(double newTemperature); > }; boost::python::class_builder<Gas> gas_class(module, "Gas"); gas_class.def(Gas::getTemperature, "__getattr__Temperature__"); gas_class.def(Gas::setTemperature, "__setattr__Temperature__");"
