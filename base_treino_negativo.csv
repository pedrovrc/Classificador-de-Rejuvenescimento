"> I use the words data-generator & modifier to be consistent with the > naming conventions of the library. To be clear, the data-generator's job > is to map arguments to a suitable data-element. The modifier's job is to Ouch, the data-generator's job is to construct (instead of 'map') a data-element from the arguments."
"On Mon, Mar 14, 2016 at 5:10 PM, Artyom Beilis <artyom.beilis_at_[hidden]> wrote: > I'd suggest take a look on any of existing C++ web frameworks > that has a good user base > and contribute to it as lots of work had already been done in very good > way. > > And of course I mean - look at CppCMS that already solved huge amount > of problems > you are talking about. > I believe that competition is really healthy here. CppCMS is dual LGPL3 and commercially licensed, according to the website you link. That reason alone, to me, justifies Vinicius' approach to provide a Boost Licensed library without any legal restrictions. However, on the technical side, I'm more on the idea that everything that can be done at compile time, should be done at compile time. Handlers, even routes, should be handled in compile time. [1]. This is C++, after all. If I were in Vinicius' shoes I'd make every little aspect configurable statically so the compiler and linker have everything they need to optimize HTTP code to the fullest, which is the rare case where users will resort to C++ for Web dev. I see no gain in using a dynamic HTTP solution that doesn't leverage extreme C++ performance possibilities. I'd rather stick to Node.js and use C++ modules where appropriate. My quarter cent, Madera [1] https://github.com/ipkn/crow"
"Stefan Seefeld wrote: > > I'm still as confused as Vladimir: If there is no difference between RC2 and RC3, > why do we have RC3 ? As I said before there is a difference. > And, what are we waiting for for the candidate to turn into > the release ? Me having the time. Just pushing it out requires 2h of uninterrupted focused work, in the best case. A RC is 1h+. These time slots are hard to find. Thomas"
"[ 208 open tickets today, 206 yesterday ] If you are maintaining a library, and have not logged into the trac system at <http://svn.boost.org/trac/boost/>, please do so ASAP. Until you do that, no tickets can be assigned to you, and will remain under "None". Instructions on working with tickets can be found at: <http://svn.boost.org/trac/boost/wiki/TicketWorkflow> and a mapping of user names to "real names" can be found at: <http://svn.boost.org/trac/boost/report/16> 17 ramey 15 dgregor 13 djowel 12 grafik 12 doug_gregor 12 az_sw_dude 10 rogeeff 9 dave 9 None 7 turkanis 7 nesotto 7 jsiek 6 vladimir_prus 6 anthonyw 6 agurtovoy 5 samuel_krempp 4 witt 4 shammah 4 bemandawes 4 <Blank> 3 pdimov 3 johnmaddock 3 jbandela 3 igaztanaga 3 fcacciola 3 danielw 2 urzuga 2 nasonov 2 jmaurer 2 hubert_holin 2 hkaiser 2 ebf 1 t_schwinger 1 speedsnail 1 samuel_k 1 pavol_droba 1 kaalus 1 guwi17 1 dlwalker 1 aaron_windsor <Blank> 1033 iostreams::restrict doesn't work on an iostreams::file_source <Blank> 1070 [iostreams]boost\iostreams\copy.hpp line80 copy_impl <Blank> 823 Seekable file_descriptor_source /sink? <Blank> 824 BOOST_IOSTREAMS_HAS_LSEEK64 on Mac OS X None 1068 Mersenne twister disables streaming for Visual C++ None 1094 Finding the correct library to link (feature request for pkg-config support)h None 1187 bcp copy not needed files None 1222 lambda::ret<T> should declare result_type. None 1247 Typos in "boost/random/additive_combine.hpp"_ lines 68-69 None 1252 [pool] severe overhead with unaligned sizes. None 1270 uniform_smallint doesn't compile with lagged_fibonacci random number generators None 960 [random] lognormal_distribution problem None 991 [pool] aaron_windsor 778 top-level configure is broken agurtovoy 1001 gcc 4.1.2 segfaults on mpl/test/apply.cpp agurtovoy 1051 MPL header ordering triggers bug agurtovoy 1099 unable to iterate through a "non-explicitly-declared" mpl::set agurtovoy 1215 Boost 1.34.1_ mpl: Wrong workaround detection using MinGW32 (or.hpp_ line #33) agurtovoy 588 mpl::remove compile error with gcc 4.1.0 agurtovoy 640 documentation mistake anthonyw 1154 tss destruction segfaults in conjunction with dlopen/dlclose anthonyw 1168 [thread] tss crashes randomly anthonyw 1226 macro TEXT() in GetProcAddress() anthonyw 1268 xtime_cmp changes to deal with overflow were reverted anthonyw 876 xtime documentation incomplete anthonyw 881 errors when build with Apache stdcxx az_sw_dude 1028 typo in boost header: date_time/time_defs.hpp az_sw_dude 1078 from_iso_string cannot read the output from to_iso_string az_sw_dude 1098 Urgent libboost-date-time1.33.1 : bugs on ia64 ? az_sw_dude 1147 date_time library contains global #define ERROR az_sw_dude 1160 warning: month_format shadows a member of this az_sw_dude 1162 warning: ticks shadows a member of this az_sw_dude 287 wrong usage of ios_base::narrow az_sw_dude 316 date_time type conversion warning az_sw_dude 604 from_ftime incorrectly processes FILETIME filled with zeros az_sw_dude 642 operator<< for gregorian::date_duration not found az_sw_dude 889 Insane Dependencies az_sw_dude 890 date_time library supports only the current dst rule bemandawes 1230 mbstate uninitialized bemandawes 559 linker error mingw 3.4.5 bemandawes 752 directory_iterator doesn't work with catch bemandawes 897 exists() throws exeption on existing but locked file on wind danielw 1044 Argument pack inaccessable in a functions return type danielw 1054 Parameter takes an "infinite" amount of time to compile with the Intel compiler. danielw 1097 keyword.hpp generates many warnings C4180: qualifier applied to function type has no meaning; ignored dave 1010 linking boost.python on freebsd dave 1019 iterator_facade::pointer should be the return type of operator-> (DR 445) dave 1085 Python rules for compiling in Mac OS X dave 1096 Tutorial needs updating for BBv2 dave 1179 [boost.python] can not export a union in VC2005sp1 dave 1181 [boost.python] can modify enum value dave 1246 breakage in boost::python svn trunk dave 865 Use of C++0x keyword as identifier dave 910 gcc strict-aliasing problems with python dgregor 1002 [iostreams] close_impl<closable_tag> does not comply with spec dgregor 1003 [iostreams] copy-paste error in typedefs for wchar multichar_filters dgregor 1011 amd64: #error Boost.Numeric.Interval: Please specify rounding control mechanism. dgregor 1139 [iostreams] Regex filter segfaults when zero matches found dgregor 1140 boost::iostreams linked_streambuf bug dgregor 1149 Minor doc error in basic_null_device dgregor 1164 Floyd Warshall broken with unsigned edge weights dgregor 1185 iostreams::direct_streambuf<T_Tr>::is_open always returns false if output iterator is not null dgregor 1192 [boostbook] problem when two files have the same name dgregor 1199 configure doesn't work with path containing whitespaces (MacOS X) dgregor 1218 Boostbook error when generating documentation for a member typedef with a description dgregor 1232 mapped_file_source::is_open() is broken under windows dgregor 556 Bundled graph properties dgregor 732 Johnson All-Pairs needs better "no path" information dgregor 736 Const correctness violation djowel 1170 Emit Warnings instead of # symbols in the syntax highlighter djowel 1171 Quickbook title output djowel 1172 non-utf djowel 1176 Space after inline code djowel 1206 Escaping from within code? djowel 1273 CR+LF newlines in position_iterator djowel 1276 spirit problem with _GLIBCXX_DEBUG djowel 1277 Closing section like [pre with } causes Quickbok to crash djowel 1280 sections in imported source files get put inside <para> elements in docbook output djowel 1281 Quickbook produces invalid BoostBook/DocBook XML djowel 241 Miss " = ParserT()" djowel 314 spirit insert_key_actor.hpp djowel 664 crash in boost::spirit::parse dlwalker 613 boost/crc.hpp uses non-standard conforming syntax doug_gregor 1021 [Graph][reverse_graph] Problem using reverse_graph adapter with an adapted user defined graph doug_gregor 1076 compile error: disconnecting struct with operator()() doesn't work in VS2005 SP1 doug_gregor 375 LEDA graph adaptors do not handle hidden nodes properly doug_gregor 402 random_vertex/random_edge are unnecessarily inefficient doug_gregor 403 Document copy_component doug_gregor 447 reverse_graph and constness of property maps doug_gregor 708 Dijkstra no_init version should not require VertexListGraph doug_gregor 733 Numbered headers don't work with "preferred" syntax doug_gregor 735 Fruchterman-Reingold grid performance can be improved doug_gregor 738 Memory leaks with signal::connect? doug_gregor 829 Implicit graph not implement doug_gregor 852 Problem with Boost and GCC 4.1 ebf 965 [doc] boost::variant tutorial - final example uses v1_v2 should be seq1_seq2 ebf 993 Variant should use least common multiple of alignments_ rather than maximum fcacciola 1217 value_initialized leaves data uninitialized_ when using MSVC fcacciola 617 Numeric Conversion Documentation minor bug fcacciola 818 No zero-argument in_place() grafik 1023 inspect grafik 1041 Cygwin requires PATH setting. grafik 1062 Cygwin install stage fails with combination of patches grafik 1146 KAI Referenced in compiler status acknowledgements grafik 1233 Boost website still refers to CVS grafik 1244 Broken links to unit test examples grafik 546 boost.build needs fixes for HP/UX grafik 616 Boost Jam_ and non english directorys grafik 896 <native-wchar_t>off does not work when build with vc-8.0 grafik 959 linking fails when Boost is compiled with STLport 5.1.* on Linux (names mismatch) grafik 977 bjam crashes when compiled with gcc 4.2 grafik 986 Problem building Python modules on boost 1.34.0 guwi17 1237 Resizing symmetric matrices hkaiser 1077 Spirit integer parser does not always detect integer overflow hkaiser 1079 boost-1.34.0 fails to compile. concept checks not satisfied. hubert_holin 162 Cannot compile octonion_test.cpp because of bug in sinc.hpp hubert_holin 647 octonion documentation bug igaztanaga 1080 boost::interprocess win32 global file mapping issue igaztanaga 1210 interprocess::barrier hangs during second use under linux (boost 1.33.1) igaztanaga 1231 interprocess_condition (emulated) hangs after notify_all(). jbandela 283 Compiler error for tokenizer on Solaris jbandela 501 token_iterator::at_end() result is inversed jbandela 665 bug in char_separator jmaurer 351 Diff in state of mersenne_twister gen between GCC3.41 & CW9 jmaurer 819 uniform_int<> with type's maximum availaible range error johnmaddock 1081 Empty string rejected as perl-style regex johnmaddock 1083 boost_regex 1.34.0 uses ICU library without linking to it johnmaddock 1148 boost_1_34_1 regex library compile failure on aix with xlv jsiek 416 Spelling of Edmonds-Karp-Algorithm jsiek 575 Calling subgraph::global_to_local on a root graph jsiek 636 strange compiling problem for transitive_closure jsiek 813 concept_check.hpp unused variable warning jsiek 815 remove_edge core dumps on self-circle jsiek 875 No iterator based constructor for adjacency_matrix jsiek 900 graphml reader namespace handling is broken kaalus 1184 property_tree assignment (operator) bug nasonov 1220 lexical_cast requires RTTI nasonov 754 boost::any - typeid comparison across shared boundaries nesotto 1145 Small bugs in Boost.Range documentation nesotto 1284 [range] sub_range assignment issue nesotto 471 boost.range and "const char[]". nesotto 518 [Boost.Range]boost::const_begin calls non-qualified 'begin' nesotto 723 local_time_facet error in VS2005 Win2003 nesotto 730 The ptr_map iterator cannot be dereference to value type nesotto 807 boost::assignment documentation: mathematical "typo" pavol_droba 1152 rle_example fails pdimov 1106 shared_ptr<T> should not convert to shared_ptr<U> when T* doesn't convert to U* pdimov 1108 shared_ptr does not compile under g++ with -fno-rtti pdimov 997 error in boost::bind doc ramey 1036 assert failure in oserializer.hpp:418 ramey 1038 "<" and ">" should be excaped in xml_oarchive ramey 1086 Serialization of weak_ptr produces invalid XML ramey 1089 missing boost::serialization::make_nvp in pointer container library ramey 1121 xml_archive_exception is missing seperate header file_ and documentation mismatch ramey 1137 Virtual destructor is missing ramey 1141 Dangerious operator<< for wostream ramey 1142 boost/serialization/optional doesn't include necessary header ramey 1223 boost::serialization chokes on correcly formatted empty XML element ramey 1267 Assertion `new_cid == cid' failed in basic_iarchive ramey 1285 [serialization] problem when including shared_ptr_132.hpp ramey 1286 Missing/Incorrect dllimport/dllexport directives prevent Windows DLLs from building ramey 757 xml serialization fails when using namespace ramey 878 error C2039: 'mbstate_t' : is not a member of 'std' ramey 961 boost::basic_binary_oprimitive not instantiated correctly ramey 968 xml_grammar - incorrect define char ramey 969 basic_binary_iprimitive::load_binary bug rogeeff 1030 execution_monitor.ipp #warning directive breaks compilation on MSVC 8.0 rogeeff 1032 typo in Boost.Test documentation rogeeff 1050 BOOST_CHECK_CLOSE_FRACTION documentation missing rogeeff 1060 no example sources in online docs for Boost::Test rogeeff 1212 Template fixtures rogeeff 607 Log level names wrong in documentation rogeeff 842 typo in auto_unit_test.hpp Revision 1.17 rogeeff 893 grammatical error in error message rogeeff 956 Doc error in test examples. rogeeff 962 Missing links in Test library documentation samuel_k 585 64 bit compile warning/error for boost::format samuel_krempp 1195 patch: boost/format/parsing.hpp does not compile if BOOST_NO_LOCALE_ISDIGIT is defined samuel_krempp 1196 Patch: when BOOST_NO_STD_LOCALE is not defined_ boost/format/internals.hpp fails to compile. samuel_krempp 1278 declaration of 'str' shadows a member of 'this' samuel_krempp 704 format zero length string msvc-8 samuel_krempp 859 boost::format ignores a user defined locale shammah 284 pool::purge_memory() does not reset next_size shammah 290 perfomance: memory cleanup for pool takes too long shammah 386 boost::pool_allocator breaks with vector of vectors shammah 88 ct_gcd_lcm.hpp compilation error speedsnail 1138 Problems with TSS and static thread library t_schwinger 1100 Building boost.function_types fails cvs rev-1.1_ no chdir command in bash turkanis 525 problem with boost::iostreams when compiled with Visual C++ turkanis 699 Changing size of memory-mapped file on Windows turkanis 786 bug in iostreams/copy.hpp line 81 turkanis 791 iostreams::tee_filter is for output only turkanis 817 Performance problem in iostreams turkanis 822 Incorrect usage of bad_write()_ bad_seek() etc. turkanis 856 iostreams file_descriptor::write fails under Win32 urzuga 574 [boost::lambda] Compile error with libstdc++ debug mode urzuga 781 Lambda: (_1 + "y")(string("x")) Doesn't Compile vladimir_prus 1165 more quoting problems vladimir_prus 1228 bug in toolset gcc + HP/UX PA-RSIC vladimir_prus 1274 Useless error message vladimir_prus 1275 boost::program_options::validation_error::what() is private vladimir_prus 469 multitoken broken vladimir_prus 689 [program_options] Endless loop with long default arguments witt 1046 Boost.Python quickstart instructions mention nonexistent target witt 834 Homepage regression links witt 957 The "Getting Started" page does not mention the stdlib option witt 973 zip_iterator has value_type == reference"
"----- Original Message ----- From: "Neil Groves" <neil_at_[hidden]> To: <boost_at_[hidden]> Sent: Wednesday, November 26, 2008 3:36 PM Subject: Re: [boost] Maintenance Guidelines wiki page (Revison 8) > > Vincente, > > On Wed, Nov 26, 2008 at 2:19 PM, vicente.botet <vicente.botet_at_[hidden]>wrote: > >> Hi, >> >> I have updated the Maintenance Guidelines wiki page. >> >> I have take in account the minor proof-reading modifications from Steve >> Watanave which I have overridden by error (thanks Steve!),and added a lot of >> thinks, maybe too much :) >> >> Please read this mail completely before jumping to the page. >> This page need to be completed and reworked. Please be free to add new >> sections to the page or improve the current ones directly or post your >> comments or suggestions to this list. >> > > <snip> > </snip> > > You can access it directly at >> "https://svn.boost.org/trac/boost/wiki/Guidelines/MaintenanceGuidelines" >> or at "https://svn.boost.org/trac/boost/wiki" >Guidelines >Maintenance >> Guidelines >> > > I can't use either of these links, or find it with a quick search. Would you > be able to post some working links? Please could you retry, it is very slow now, but it works for me. Vicente"
"2015-08-01 13:03 GMT-03:00 Bjorn Reese <breese_at_[hidden]>: > Vinicius, are you fine with that period? Yes, I'm happy with that. =)"
"> I am trying to use the boost array library with VC7 and STLport-4.5.3. > array.hpp at line 56, reads > > #elif defined(BOOST_MSVC) && (BOOST_MSVC == 1300) That is a config problem - and it's been fixed in the latest cvs version where that reads: #elif (defined(BOOST_MSVC) && (BOOST_MSVC == 1300) || (defined(__ICL) && defined(_CPPLIB_VER) && (_CPPLIB_VER == 310))) && !defined(__SGI_STL_PORT) && !defined(_STLPORT_VERSION) regards, John Maddock http://ourworld.compuserve.com/homepages/john_maddock/index.htm"
"On 10/30/2013 10:58 PM, Daniel Pfeifer wrote: > Beman, Dave, Eric, > > Should we attend admin issues now or wait until after the final > switchover to git? > > Advantage of starting now: Authors can experiment with their libraries > inside boostorg. > Disclaimer: They even can push their changes, but need to keep in mind > that Boost2Git continuously recreates the whole repository structure > based on the SVN contents. > > Advantage of doing it when Boost2Git job is switched off: Avoid > surprises that commits get deleted/overridden. My $0.02: Couldn't hurt to grant folks access when they ask for it. When we close the admin issues, we should make it clear that any changes made to the repos before the switch-over will be overwritten."
">> "Current file systems do not provide atomic multi-block appends; >> appends can be broken down into multiple operations. However, most >> file systems seemingly guarantee that some prefix of the data written >> (e.g., the first 10 blocks of a larger append) will be appended >> atomically" >> >> It sounds to me like I have this case covered with the "partial write" >> failure mode of fail_file. Or is there another case I missed? >> > > This portion was worded poorly by the authors. If you look at table 1, > a single block append doesn't work when the filesystem is **not** doing > metadata journaling. Its inconceivable that multi-block appends would > appear atomically for these configurations. Their intent was to point > out that filesystem configurations achieving single block atomic append > could actually do up to 10 blocks atomically. I know from my empirical testing that atomic append only updates the file's maximum extent atomically in the kernel. The i/o writing the appended data is not atomic with respect to other appends nor reads, so if three threads each append to the same file a block, the appends will not be interleaved because the file high watermark is atomically incremented by the total write size before each write is started, but if you do a concurrent read of the end of the file you will see torn writes. I don't know if the torn writes as seen by the kernel reflects what reaches storage, but I'd suggest it would be wise to assume they land into storage even more reordered again. Now, journaled file systems may give the appearance of atomic appends because I would assume that the journal has a mutex on it, and appending unavoidably incurs extent allocation which is a journal operation. So it could simply be that atomicity of appends is an artefact of how the journal has been implemented for that file system, and is not a guarantee. Niall"
"On Sun, Jan 11, 2015 at 8:41 AM, Matus Chochlik <chochlik_at_[hidden]> wrote: > On Sun, Jan 11, 2015 at 2:05 AM, Klaim - JoÃ«l Lamotte <mjklaim_at_[hidden]> > wrote: > > > On Sat, Jan 10, 2015 at 8:46 PM, Vicente J. Botet Escriba < > > vicente.botet_at_[hidden]> wrote: > > > > > > > > > [8<] > > > > Basically allow very flexible composition even at runtime (which helps > > tools dev too). > > It's also have been mentionned in the documentation after these > > discussions. (the doc is actually wrong in thinking that all engines > > component systems rely on inheritance by the way). > > > > Last months I have seen mentionned several implemetnations of this > pattern > > in C++11/14 on github but was not pleased with any design so far. > > The design of Boost.Mixin is close to what I want but don't reach my > needs > > yet (or at least last time I looked at it). > > > > I've been playing with some ECS designs lately and tried to implement two > of my own [1],[2] (maybe those are among those you've already seen) (and > sorry for the shameless plug). Based on what I've seen, if the ECS is to be > used according to the usage patterns you usually see in a game (or > rendering) engine, I believe it is better for the component instances to be > stored together, outside of the entities (for locality of reference, > efficient (re-)allocation, etc.). > > I violently agree. > The entity should IMO be just an unique identifier My experiments so far reach to the same conclusion: it's the most flexible and potentially efficient approach. > and in both of my > implementations there is a `manager` class that can be used to > store/modify/query/remove/etc. the components of an entity. This way > operations that are common, like execute this function (every iteration of > the update loop) on all entities with this set of components can be > implemented more efficiently. > In my current implementation I call the object holding all components a "cluster". The Cluster hold one "pool" of component by type of components. Currently all the pools are the same type and basically are augmented flat_maps but I recently realized that a more flexible system could be implemented by letting the cluster user insert different kinds of polls depending on how he wants the component type to be memory managed ( like a vector or like an actual pool or with allocated nodes?), how "updates" are processed (in parallel, concurrent, jsut a loop?). I plan to try this design in the coming months. I didn't solve the component-inter-requirements problem though, I'm not sure if I should implement this at all, and if yes should it be compile-time checked as Vincente suggests? In which case the cluster would have to know the types it can manage at compile time too, because I see no way for an entity to be able to be checked at compile time except for a construct like the suggested "subject". > > From what I've seen in `Mixin` sources (quite some time ago, maybe it has > changed in the meantime) it does not do this. But the Mixin docs state that > it is not exactly an ECS and maybe its usage patterns are different. > > > > > > > > > * Respect to subjective programming: it would be great to be able to > > > create subject from an entity so that only the mixins of the subject > > would > > > play when a reference to this subject is addressed. > > > > > > subject<Mix_1, .... Mix_n> s (o); > > > > > > o.get<Mix_k>() works as expected. > > > > > > o.get<Other>() compile fails if not equal to any Mix_k > > > > > > > > Interesting. > > > > In the [1] implementation you can do this by creating a `manager` that has > a statically assigned group of component types. > The usage is then close to the following: > > > struct cmpnt_1 { }; > struct cmpnt_2 { }; > struct cmpnt_3 { }; > struct cmpnt_4 { }; > > //declare group_x to contain component types cmpnt_1, cmpnt_2, cmpnt_3. > > manager<group_x> m; > > entity e; > > m.add(e, cmpnt_1(...), cmpnt_2(...)); > use(m.get<cmpnt_2>(e).whatever); > m.add<cmpnt_3>(e); > m.for_each<cmpnt_1, cmpnt_3>(func); > m.remove<cmpnt_1, cmpnt_2>(e); > > m.add(e, cmpnt_4()); // compilation fails > m.get<cmpnt_4>(e); // compilation fails > m.remove<cmpnt_4>(e); // compilation fails > > But having implemented several apps using this approach I find it quite > limiting in some situations that the group of components is static. > Sometimes it is useful (for example for debugging) to have the ability to > add/remove component *types* on-the-fly. [2] allows this but its > unfinished. > > [8<] > > I can do that in my implementation indeed, it is helpful. As said before I think it can be improved by allowing the user to provide the container of component for a type, making him chose how to manage them as long as the container match a specific set of requirement (concept?). > > > > > > > > * Can a mixin D inherit from another mixin B? Could the mixing D be > > > retrieved when getting the mixing B? > > > > > > mutate(o).add<D>; > > > > > > o.get<B>()->f() // f been a virtual function on B? > > > > > > > > I am failing to see the point or usefulness of this? > > > > Most of the literature I've seen on ECS warns against trying too hard to > combine OOP and the data-driven programming style used by E/C systems. Such > logic should be encapsulated in the `systems` that work on the entity's > components. But again maybe Mixin tries to fill a different niche than > 'typical'/'traditional' ECS's do. > > [8<] > > > > > > [1] https://github.com/matus-chochlik/exces > [2] > https://github.com/matus-chochlik/eagine/tree/develop/include/eagine/ecs > > BR > > Matus > > _______________________________________________ > Unsubscribe & other changes: > http://lists.boost.org/mailman/listinfo.cgi/boost >"
"On 3/3/2011 6:57 AM, Chad Nelson wrote: > On Wed, 02 Mar 2011 13:46:33 -0800 > "Jeffrey Lee Hellrung, Jr."<jhellrung_at_[hidden]> wrote: > >> 1) I was hoping the bignum algorithms would be factored out and >> allowed to operate on, e.g., ranges of digits, rather than being >> coupled to the xint::integer_t data structure. I know this had been >> mentioned before. > > And I thought I had answered it, by moving almost all of the functions > out of the integer_t class. Apparently I misunderstood your intent, > though it's something I'd have wanted to do eventually anyway. What difference, from the point-of-view of the interface or from the user, does it make if the algorithms are implemented in the integer_t class scope or a detail namespace scope? It seems you misunderstood the desire for decoupling the algorithms from the data structure. See also Mathias' email regarding "genericity"; I agree with his evaluation in this regard and won't repeat it. Is this decoupling the "something [you]'d have wanted to do eventually anyway", or are you referring to something else? >> Chad, what are your thoughts on this? I know the purpose of this >> library is to provide out-of-the-box bignum functionality with >> minimal hassle, but, to me, the algorithms should be part of the >> interface as well and decoupled from the xint::integer_t data >> structure. > > Maybe I'm missing something... the only thing I see that that would > accomplish, that the current design doesn't, is to allow people to > operate on arbitrary slices of data. Is there really enough need for > that to warrant it? You can't assume that everyone will be satisfied with your integer_t data structure. Someone may want a data structure that uses the small-object optimization, because they have a lot of tiny integers running around and occasionally have large ones. Or they may want to use a std::deque(-like) underlying storage. I don't know. But I do know that your library will be strictly more usable if you decouple the algorithms from the integer_t data structure. I'm hesitant to vote for acceptance unless this decoupling were effected; your mileage with other boosters will obviously vary, but I gather Mathias is of the same opinion. >> 2) In a similar vein, I would like to see the cryptographic >> functionality decoupled from the xint::integer_t data structure as >> well, and released separately. > > That's one of the most common reasons that people want to use a > large-integer library. Separating those functions from the library > would make it that much harder for potential users to get everything > working. Can you be more specific on *how* it would be "much harder", from the user's perspective? >> Also, good things: I like the policy-based design, and I think it's >> the right direction. The Boost.Parameter arity thing may get onerous >> (see comment below), and one thing you could do to work around it is >> to just accept a mpl::map of tags, since I'm guessing your not using >> Boost.Parameter's deduction functionality (awesome and powerful, but >> unnecessary in this case, I think). > > I believe it *is* using deduced parameters. I don't recall the > terminology, but that's what Dave Abrahams called it when I described > the interface. I'm referring to http://www.boost.org/doc/libs/1_46_0/libs/parameter/doc/html/index.html#deduced-function-parameters and http://www.boost.org/doc/libs/1_46_0/libs/parameter/doc/html/reference.html#id5 In other words, are you specifying Boost.MPL predicates in your parameter specifications to deduce the binding of "bald" template parameters to tags/keywords? >> On to more specific comments... >> >> Documentation Comments >> ---------------------- >> >> * http://www.oakcircle.com/xint_docs/ >> >> "Why would I use it? ... Because it's fast." >> >> Do you have any benchmarks to back this up? Fast relative to...? > > Fast relative to pretty much all home-grown code. At worst, it'll be > essentially the same speed as anything that doesn't use hand-written > assembly language functions. Pretty bold claim, okay. >> "Why would I use it? ... Because it has the features you need." >> >> Included in here is "[c]ryptographically-secure prime number >> generation". This seems a little too domain-specific to be included >> in this library. Is there any reason the prime number generation >> couldn't be factored out and, further, be bignum-implementation >> agnostic? Boost.Prime, for example? > > Certainly it could, but again, cryptography is the major reason for a > large-integer library. And prime-number generation is a very large part > of it. Yes, I get that; I just don't understand why they can't be decoupled and still work harmoniously together. Ideally, other bignum data structures should be usable with the cryptographic algorithms. >> * http://www.oakcircle.com/xint_docs/namespaceboost_1_1xint.html >> >> integer_t<...> square (const integer_t<...> n) >> >> The complexity is just O(n^2). If you want to more precise, don't >> use O(...), just state the number of additions/subtractions and >> multiplications. > > Are you sure about that complexity? That function doesn't just multiply > a number by itself, it uses an algorithm explicitly designed for > squaring a number, which is more efficient. I think the complexity on > that one is correct. Ummm...yes, the stated complexity is correct, but O(n(n+1)/2) = O(n^2). So asymptotically speaking, it's not any faster than using the naive grade-school multiplication algorithm. Like I said, unless you want to give a precise operation count, it's just O(n^2). >> integer_t<...> pow (const integer_t<...> n, const integer_t<...> e) >> >> I suspect this complexity is, really, O( # of bits in the result ), >> as the last one or two multiplies are what dominate. > > I'm pretty sure the complexity on that one is correct as well. Yeah, I don't think I'm right, either, but let's analyze this... The asymptotic work in your loop in detail::pow is the same as the following loop (we'll assume that e >>= 1 is a constant-time operation): for(; e != 0; e >>= 1) p = square(p); Let p have np bits. Each successive loop iteration *doubles* the number of bits in p, so the work for each successive iteration is np^2, (2np)^2, (4np)^2, ..., ((2^ne)*np)^2 (there are ne loop iterations, where ne is the number of bits in e). The total work is then (1 + 4 + 4^2 + ... + 4^ne) * np^2 = O(4^ne * np^2) = O(e^2 * np^2) By my count, you're drastically underestimating the complexity ;) Let me know if you agree with the above analysis, I could be wrong. >> I was also thinking about adding an overload where the power is >> specified as an unsigned long, but I don't know if it would actually >> be worth it... > > It might not be too difficult to make that function take any numeric > type. It's already a template function. But I suspect any speed > improvement would be unnoticeable. Likely. >> integer_t<...> square_root (const integer_t<...> n) >> >> You should mention that the algorithm is just Newton iteration with >> initial guess 2^floor(log2(n)/2) (where n is the input value). > > What benefit would that add to the documentation? The average developer > using the library won't care what method is used. If they're > interested, can't they check the implementation source code to see? There are many different algorithms to compute a square root; even users want to know what algorithms you're using so they can use your library with confidence. >> Also, your complexity claim implies a bounded number of Newton >> iterations, independent of the inputs, as each loop through the while >> loop is O(n^2) (where n is the # of bits) due to the division... that >> may be the case, and if so, you might want to back that up with a >> reference or something, but I suspect you should have maybe a log(n) >> in there (where n is the # of bits), as Newton has "only" quadratic >> convergence. > > That's one of the complexity values that I'm not sure of. I haven't > been able to find any reference that pins down a value for it, so that > was an educated guess. Well, I stand by my observation here. Given that Newton has quadratic convergence, I would quote the complexity as O(log(nn)*nn^2), nn = log2(input). >> I believe there is an O(n) square_root algorithm that would be >> asymptotically faster, but...I'd have to look it up... > > That's the best one that I was able to come up with in the time I had. > If you can point me to a good description of a more efficient one, I'll > be happy to implement it. I believe this is what I was thinking of, though the description is a bit terse: http://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Digit-by-digit_calculation >> int is_prime (const integer_t<...> n, callback_t callback=no_callback) >> >> Given the documentation, I think a more descriptive name, such as >> is_probably_prime_rabin_miller, would be better. > > Maybe, but a lot more typing for an arguable benefit. The documentation > specifies its limitations, I believe that's sufficient. The "arguable" benefits are: - the name is no longer misleading; is_prime doesn't actually check if its input is prime; and - it is clear in what sense the input is determined to be probably prime. Again, think about someone *reading* code that uses this is_prime function. >> Also, I'm not sure how small "infinitesimally" small is...it seems >> the wikipedia page only guarantees at most a 1/4^5 chance of a false >> positive (given the current implementation), but in practice it >> states the chance is much much less. > > Applied Cryptography, Second Edition, page 260 states that "for a > 256-bit n, the odds of error in six tests are less than 1 in 2^51", and > the odds get slimmer the larger the number is. (On the previous page, > it says of 2^50 that "[...] if you consider that the odds of the number > being composite are 300 million times less than the odds of winning > top prize in a state lottery, you might not worry about it so much.") > > It also recommends only five tests, which is what the library uses. Thanks for clearing that up. I think such a reference should be added to the documentation. >> Perhaps you should allow the iteration count (the "k" from the >> wikipedia article) to be passed as a parameter as well (possibly >> defaulted), for those that want more control on their primality test. > > The documentation does say that if you want even greater certainty, you > can run it through that function multiple times. A handful of runs > through that should be more than sufficient for any purpose the library > will conceivably be put to. Agreed. >> http://www.oakcircle.com/xint_docs/structboost_1_1xint_1_1options_1_1threadsafe.html >> >> "Note that even with this option, it is still your responsibility to >> ensure that only one thread accesses a particular integer object at a >> time." >> >> You seem to imply that it is not thread safe under any circumstances >> for multiple threads to even have *read* access to an xint::integer_t >> object. Is that the case, and if so, why? > > Any number of threads can *read* an integer simultaneously. But if even > one is *writing* to the integer, all bets are off -- no other thread > can safely access it for any reason until the write is done. This is > extensively detailed on the page titled "The threadsafe Template > Parameter", off the index page. Okay, then all I ask is that on the originally referenced page, it should be stated that multiple reader access is okay. That's what I had guessed, but not what one might infer upon the way it is written. >> http://www.oakcircle.com/xint_docs/classboost_1_1xint_1_1integer__t.html >> >> template<...> class boost::xint::integer_t<> >> >> "You can specify several template parameters for the type. Most of >> these parameters must be specified via helper classes defined in the >> boost::xint::options namespace. See the list and descriptions there." >> >> So that covers "most" of the template parameters...what about the >> rest? > > There's only one other, the custom allocator. It's mentioned in the > description on that page as well, at the bottom. Mentioning it here, too, would be helpful. >> Also, it would be helpful to document here what the default settings >> are. > > True, and thanks for pointing it out. Added to the to-do list. Okay. >> integer_t<...> & operator+= (const integer_t<...> b) >> integer_t<...> & operator-= (const integer_t<...> b) >> >> Why are these parameters passed by value? > > This was mentioned in an earlier message. I didn't recall the reason > then, but I've looked into it: it's partly due to Dave Abraham's "Want > Speed? Pass by Value." article (possibly by misunderstanding, I'll > review that in the next few days to find out), and partly because the > internal COW system makes copies very cheap -- I suspect, as cheap as > pass-by-reference. Most of those pass-by-value functions should > probably be changed, we'll see what I come up with. I'm pretty sure a COW copy is never cheaper than a reference copy, and probably always less cheap (given the reference count that needs incrementing). Besides, COW isn't on by default... >> int sign (bool signed_zero=false) const >> >> I think you should separate the 2 different meanings of signedness >> into 2 separate functions. There are performance considerations, of >> course, but it's also difficult to the casual reader to infer what >> x.sign(true) is suppose to mean without looking it up. A second >> function called sign_with_signed_zero might be more appropriate. > > It would be easy enough to add it, and it could occasionally help write > self-documenting code, so I've put it on the list. sign_with_signed_zero might be a little long, but I don't have any alternate names at the moment, and you get the idea. >> * http://www.oakcircle.com/xint_docs/threadsafe.html >> >> "When using copy_on_write, identical integer objects are allowed to >> share storage, which is more efficient for both CPU power and >> memory..." >> >> I'm (still) not sold that copy-on-write gives any noticeable >> performance benefits in this library over move semantics except in >> contrived examples, so I think some kind of justification of the above >> claim would be justified. > > We went through that, at exhaustive length, last year. The final > results are here: > <http://lists.boost.org/Archives/boost/2010/05/166036.php>. Will review. >> I'm also not a fan of the integer_t::integer_t(const integer_t& b, >> bool force_thread_safety) constructor; isn't there already an >> "ensure_unique" member function already there (in the implementation) >> that ensures an integer_t object has sole ownership of its storage? >> Indeed, looking more at some source files, I would guess this is >> _make_unique. I would consider such a member function preferable to >> this constructor overload, especially given how the mysterious boolean >> parameter looks in client code (see integer_t::sign comment above). > > Please see the aforementioned "The threadsafe Template Parameter" page. > That Boolean parameter will be used so rarely that I don't think it's > unreasonable to ask the reader of the client code to look it up if he > runs across it. That page, or your explanation here, doesn't justify why you think this constructor overload is preferable to a make_unique member function. Sorry, "because that's the way it is now" doesn't count ;) >> http://www.oakcircle.com/xint_docs/basic__types__and__includes_8hpp.html >> >> "#define BOOST_PARAMETER_MAX_ARITY 6" >> >> This is not guaranteed to actually have any effect. Think about if >> Boost.Parameter gets included before any xint header does. Better >> (and, yes, more onerous) to document that xint::integer_t uses >> Boost.Parameter and hence the user must set this macro to at least 6. > > Good point. Added to the to-do list. If BOOST_PARAMETER_MAX_ARITY is already defined, you can check if it is at least 6, and if not, #error with a helpful error message. >> Miscellaneous Comments >> ---------------------- >> >> Why is digit_t in the xint::detail namespace, when it is expected to >> be part of the interface for purposes of supplying an allocator? > > At the time I was writing the library, its definition hadn't been > nailed down, so it was subject to change without notice. Now it should > be stable, so I'll promote it to the xint namespace. Okay. >> How did you create your documentation? Your documentation generator >> may appreciate an acknowledgment in your documentation. > > Ah, good catch. I didn't notice it was missing. I've re-added it for > the next update. Good. >> Also, regarding the complexity notation, it would probably be best to >> state the complexity in terms of some other letter than n, so as not >> to confuse n with the input value. I know I did *not* do this in my >> comments above, as I was trying to follow your notation, but it >> easily gets confusing. Or just use log(n) instead of n to mean the # >> of bits or digits. > > Probably so. Added to the list. Okay. - Jeff"
"On Sat, May 14, 2011 at 9:06 PM, Mostafa <mostafa_working_away_at_[hidden]> wrote: > On Sat, 14 May 2011 12:38:50 -0700, Lorenzo Caminiti <lorcaminiti_at_[hidden]> > I just took a quick glance at the documentation to get an understanding of > the library, and I have a suggestion/comment: > > 1) I suggest adding: > > #ifdef ENABLE_BOOST_LOCAL_VARIADIC_WITH_DEFAULT > #define WITH_DEFAULT , default > #endif > > #ifdef ENABLE_BOOST_LOCAL_SEQUENCING_WITH_DEFAULT > #define WITH_DEFAULT ) default > #endif > > to the library. I think it makes client code more readable if they define > ENABLE_BOOST_LOCAL_VARIADIC_WITH_DEFAULT or its variant rather than just > defining WITH_DEFAULT. Something similar (at least for the variadic syntax) is suggest in one of the docs examples -- see last example here: http://svn.boost.org/svn/boost/sandbox/local/libs/local/doc/html/boost_local/Tutorial.html#boost_local.Tutorial.default_parameters However, Boost macro naming conventions will require this macro to be named BOOST_LOCAL_WITH_DEFAULT if the macro were to be added to Boost.Local. IMO, that name is too long defeating the increased readability benefit. Therefore, I'd leave it up to programmers to #define WITH_DEFAULT if they wish to do so as suggested by the above doc example. > 2) In you're email you mentioned that Boost.Local functions can be used with > stl algorithms, is this noted in the web documentation? Yes, it is mentioned in a few places starting at the very beginning of the Introduction section (3rd bullet point from the top): http://svn.boost.org/svn/boost/sandbox/local/libs/local/doc/html/index.html#boost_local.Introduction Here is a sketch of how Boost.Local implements passing local classes as template parameters (normally not allowed in ISO C++): http://svn.boost.org/svn/boost/sandbox/local/libs/local/doc/html/boost_local/Implementation.html#boost_local.Implementation.local_classes_as_template_parameters Thanks! --Lorenzo"
"I don't know if y'all need yet another opinion about names, but what the heck. Talking generically, ideally, not always referring to the STL names (although I'll acquiesce in the STL names, until they are replaced by the Generic Java names): Briefly ===== "queue" means ordered extracts. LIFO if nothing else; or "priority_queue". No guarantees on internal order. I basically agree with John Potter: Hum: push, pop, top, empty ? classic stack Oh: put, take, look, empty ? any collection/container And Kevlin Henney: * Perhaps an adjective rather than a noun would be better. Rather than describing it as a thing, describe its properties. "buffer" is a generic queue, with no guarantees as to extraction order. "bag" means multiset. Longstanding use, although I would prefer to deprecate "bag" in favour of "multiset". "collection" implies that "looking at the collection" is what's important. So, a pure queue that only allowed you to enqueue/dequeue would not be a collection; C++'s queue is. "sorted_collection", "arbitrary_collection" could be formed naturally. "set" and "map" have unique elements. No guaranteed order of extraction. No guaranteed order of traversal. Random queries. "multiset" and "multimap" may have multiple elements. No guaranteed order of extraction, except when specifying object or key to be extracted. Random queries. No guaranteed order of traversal. YES: IMHO C++ (and Pascal, and many other programming languages) got this wrong. The C++ STL's set/map/multiset/multimap provide a guaranteed internal traversal order, and would better be called "sorted_set", "sorted_map", etc. IMHO "hash_map" is the only primitive map. My opinion is in good company: Messrs Date and Codd, of relational database theory, are also of the opinion that "set" does not imply ordering. I have no preconceptions about "sack", "pouch", "satchel", "backpack", etc., except agreeing with Kevlin that inventing arbitrary new terminology is bad, if adjectives applied to existing terms sereve equally well. Verbosely ======= "queue" is a data structure that has insert and extract operations (enqueue and dequeue, if you like; push*/pop* for STL). There's a huge body of knowledge called "Queuing Theory"; it would be a shame to adopt a definition of "queue" that is incompatible with this theory. The term "queue" implies ordering, LIFO ordering if not further qualified. "priority_queue" is a further qualification: some static key controls the order of extraction. "dynamic_priority_queue" is a priority queue where the priorities attached to the objects change while in the queue. Extraction still always extracts the instantaneously highest (or lowest) priority objects in a single threaded world; in a multithreaded world, often falls back to some approximation of instantaneous highest priority, since full serialization may be too costly. (E.g. Thomas Anderson's run queues.) "queue" and "priority_queue" are not strongly associated with internal ordering: i.e. iterating over the queue does not mean that the order of iteration will be the same as the order of extraction. This allows implementations such as binary or Fibonacci heaps, that do not keep the objects in sorted order. "sorted_queue" might be construed as a queue that provided an iterator that traversed objects inside the queue in their priority order."
"Christian Holmquist wrote: Thx, now its compiling edit boost\tools\build\v2\user-config.jam bjam toolset=msvc stdlib=stlport bye Bernd > Hello, > I compile it like this with vc8.0. just changing the toolset to > msvc-7.1should work. > > bjam toolset=msvc-8.0 stdlib=stlport > > in user-config.jam (boost\tools\build\v2) I have: > > import toolset : using ; > using msvc ; > using stlport : : ../stl/stlport ; > > boost and stlport is located side by side in our directory structure: > > /libs/boost/ > /libs/stl/ > > so you may need to change the relative directory 'using stlport : : > YOUR-STLPORT-DIRECTORY/stlport ;'. > > HTH, > > p.s. it took me quite a while too to get this working, even though it seems > obvious and simple when looking at it now.. :) d.s. > > On 23/10/2007, Bernd Martin Wollny <bm.wollny_at_[hidden]> wrote: > >> Hello, >> I just tried to upgrade from boost 1.33 to 1.34.1 >> In the old boost version you can use -sTOOLS=msvc_71-stlport >> -sSTLPORT_VERSION=51.4 .,...... >> It's seemd that the syntac has changed but .. you can not find this >> changes in the documentation. >> Can some one help me how i can compile boost 3.1.4 with MS VC7.1 and >> stlport ??? >> >> >> bye >> bernd >> >> >> > _______________________________________________ > Unsubscribe & other changes: http://lists.boost.org/mailman/listinfo.cgi/boost >"
"Le 01/06/15 10:02, Andrey Semashev a écrit : > On Sunday 31 May 2015 20:07:43 Edward Diener wrote: >> Updates to clang on Windows have broken the use of clang with the >> [winapi] library. I do not know if this has occurred in the past but it >> seems to have occurred recently when I build the latest clang from >> source and use it on Windows to compile build Boost libraries which use >> the internal winapi library. >> >> Preprocessing clang and gcc output for a given call in the Boost winapi >> library and in the corresponding mingw windows.h shows that both >> compilers view the same source but treat them differently. >> >> As an example let's look at the GetSystemTimeAsFileTime call. The >> preprocessed source for both clang and gcc shows: >> >> In the Boost winapi it is: >> >> __attribute__((dllimport)) void __attribute__((__stdcall__)) >> GetSystemTimeAsFileTime(FILETIME_* lpFileTime); >> >> In the mingw/gcc windows.h it is: >> >> void __attribute__((__stdcall__)) GetSystemTimeAsFileTime(LPFILETIME); >> >> where the FILETIME_ and LPFILETIME are the same. >> >> When gcc sees these two declarations in the two different headers it >> says everything is OK. >> >> When clang sees these two declarations in the two different headers it >> gives an error: >> >> In file included from test_winapi.cpp:9: >> In file included from /mingw/include\windows.h:62: >> /mingw/include\winbase.h:1397:24: error: conflicting types for >> 'GetSystemTimeAsFileTime' >> WINBASEAPI void WINAPI GetSystemTimeAsFileTime(LPFILETIME); >> ^ >> ..\..\..\boost/detail/winapi/time.hpp:70:9: note: previous declaration >> is here >> GetSystemTimeAsFileTime(FILETIME_* lpFileTime); >> ^ >> >> For this line in boost/detail/winapi/time.hpp >> >> __declspec(dllimport) void WINAPI >> GetSystemTimeAsFileTime(FILETIME_* lpFileTime); >> >> It seems like the fix for clang is to leave out the >> __declspec(dllimport) portion of all these Boost winapi calls while >> leaving it in for everybody else. I am discussing this on the clang >> developers mailing list but it seems like they are pretty adamant that >> if they see __attribute__((dllimport)) in from of a function declaration >> and do not see it in front of another function declaration, despite the >> rest of the signatire being the same, the two declarations are not the >> same function being declared and therefore an error because of ODR. > There's this possibly related ticket: > > https://svn.boost.org/trac/boost/ticket/11338 I have no access to a windows environment. I could create a branch and do my best to port to Boost.WinAPI if someone is ready to test it. I would also accept any working patch. Best, Vicente"
"2014-05-06 20:05 GMT+04:00 Glen Fernandes <glen.fernandes_at_[hidden]>: > On Tue, May 6, 2014 at 8:12 AM, Antony Polukhin wrote: > > Unfortunately I have no permissions to do so. Could someone help? > > Hey Anthony, > > You can create a ticket > > http://github.com/boostorg/admin/issues?direction=desc&sort=created&state=open > > e.g. http://github.com/boostorg/admin/issues/67 > Thanks a lot! > Sorry! Antony* Don't worry. It's a matter of translation: in my ID I'm Anton."
NULL
"On 11/12/10 15:25, Domagoj Saric wrote: > > "Mateusz Loskot" <mateusz_at_[hidden]> wrote in message > news:4D038E6B.5010903_at_loskot.net... >> Would you mind explaining what you exactly mean as ROI? >> The abbreviation stands for Region of Interest. This is clear, >> but what definition of ROI you refer to? >> I have a feeling there is potential for another confusion here. > > Hmm...well I mean simply that, a region of interest....in many contexts > in the current discussions it is almost synonymous with a > subimage_view... OK, this is clear now. I have met term ROI mostly used to describe a certain coding strategy where regions which are encoded to higher quality (and stored as such in a format) than the rest of image. This is common technique used in JPEG2000 or PGF. This also allows faster decoding and access to those subimages where each of them is ROI. > Please feel free to correct me if you think I'm using > the term in wrong/confusing ways... I just wanted to confirm that we think of the same writing and reading the term ROI. > ps. have you by some chance ran the GDAL test(s)? Just posted my results as follow-up to yours. Best regards,"
"Niall Douglas wrote: > The NT kernel API is exceptionally stable as any changes to it cost Microsoft and anyone who writes device drivers dearly. Even when I worked at Microsoft (not that long ago; I left in 2014), in the teams/orgs I was in, we wouldn't even consider using any undocumented NT APIs in our code: What you're doing is brave. I'm suprised no AFIO users (if people are already using AFIO) have quoted an old post like http://blogs.msdn.com/b/oldnewthing/archive/2005/07/01/434648.aspx after seeing you use those APIs. > Before I use any NT kernel API I examine when it entered NT and if it has ever changed in any release since, with the Windows XP kernel being my minimum supported kernel. Before I use any undocumented NT API I ask myself if I'm writing a toy application for myself. If the answer is "no" then I do not. :-) I certainly wouldn't use it in code I contribute to Boost. > The only backfire found to date is the asynchronous directory enumeration via the WOW64 layer where Microsoft has a bug in their WOW64 syscall parameter repacking code, so this only affects x86 binaries on a x64 kernel. And there we go. I didn't even notice you already have an issue opened about it: https://github.com/BoostGSoC13/boost.afio/issues/79 - I actually think this decision is going to color people's opinions of AFIO's quality. > What your comment has made me realise is that it would make much more sense if there were a "normal persons tutorial" and an "advanced users tutorial" where the former is a nice hand holding all-portable baby steps thing, and the latter is stuff like writing distributed mutual exclusion algorithms solely via atomic append onto the filesystem like is in the current tutorial. How does that plan sound? It's your library, and you know your target audience. I would only suggest you consider that for any given example that you have decorated with platform-specific code / conditional code to illustrate some point or the other, just make sure it passes the test that any real potential customer of AFIO is going to issue: "Could I implement what this example is trying to achieve using much less [perhaps platform-specific] code, and achieve the same level of performance?". If the answer is "no", then you have nothing to worry about. Glen"
"Hello Janek, ----- Mensaje original ----- De: Janek Kozicki <janek_listy_at_[hidden]> Fecha: Jueves, Octubre 5, 2006 9:20 pm Asunto: [boost] flyweight library? Para: boost_at_[hidden] > Hello, > > Some time ago there was a discussion about flyweight library, I have > examined it and considered it very useful. Especially now, it is > possible that I will need to use it. > > Since I cannot find it either inisde CVS nor in boost sandbox, I > wantedto ask what is the status of flywieght library? > > - is it yet to be submitted as a library proposal ? This is my plan. > - it has been already accepted and will be Added Soon (tm) to CVS ? No, not at all. > - something else ... ? After uploading the version of the lib you can find at the vault, I've continued evolving it to make it more customizable, include serialization support and some other goodies. The basic code base is set up, but there's still quite some work to do before I can present it in public, and, if acceptance is good, request a formal review. I'd say the stuff could be ready for presentation around Dec 06 or Jan 07. > -- > Janek Kozicki Joaquín M López Muñoz Telefónica, Investigación y Desarrollo"
"on Sun Aug 04 2013, Stephen Kelly <steveire-AT-gmail.com> wrote: > On 08/04/2013 10:57 AM, Daniel James wrote: >> On Sun, 4 Aug 2013, at 10:22 AM, Stephen Kelly wrote: >>> What do you think about increasing the compiler requirement much more, >>> as I wrote in another mail? >> I'd say no, unless you've got a very good reason. Compiler support >> should be an individual library maintainers decision. > > Thanks for bringing that up. I was hoping someone would :). I've been > reading the boost mailing list for a while and I've seen similar > sentiments that each maintainer can make somewhat autonomous decisions > on things like this. That obviously does not help with forward momentum > in efforts like this, and I expect the boost community has a solution to > that problem. > > Is the solution the steering committee? Yes, that was one of the main reason we formed it."
"On 9/8/2013 11:18 AM, Marshall Clow wrote: > See the calendar at: http://www.boost.org/development/index.html > > September 16: 1.55.0 Closed for new libs and breaking changes > September 23: 1.55.0 Closed, except bug fixes and doc changes > September 30: 1.55.0 Closed, except by permission > October 7: 1.55.0 Beta release I forgot to merge the fix I made to Boost PP tuple/rem.hpp on the trunk to release. May I still do so ? It is revision 85172 on trunk. It is just a one-line addition for the macro: #define BOOST_PP_TUPLE_REM_0() that was missing in Boost PP. Edward Diener > > -- Marshall > > Marshall Clow Idio Software <mailto:mclow.lists_at_[hidden]> > > A.D. 1517: Martin Luther nails his 95 Theses to the church door and is promptly moderated down to (-1, Flamebait). > -- Yu Suzuki > > > _______________________________________________ > Unsubscribe & other changes: http://lists.boost.org/mailman/listinfo.cgi/boost >"
"Edward Diener wrote: > The right thing would be for the sort library to change its boost::sort > namespace name to something else, like boost::sortlib, so as not to > conflict with range's boost::sort algorithm. In general there should be no > boost:: namespace names with the same name as a std:: algorithm as this > will conflict with range's mimicking the standard algorithms with a range > instead of iterators. This made sense in the past when we put everything in boost:: but I'm not sure it makes sense today. Our current de-facto policy is one namespace per library matching its name, and nothing else in boost::. This is the only approach that scales. So I'd say that it's Range that needs to yield rather than Sort (which does everything by the book)."
"Daniel Frey <daniel.frey_at_[hidden]> writes: > Peter Dimov wrote: >> John Maddock wrote: >> >>>However, the static asserts still always get triggered, and I'm not >>>sure why: any language lawyers understand this? >> At the instantiation point B and A<B> are still incomplete. > > Would it help to move the BOOST_STATIC_ASSERT to the dtor of A<B>? Yes, if it meets the design goals fo the author."
"Guillaume Melquiond wrote: > Quoting Ion Gaztañaga: > >> template<class T, member_hook T::* P> >> class value_traits; >> >> compiles fine, but I just want to have one template parameter > > This is not a good enough rationale for the current interface. I insist in the > need for moving the class parameter from the hook to the value traits, > both for > efficiency and clarity. I'm not trying to justify the current interface. I just wanted to say that two parameters will be needed. It's clear that the hook shouldn't have a template parameter because we are generating unnecessary code. Thanks for pointing this out. > I hadn't noticed that your functions size() and count() don't return a > size_type > as defined by the standard. The standard says that the return type of these > functions must be large enough so that it can contain any positive > value of the > pointer_type of the iterators of your containers. > > Moreover, there is not much point in putting a short type as an integer return > type, as the value will generally go through a fixed register, which doesn't > care about the reduced size of the return type. It may even produce worst > binary code, as either the callee or the caller will have to explicitly > discard > the upper bits. The standard also allows allocator::size_type to be any type, so if I want to support building STL containers above Intrusive, I must somehow allow specifying the size_type for Intrusive. > But it doesn't have to be properly unlinked for it to be perfectly safe and > meaningful. As a matter of fact, you want to be able to change an element of a > list; they are not supposed to be immutable. Your library doesn't allow a user > to do "*i = v" when i is an iterator of a list and v an unlinked value. This > really strikes me as wrong! "*i = v" is convincing. You can still achieve this if you define operator=() for a value_type, not calling hook::operator=(). However, I agree that that compiler generated assigment operator should allow "*i = v". So I will make hook assigment a no-op, to maintain the value linked in the container. This will make ordered containers a bit unsafer, but you can't have everything ;-) > Maybe it would be clearer with an example. The following pseudo-code is > something I want to be able to write. > > struct T { hook1; hook2; data }; > iset<T,hook1> set1; > iset<T,hook2> set2; > ...; > set2 = set1; If sets are different types, operator= has no sense in my opinion, because it should destroy old values and there is no function to do so. To me, only a move assignment/construction (in C++0x) would make sense: set2 = std::move(set1); which would be equivalent to a "set2.swap(set1)" (no value is destroyed). But intrusive containers are non-copyable and non-assignable and I want to emphasize this with the interface. A matter of taste, I guess. > Best regards, > > Guillaume Thanks again, Ion"
"On 15/05/13 10:35, Oliver Kowalke wrote: > I need some help to extract the type of a callable which is passed as > argument to the ctor of X. > > struct X > { > template< typename Fn > > X( Fn fn) { > ... code which evaluates Fn and extracts the type of the first arg > of Fn > } > }; You can't do that. Just change your code to not require it."
"> > I imagine your line-by-line reading iterator would look something like > > (PSEUDO-CODE!!!): > > > > > > class line_by_line_iterator { > > buffer_t& buffer; > > > > public: > > const buffer_t& operator*() const { return buffer; } > > void operator++() { format_specific_read_one_line_into(buffer); } > > }; > > > > > > I'd do it using iterator_facade. > > > > A case that this fails to manage efficiently is when your format-specific > > implementation has an efficient way to skip forward without actually > > decoding. This is not something that I've ever had to worry about, but I > > think you could do it easily enough by adding a flag and doing the read > > lazily in operator*. > > you mean pass a boolean into operator*? Surely not, as the signature of an overloaded operator is fixed :) I think Phil means rather than do the read in operator++, just set a flag in operator++ that the read should be done, and actually do it in operator* (which then clears the flag). Then if someone calls operator++ again without calling operator* (which you can detect by the flag being set in operator++), you can do a skip in operator++, and thus avoid decoding the line you didn't need. Regards, Nate"
"Andrey Semashev <andysem_at_[hidden]> writes: > Jeremy Maitin-Shepard wrote: >> Andrey Semashev <andysem_at_[hidden]> writes: >>>>>> That will just require duplicating the tables and algorithms required to >>>>>> process the text correctly. >>>>> What algorithms do you mean and why would they need duplication? >>>> Examples of such algorithms are string collation, comparison, line >>>> breaking, word wrapping, and hyphenation. >> >>> Why would these algorithms need duplication? If we have all >>> locale-specific traits and tools, such as collation tables, character >>> checking functions like isspace, isalnum, etc. along with new ones that >>> might be needed for Unicode, encapsulated into locale classes, the >>> essence of algorithms should be independent form the text encoding. >> >> Using standard data tables, and a single algorithm that merely accesses >> the locale-specific data tables, you can provide these algorithms for >> UTF-16 (and other Unicode encodings) for essentially all locales. This >> is done by libraries like IBM ICU. Providing them in addition for other >> encodings, however, would require separate data tables and separate >> implementations. > I still can't see why one would need to reimplement algorithms. Their > logic is the same regardless of the encoding. I'll admit I haven't looked closely at the collation algorithm given by the Unicode specifications recently, so it is hard for me to give details. String collation is in general lexicographical on the grapheme clusters, but for some languages there may be certain exceptions (someone please correct me if I am mistaken). Perhaps someone with more knowledge can elaborate, but I believe the Unicode collation algorithms are indeed highly specific to Unicode. >>> What I was saying, if we have a UTF-8 encoded string that contains both >>> latin and national characters that encode to several octets, it becomes >>> a non-trivial task to extract i-th character (not octet) from the >>> string. Same problem with iteration - iterator has to analyze the >>> character it points to to adjust its internal pointer to the beginning >>> of the next character. The same thing will happen with true UTF-16 and >>> UTF-32 support. >>> As an example of the need in such functionality, it is widely used in >>> various text parsers. >> >> I'm still not sure I quite see it. I would think that the most common >> case in parsing text is to read it in order from the beginning. I >> suppose in some cases you might be parsing something where you know a >> field is aligned to e.g. the 20th character, > There may be different parsing techniques, depending on the text format. > Sometimes only character iteration is sufficient, in case of forward > sequential parsing. There is no restriction, though, to perform > non-sequential parsing (in case if there is some table of contents with > offsets or each field to be parsed is prepended with its length). Such a format would likely then not really be text, since it would contain embedded offsets (which might likely not be text). But in any case, the offsets could simply be provided as byte offsets (or encoded unit offsets), rather than character or grapheme cluster offsets, and then there is no problem. Note: I'm using the term "encoded unit" because I can't recall the proper term. >> but such formats tend to >> assume very simple encodings anyway, because they don't make much sense >> if you are to support complicated accents and such. > If all standard algorithms and classes assume that the text being parsed > is in Unicode, it cannot perform optimizations in a more efficient > manner. The std::string or regex or stream classes will always have to > treat the text as Unicode. Well, since std::string and boost::regex already exist and do not assume Unicode (or even necessarily support it very well; I've seen some references to boost::regex providing Unicode support, but I haven't looked into it), that is not likely to occur. I think it is certainly important to provide some support for non-Unicode encodings. In particular, converting between arbitrary encodings should certainly be supported. Depending on to what extent your parsing/processing relies on library text processing facilities above basic encoding conversion, it may or may not be feasible to directly process non-Unicode text if only this very basic level of support is provided. It would be useful to explore how much trouble it is to support arbitrary non-Unicode encodings, and also to explore how useful it is to be able to format/parse numbers, dates (and perhaps currencies), for instance, in non-Unicode encodings."
"Daniel James wrote: > Péter Szilágyi wrote: > >> does boost or does it not contain the unordered_map, > > Boost doesn't currently have unordered containers. I'm going to ask for > a review soon, but given the amount of time it's taken libraries to get > into boost recently, don't hold your breath. While "don't hold your breath" is certainly good advice, there is general agreement that we need to fix the release procedure so we can release on a much more reliable schedule. At BoostCon last week there was a lot of background discussion about the details of objectives and how to achieve them. I'm writing a proposal now and should be ready to post for comments sometime this coming week. --Beman"
"Lorenzo Bettini wrote: > Hi > > I was trying to build a static version of the regex library (boost > 1.39), issuing this command: > > ./bjam --build-dir=build_static --layout=system threading=single > runtime-link=static link=static > > but I always get this error: > > error: link=shared together with runtime-link=static is not allowed > error: such property combination is either impossible > error: or too dangerious to be of any use > > but why is it trying to use link=shared when I explicitly specified > link=static? You must have an ICU installed, and Boost.Regex tries to use that automatically. ICU only comes as shared library. You might wish to remove the ICU_PATH setting in project-config.jam or whenever it's is made. - Volodya"
"on Tue Aug 23 2011, Alexander Terekhov <terekhov-AT-web.de> wrote: > Dave Abrahams wrote: > > [... memory model ...] > >> It's not really different than locking. If you want to write to shared >> data, you need some way of making it not-a-race. It's just that when >> the data structure is small enough (like an int) you can make it atomic >> instead of putting a lock around it. > > No. All I'm saying here is that a C++11 default atomic int is equivalent to an int, coupled with an associated mutex, where accesses to the int are always protected by locking the associated mutex. If you're seriously disagreeing with *that*, please say explicitly on what grounds. If you're not disagreeing with that, we have no disagreement and you're just grinding some irrelevant axe."
"On Wed, Apr 30, 2003 at 10:24:09AM +0100, Ken Hagan wrote: > > William E. Kempf wrote... > >> pragmas. As a "best practice suggestion", it's a great idea... as a > >> requirement, I'd have to voice an opinion against. > > Paul A. Bristow wrote: > > > > I absolutely agree, but I feel it would be useful encourage authors > > to try. > > Playing devil's advocate, but why? > > With the compiler in question, I can write > > #pragma warning(push) > // lower the warning level > // include dodgy headers > #pragma warning(pop) > > and I do exactly this for all my third party headers. I don't know > if other compilers have this push/pop feature, but they ought to. > (In fact, I can't think of a pragma that wouldn't benefit from > being able to push and pop its effects.) > > Also, if I run LINT on my code I get warnings about things that > my compiler never worries about. I have to tell LINT to ignore > the quality of third party headers too. Are we suggesting that > boost authors write "//lint" comments too? Where does it stop? > > I use compiler warnings to point me at risk areas in my code. > Boost has been tested rather more thoroughly than my own code > (sad to say) and doesn't feature highly in my risk assessment, > so I'm going to lower the warning level for those headers anyway. > > Given that, there isn't much point in boost authors writing lots > of "line by line" warning suppression paragmas. > I have noticed a lot of new warnings in the release 1.30. I absuletely agree, that there is no reason to do some kind of "line by line" pragma suppression. But... Most of the new warnings can be easily removed with a static_cast. I don't understand, why any boost lib have to generate such a warnings. Pavol"
"David Walthall wrote: > The following patch fixes the mapped_file_test compilation error for > msvc 7.1 (daw-msvc71): > > Index: libs/iostreams/src/mapped_file.cpp > =================================================================== > --- libs/iostreams/src/mapped_file.cpp (revision 48407) > +++ libs/iostreams/src/mapped_file.cpp (working copy) > @@ -434,7 +434,7 @@ > > void mapped_file_source::close() { pimpl_->close(); } > > -mapped_file_source::operator safe_bool() const > +mapped_file_source::operator mapped_file_source::safe_bool() const > { return pimpl_->error() ? &safe_bool_helper::x : 0; } > > bool mapped_file_source::operator!() const > > I am not the expert on this, but I think creating a Trac entry for the bug and posting it there is better. Things can get "forgotten" on mailing lists."
"> > 1. parameter type enforcing > > Check. You provide a simpler and less-capable interface. Of course > it would be easy to add a simple and less-capable interface on top of > our general one. Could you please ground you statement about "less-capable". With specific examples. If you mean something amoung the lines "is_movable" check. Look at my responce here: http://lists.boost.org/MailArchives/boost/msg75147.php > > 2. default value support > > Details, please? Please show the differences (I've clearly lost track > of this thread). template<typename Params> void foo( Params const& p ) { you interface int ind = p[index | 0 ]; my interface int ind = p.has(index) ? p[index] : 0; } > > 3. option parameter support optional actually. Sorry > > Details, please? >From other thread: > > void foo_impl( int i1, int i2 ) {...} > > void foo_impl( int i1 ) {...} > > > > template<typename Params> > > void foo( Params const& p ) { > > if( p.has(i2) ) > > foo_impl( p[i1], p[i2] ); > > else > > foo_impl( p[i1] ); > > } > > 4. Unlimited number of parameters support > > If I understand what you're saying, no you don't. Why? I could have as many parameters to function as I want since I do not try to combine under the hood of single keywords structure. > Don't forget, we have the overloaded comma operator. Don't you still need to use keywords structure? Doesn't it has limited arity? If you don't, which features wouldn't be accessible (without keywords structure)? > If I don't understand what you're saying: details, please? > > -- > Dave Abrahams Regards, Gennadiy"
"Eric Niebler wrote: > Could you send a repro? I'm trying but it seems I can't. Well, I think that in fact I must have a MPL type somewhere as a tempalte argument or base type I forgot to remove/wrap. THe question is, shouldn't *all* MPL component be ADL protected ?"
"On Wed, Nov 11, 2015 at 11:47 AM, Thomas Trummer <th.trummer_at_[hidden]> wrote: > > > On 11 Nov 2015, at 05:41, Marshall Clow <mclow.lists_at_[hidden]> wrote: > > > > Have I missed anything? > > Iâ€™ve looked into the build related warnings for OS X: The main problem > seems be that â€˜darwin.jam' defaults to gcc which is just a front-end for > clang for quite some time now. Fortunately there is already > â€˜clang-darwin.jamâ€™ for current versions of OS X. The second problem is the > use of C++11 code without providing the corresponding compiler option. So > the correct command line for building Boost with a recent OS X version is > as follows (and which should probably become the default at some point in > the future): > > ./b2 toolset=clang-darwin cxxflags=-std=c++11 > > I have a custom toolset which is exactly that "clang-darwin-11" (also clang-darwin-14 and clang-darwin-1z, for that matter :-)) -- Marshall"
"> Currently, the allocate/deallocate functions et.al. in > lockfree::detail::freelist_stack are private. This inhibits reusing this > class for implementing other lock-free datastructures as it's not possible > to allocate anything which has not a constructor taking 0, 1, or 2 arguments > (those are supported explicitly by exposing overloads for > freelist_stack::construct). > > Would it be possible to make the mentioned functions 'protected' instead? hm, i see your point. however freelists are not really part of the public API. iac, i'd somehow prefer to have an API like: template <class... Args> T * construct(Args&&... args) but for the time being, making these functions protected is ok to me. tim"
"> I'd like to point out that Boost.Signals2 is threadsafe, and you pay for > that, to the tune of 2x slower performance than Boost.Signals. That is the > figure reported during the Boost.Signals2 review. Does anyone know if this > has changed? If not, removing Boost.Signals is a case of requiring some > users to pay for what they do not use (the threadsafety bit). I never used > signals/slots in any context in which I was signalling across thread > boundaries, and I don't expect that to be a common use case. more recent benchmarks: https://github.com/NoAvailableAlias/signal-slot-benchmarks"
"on 9/7/01 8:25 AM, Gennadiy E. Rozental at rogeeff_at_[hidden] wrote: Index: conversion_traits.hpp > =================================================================== > RCS > file: /cvsroot/boost/boost/boost/type_traits/conversion_traits.hpp,v > retrieving revision 1.7 > diff -r1.7 conversion_traits.hpp > 203c203 > < #ifndef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION > --- >> #if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) || defined( > __SUNPRO_CC) && __SUNPRO_CC >= 0x520 It looks to me like the real problem fixed by this and many other suggested patches is that BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION (and perhaps other flags from config.hpp) needs to be set for newer versions of the SunPro compiler, not just older versions. We don't want to sprinkle changes around all the files to deal with this. Instead we want to just fix config.hpp. -- Darin"
"----- Original Message ----- From: "Markus Schoepflin" <markus.schoepflin_at_[hidden]> > Hi David, > > --- In boost_at_y..., "David Abrahams" <david.abrahams_at_r...> wrote: > > That was in the original design, but I punted when I ran into a > problem that > > looked like inheritance. I'm not sure I remember exactly, but I > think it was > > something like this: what happens if you derive a variant my-debug > from > > debug, then specify <debug><define>FOO in your target requirements? > Should > > FOO be defined in your "my-debug" build? > > I would certainly expect this. Which? (I asked two questions above). > > What happens if you add > > <my-debug><define>FUBAR? > > <debug> gets FOO and <my-debug> gets FOO and FUBAR. > > > Is the behavior the same for non-free features as > > for free features? > > Yes. It can't be exactly the same. You only get one setting for any non-free feature. You can't have both <inlining>full and <inlining>off, so I suppose you'd like to see non-free feature overrides? > What I had in mind was some kind of basic variant (like debug or > release) and some other variant which inherits all the settings from > the basic variant but enables this or that feature, giving me the > variants debug-feature1, release-feature1, debug-feature-2, ... You can get a similar effect by setting, e.g. BUILD = release <debug-symbols>on I'll put your request into the mix. If you would like to volunteer to implement some things, your request could get handled much faster ;-) -Dave"
"AMDG Steven Ross wrote: > I have figured out an optimization that in simple testing makes integer_sort > faster than std::sort on already-sorted data (and comparable on > mostly-sorted data), and improves performance slightly on unsorted data. As > the worse best-case performance was the main drawback to the algorithm based > upon my prior results, I was wondering if it was appropriate to delay the > review until I can get this change fully implemented and tested? > > If it is proper to delay the review, I apologize for wasting people's time. > I thought I was done optimizing it, but apparently not. > > I think I can finish all this up by monday It usually takes a fair amount of time to schedule a review. There shouldn't be any problem. In Christ, Steven Watanabe"
"When you said: >the communities own design philosophies are brutally ignored > by its own members. this implied a historical perspective, because a claim like this could only substantiated by reviewing the history of the boost community. When you respond by later saying: > Historical facts are not very relevant to the current state. I never made > any claim to have been following the development list prior to, well, > yesterday. then I think that you have admitted that your statement "the communities own design philosophies are brutally ignored by its own members" cannot be substantiated by you. Anyway, I agree with you that generally #ifdef's make code difficult to read and should be avoided when possible. If you had been following the community discussion, you would know that many of the existing #ifdef's are used to "assist... deficient compiler(s)". The development list is not only a good tool for discussion, it is also a historical body of commentary, AND an excellent place to learn about advanced C++ practice. I hope that you will use it carefully and considerately, and participate in this shared venture. Respectfully, David ----- Original Message ----- From: "Eric Woodruff" <Eric.Woodruff_at_[hidden]> To: <boost_at_[hidden]> Sent: Monday, August 05, 2002 3:23 PM Subject: [boost] Re: Re: Re: Re:PlatformNeutrality-withoutreinterpret_cast<>andifdef > Historical facts are not very relevant to the current state. I never made > any claim to have been following the development list prior to, well, > yesterday. > > It is clear the the #1 principle is violated: > "Aim first for clarity and correctness; optimization should be only a > secondary concern in most Boost libraries." > > #ifdef's are certainly not very clear, and definately not correct. Use of > the preprocessor mutates the language, violating the standard, and thus, > should only be used to assist a defficient compiler. > > In that case, principle #2 is also ignored: > "Aim for ISO Standard C++. Than means making effective use of the standard > features of the language, and avoiding non-standard compiler extensions. It > also means using the C++ Standard Library where applicable. " > > But this is the accepted way of the majority. > > ----- Original Message ----- > From: David Brownstein > Newsgroups: gmane.comp.lib.boost.devel > Sent: Monday, 2002:August:05 5:59 PM > Subject: Re: Re: Re: Re: > PlatformNeutrality-withoutreinterpret_cast<>andifdef > > > Eric, > Please explain which of the communities design principles you believe have > been "brutally" ignored? I assume that you have followed the design and > implementation of boost::threads since the beginning (with all the attendant > discusions), and are hence prepared to provide a detailed analysis that will > back up this claim? > > David > ----- Original Message ----- > From: Eric Woodruff > To: boost_at_[hidden] > Sent: Monday, August 05, 2002 2:09 PM > Subject: [boost] Re: Re: Re: Platform > Neutrality-withoutreinterpret_cast<>andifdef > > > Please explain how boost users are supposed to maintain a level of > confidence in the safety of this foundation that is aimed at addressing the > impotence of C++ itself, by providing things that were left out of the > standard, when the communities own design philosophies are brutally ignored > by its own members. > > Boost doesn't stand to make any profit, so then why doesn't it stand on it's > principles above the alternatives? It seems that upon examination, boost is > going the way of all other open projects that exist. This is leading me to > believe that inspecting of OpenSceneGraph, which also provides an image of > holding high-standards, will prove the same. > ----- Original Message ----- > From: William E. Kempf > Newsgroups: gmane.comp.lib.boost.devel > Sent: Monday, 2002:August:05 4:40 PM > Subject: Re: Re: Re: Platform Neutrality -withoutreinterpret_cast<>andifdef > > > ----- Original Message ----- > From: "Eric Woodruff" <Eric.Woodruff_at_[hidden]> > To: <boost_at_[hidden]> > Sent: Monday, August 05, 2002 3:07 PM > Subject: [boost] Re: Re: Platform Neutrality - > withoutreinterpret_cast<>andifdef > > > > I can understand the hit taken in the readability of the mutex > > implementation for "efficiency," but it is unacceptable for thread. I've > > read boost's biases and the thread implementation is a certain violation > of > > the heart of boost's principles. > > Eric, I think you're getting confrontational. Boost went through formal > review and no one had the objections to the *implementation* that you do. > More over, Boost.Threads is hardly the only Boost library that uses > conditional compilation in this manner. If you're going to accuse me of > violating the heart of Boost's principles you'd better back it up with > citations. > > Truth be told, a pre-review version of the library used the PIMPL idiom for > the reasons you cited, and it received numerous complaints for having done > so. The current usage of conditional compilation is a result of the Boost > membership requesting this. > > Bill Kempf > _______________________________________________ > Unsubscribe & other changes: > http://lists.boost.org/mailman/listinfo.cgi/boost > > _______________________________________________ > Unsubscribe & other changes: http://lists.boost.org/mailman/listinfo.cgi/boost"
"AMDG On 03/18/2012 11:11 AM, thijs_at_[hidden] wrote: > I was wondering what the status is on implementing the discard() functionality in random engines? linear_congruential_engine has an optimized discard. I think most of the rest are implemented as as simple for loop. > Eg for MT these is a constant time algorithm, is there work being done on that? > Really? Do you have a link? > Another thing I found in the sandbox is a Sobol and Fauré quasi-random sequence random engine. Is that planned for inclusion? Those too have constant time discard() algorithms. > I believe the implementation is solid, but I'd prefer to have them go through the review process before being included. > A fast discard() is something we need for parallel random number generation, it will allow us to have independent random streams via discarding. > > Finally I've also used an trial PRF engine posted here, and I liked it a lot. What is the status of that random engine? > In Christ, Steven Watanabe"
"From: <nbecker_at_[hidden]> > We can use more functions related to complex types. Here's one handy > one: > > template<typename func, typename flt> > inline std::complex<flt> ComplexApply (func f, std::complex<flt> x) { > return std::complex<flt> (f (real (x)), f (imag (x))); > } > > Can bind do this? Yes, bind can be used to emulate the above, but in this case the dedicated function approach is much clearer. bind is merely a convenient way to define function objects inline. When the complexity of the bind() expression reaches a certain point it becomes easier to simply define the function object "the old way." ;-)"
"On 9 Sep 2013 at 18:41, Andrzej Krzemienski wrote: > Your analysis is correct, but in practice the problem described by Daryle > still exists. Authors of classes that throw in destructors need to take > some action if they have written their libraries in C++03: either mark > destructors as noexcept(false) or embed a sub-object (member or base class) > that has a noexcept(false) destructor. In C++03 it was always best practice to *always* wrap your destructors in a try...catch clause. Now it's somewhat mandatory. As an aside, we could really do with some new compiler warnings on this actually. I already get caught enough times forgetting to mark move constructors as noexcept, without which some STL implementations will silently disable move construction completely. Niall"
"On Wed, Apr 26, 2023 at 2:30â€¯PM Alfredo Correa via Boost <boost_at_[hidden]> wrote: > https://gitlab.com/correaa/boost-multi. I've had a look at this repository, and these are my thoughts. It looks like the author has invested considerable effort to polish everything about the library up to be Boost quality. The README.md is comprehensive, well written, and sounds like the kind of things we care about. I don't know a whole lot about the particular needs of robust multi-dimensional array users but this has got to be worth reviewing. It seems the library requires C++17 or greater, which is unfortunate. But especially unfortunate considering that there are no features which actually require it other than using std::pmr::memory_resource. But this could have been conditionally enabled on the C++ version. That said, there's no rule which says you have to support old versions of C++, and the contents of the repository demonstrate that Alfredo's is likely to be an engineer who reflects the qualities of a good Boost library author. Therefore I endorse this library for review. Thanks"
"On Fri, 1 Jun 2001, Revuz dominique wrote: > > Jeremy Siek wrote: > > >ASTL looks neat... to bad the BGL wasn't around when you starting working > > >on it. Have you thought at all about converting ASTL to use the BGL > > >interface? > > No i didn't think about that ! Nor Vincent ;-) > The BGL is very vertex oriented and we are very edge oriented. Really? Could you explain this? (I don't see how BGL is oriented towards vertices more than edges). Please use concrete examples. > I don't think wanting a implementation that is good for both task is a good > objective. Very true. I am in favor of lots of different graph implementations... BGL has a few and I encourage people to create more to fit different needs. What I am *not* in favor of is lots of different intefaces for the same abstract thing. Not only is it confusing, but it also inhibits reuse. > It is a better idea to propose a general interface for data structures > capable of storing automata or transducers or graphs in general, and > then write algorithms that use this common interface, then the final > user can choose the rigth implementation of the algorithm and the data > structure in is own uniq case. I could not agree more. That is why we developed the BGL graph concepts. http://www.boost.org/libs/graph/doc/graph_concepts.html What I'm trying to suggest is that maybe the interfaces we have defined will work for automata algorithms (I'd be surprised if it didn't). Cheers, Jeremy ---------------------------------------------------------------------- Jeremy Siek www: http://www.lsc.nd.edu/~jsiek/ Ph.D. Candidate, IU B'ton email: jsiek_at_[hidden] Summer Manager, AT&T Research phone: (973) 360-8185 ----------------------------------------------------------------------"
"On 6/23/06, nicola <vitacolo_at_[hidden]> wrote: > One design choice in the BGL is that there are "visitor" functions, e.g. > breadth_first_search() and depth_first_search(), but there are no > "bfs_iterator" or "dfs_iterator". What are the motivations that lead to > such choice? Might they be applied to trees as well? > My guess for that would be that iterators are intended to be cheap to copy but duplicating the stacks, queues, or sets of visited/pending nodes would be very expensive. It might be possible to take advantage of the special characteristics of trees to solve this, however. I think a dfs_iterator shouldn't be that different to implement from the usual iterators, since an in-order iterator already walks the tree in a way similar to DFS, just skipping nodes at different times. ~ Scott McMurray"
"on Mon Jun 04 2007, "Gennadiy Rozental" <gennadiy.rozental-AT-thomson.com> wrote: > "Douglas Gregor" <doug.gregor_at_[hidden]> wrote in message > news:FC0BF0AD-CC21-430D-98B4-3C4FE793440F_at_osl.iu.edu... >> On Jun 4, 2007, at 5:06 PM, Gennadiy Rozental wrote: >>> Every library is tested against particular set of >>> dependencies selected by developer. But only *one* per lib. It does >>> require >>> additional disk space for source tree copy. I don't believe it major >>> requirement these days. >> >> I thought that too, but you are wrong. One of the most common >> failures with regression testers is that they run out of hard drive >> space, because testing Boost... just a single tree... requires tens >> of gigabytes. > > Umm.. so what? My 3 year old desktop got 300 gig. Server sytems should have > an access to even larger resources. All the arguments in the world don't change reality. We have testers for whom the disk usage of our tests has posed a real problem."
"Robert: > Note that if this tree "navigator" were automatically generated > and inserted as part of the documentation build, it could be > replaced by some other implemenation just by changing > the build script. Is this building procedure documented? Regards Matias"
"> Yes, if you need it. Will anything you commit break > compatibility with existing code? No. It's just fix for Boost.Test unit-test to make it compartible with regression testing and one new feature. I asked to make sure. Gennadiy."
"On 21 Jun 2015 at 17:19, Peter Dimov wrote: > run test.cpp : : : [ requires cxx11_variadic_templates > cxx11_template_aliases cxx11_hdr_type_traits cxx11_hdr_tuple ] ; Firstly, many thanks for this tip. I had no idea that Boost.Build could be told that a library requires certain C++ features. AFIO now uses that facility, and that let me clean out some cruft. Thank you. I do wish to reiterate my desire for a std=98|03|11|14|1z parameter for ./b2. I think users get confused - as you can see on stackoverflow - on how to build Boost for C++ 11 or 14 or 1z. A simple ./b2 toolset=clang std=14 ... I think is clear and obvious and memorable. Niall"
"--- In boost_at_y..., dmoore_at_a... wrote: > Some other ideas, since my description doesn't exactly cover the 4786 > case you're describing. I was quite imprecise, as you pointed out, > in my first email. > > > 1. Warning levels and settings are compiled into the pre-compiled > header files, which sometimes a "Make Clean" doesn't even clear out. The Boost.Threads Jam build system does not use precompiled headers, so this is not the culprit. > 2. The "cleanest" way to manipulate warning levels without > interfering with the user's command line settings is the following at > the top of your header file: > > #pragma warning(push) > // Now do your thing > #pragma warning(disable:4786) > > // Rest of header file > > // And at the bottom: > #pragma warning(pop) Yes, but if the brute force disable sans push/pop doesn't work then the "user friendly approach" isn't going to make any difference. > This may help to "tickle" the nested include bug you're running into > and get you moving down a working code path in the MS preprocessor. > > > 3. There's a difference between getting your headers to be "4786 > clean" and having a library user's source code to be "4786 clean". > The warning is triggered whenever the template is > expanded/instantiated. The technique in #2 will clean up the warning > for any member data objects contained in a class definition, but > wouldn't save a user from seeing the warning when they instantiate > something in their source code. To help them, they need a #pragma > warning(disable:4786) at the top of every source file as well. Yes, but this doesn't always work (case in point with the current Boost.Threads code). Bill Kempf"
"Herve Bronnimann wrote: > Dietmar, Dirk, others: are there any plans to take care of the beta > priority queues? Well, yes, there are plans to put them forward at some point but they are not very concrete. I would welcome if somebody would pick this stuff up and move it forward. > Because I was thinking of doing something with it (as a > "public service" if you will), I would really appreciate it if somebody would pick up the code. I can try to help but I cannot guarantee anything with regard to this... > 1. add allocators in the design, to be able to take advantage of > boost::fast_pool_allocator That's probably reasonable for all the [mostly] node based priority queues. When I wrote the code I was occupied with the logic and wasn't comfortable with the details of allocators so I didn't provide this. > 2. make it STL-compatible by using min-heaps rather than max-heaps > (that' actually a piont that we could discuss forever I guess) I think the literature uses the style I'm currently using, at least the literature I used to implement it. This is the only reason it is the way it is: I have no strong feeling about this although the behavior should, of course, be consistent. > 3. adding merge operations for heaps (esp. fibonacci heaps) This should be pretty trivial for Fibonacci heaps. I don't see how this can be done efficiently for other kinds of heaps, however. Even for Fibonacci heaps I'm not sure whether it is possible to guarantee a better complexity than inserting all elements individually (but then, I have only read about the basic algorithms and I can imagine that it is possible to merge them more efficiently). > 4. adding small-rank operations (second_top, third_top?) if it > would not surcharge the interface too much Depending on the kind of heap, this can be done efficiently. Eg. for Fibonacci heaps I don't think that this can be done efficiently. > 4. perhaps adding Chazelle's soft heaps (used for approximate sorting > and minimum spanning tree) Can you point to a URL which gives details on this approach? So far I have implemented (at least partially with respect to radix heaps) all approaches to heaps I have come across (well, I have omitted to a set and/or map adaptor) and I would be interested in other approaches, too. > 5. remove splay heaps and put skew heaps instead (same idea, but > specifically for heaps) Hm, I thought this is what I have implemented... Maybe I goofed things up and there are better approaches I missed for some reason. > 6. put an adapter for set and map tree-like data structures (so you'd > have the splay heap back, but also red-black heap, avl-heap, etc. by > the same token) A general data structure library. Something between sequence (provided by the STL) and graphs. That would be nice. Actually, most heaps are trees and it may be reasonable to provide a tree abstraction(s) and implement the heaps in terms fo the tree abstraction(s). Then you would provide different trees and algorithms on trees (eg. rotating, tree-find, etc.). Also quite interesting... > If you plan to do anything about it, I can send you concrete ideas and > proposals along the lines above. I have no plans to do something with this library in the near future: Actually, I don't need or use them. Somebody asked for this stuff and I thought it would be fun to implement it. Then everybody seemed to have lost interest. I would be glad if someone continues the work. I think it is a basis to start from."
"> -----Original Message----- > From: Boost [mailto:boost-bounces_at_[hidden]] On Behalf Of Andrey > Semashev > Sent: Mittwoch, 8. Februar 2017 19:47 > > > Thank you for your initiative. :) > If you end up creating PRs, remember that the changes should be against the > develop branch, not master. We don't make changes to master directly. Good to know. I think something more-or-less intelligent in Git(Hub) already made "develop" the default source when creating new branches, but it's good to know that this is in fact the desired "way of doing it" in the Boost repos. > Finally, if you're interested in keeping your platform supported, you might > want to consider becoming a tester. This way, at least, the maintainers (and > users) will be able to see the state of Boost on your platform, and maybe fix > the problems as they appear in the future. I'll talk to some people at my company. I'd be all for it. Only thing is, CPU cycles on the z are a precious good because our machine is pretty limited (MSUs). Maybe we could create an LPAR with super-low priority, so that the tests can run when the machine isn't busy doing something else (like compiling our stuff or running our tests). IDK, we'll see. Cheers, Paul The contents of this e-mail are intended for the named addressee only. It contains information that may be confidential. Unless you are the named addressee or an authorized designee, you may not copy or use it, or disclose it to anyone else. If you received it in error please notify us immediately and then destroy it. Dynatrace Austria GmbH (registration number FN 91482h) is a company registered in Linz whose registered office is at 4040 Linz, Austria, Freistaedterstrasse 313"
"FYI, this came from the main author of ReST:"
"John Maddock wrote on 11/27/99 8:17 AM >1) If type T is small, but expensive to copy (pimple deep copy) then the >implementation below will produce worse code than just using "const T&", if >necessary I can deal with this by using SGI style type_traits, to limit >specialisation to POD types. However that may exclude some types (small >iterators) that should be dealt with by the specialisation - take your pick >:-) I've been thinking about the pimpl problem too. I think it may be the death of this suggestion. This is like a huge ham in the butcher window. Sure looks tasty, but when the spouse finds out how much you spent on it it may be your last meal. The only way I see to save this is by following John's suggestion of the type_traits. template <typename T> struct type_traits { static const bool has_trivial_copy = false; }; template <> struct type_traits<char> { static const bool has_trivial_copy = true; }; ... But this defeats the purpose of the IsSmall trick in the first place. It still __might__ be worth it if type_traits had to be there anyway to support some other application. Then we could do something like: template< typename T, bool IsSmallAndFast = sizeof(T) <= sizeof(void*) && type_traits<T>::has_trivial_copy > struct call_traits; template< typename T > struct call_traits< T, false> { ... (haven't actually tried this to make sure it works) And then for (small and fast) class iterators you would still have to specialize for type_traits, but not call_traits. If there were some other benefit to type_traits, might be worth it. But if type_traits only exists to support call_traits, I think not worth it. Any chance we could get core to automate type_traits to support boost? :-) -Howard"
"Geurt Vos said: > > Just downloaded the 1.30.0-beta1 zip. There boost/thread.hpp > is slightly wrong. Line 16 reads: > > #include <boost/thread/conditin.hpp> > > but should be: > > #include <boost/thread/condition.hpp> Fixed. Thanks."
"Ross Smith wrote: > > John Max Skaller wrote: > > > > gcc 2.95.3 is useless. If you haven't broken it > > in the regression tests, you haven't been trying. > > It has a catastrophic bug: it expands inline methods of template classes > > when it instantiates the class. > > > > The following example will fail for any smart pointer > > class with an inline dispatch on the internal pointer: > > > > class Y { smart_ptr<X> x; }; > > class X { smart_ptr<Y> y; }; > > > > Is there a way to turn off this non-conforming behaviour? > > What's non-conforming about it? The above code should certainly fail. The following works in C: struct X { struct X* x; }; struct Y { struct Y* y; }; and replacing an X* with a smart_ptr<X> had better work, or templates are utterly useless for building recursive data structures. Perhaps you wanted me to prepend: class X; class Y; ?? But the example is a special case: just consider: template<class T1, class T2> struct X { smart_ptr<X<T2,T1> > ptr; }; to see that it isn't always possible to forward declare things."
"Does anyone know the satus of these pending libraries? I'm in need of a mutable priority queue. TIA Fernando Cacciola"
"Hi, I was trying to serialiaze ptr_containers and I couldnt find a way, so I copied some headers and modified them to serialize ptr_list(the only one I need to serialize in the moment), and it seems to be working. So If someone is interested, I could send it to someone. Im not an expert in the serialize library, so I dont even know if it is really right... But it worked to me(the objects are all serialized as pointers, so if there's two objects then it just serialize one...). I think that extending it to serialize others sequence containers would be very easy, but I didnt touch in the associative containers... The files that I created: ptr_collections_load_imp.hpp // from collections_load_imp.hpp ptr_collections_save_imp.hpp // from collections_save_imp.hpp ptr_list.hpp // from list.hpp Thank you."
"Ben Robinson <icaretaker <at> gmail.com> writes: > produced that can be run in a unit test framework. The key ingredient > of my idea, is to allow the code to compile by conditionally replacing > the failing static asserts with throwing a run-time exception. Now the > code can compile, and unit tests can be written to confirm that each > assertion either passes or fails as desired. As they say: I'll believe it, when I see it ;) Until that time this is all too much vapor for me. As I mention in other post, you never explained how this condition is checked and who is going to check it: compiler, preprocessor, person. Gennadiy"
"> This has nothing to do with my original problem, but I'm curious what this > Boost.Function constructor would look like if there was a working > boost::arity_traits class. I'm relatively new to generic programming using > C++ templates and I'd like to learn more. What exactly do we need from an arity_traits/function_traits class? To be more clear, what should be in it, and is it a necessity that it compile on non-compliant compilers (i.e. partial specialization)? Paul Mensonides"
"On Mon, Oct 31, 2011 at 12:31 PM, Nathan Ridge <zeratul976_at_[hidden]>wrote: > > > Is there interest in adding a Top-Bounded adaptor into Boost.Range ? > > > > Example: > > > > using namespace boost::adaptors; > > using namespace boost::assign; > > > > std::vector<int> input; > > input += 1,2,3,4,5,6,7,8,9; > > > > boost::copy( input | bounded(0), std::ostream_iterator<int>(std::cout, > > ",")); // prints nothing > > boost::copy( input | bounded(1), std::ostream_iterator<int>(std::cout, > > ",")); // prints 1, > > boost::copy( input | bounded(2), std::ostream_iterator<int>(std::cout, > > ",")); // prints 1,2, > > boost::copy( input | bounded(8), std::ostream_iterator<int>(std::cout, > > ",")); // prints 1,2,3,4,5,7,8, > > There is a Boost.Range extension library called P-stade Oven which > provides this adaptor under the name "taken", and many other adaptors: > > http://p-stade.sourceforge.net/oven/doc/html/index.html > > There exists an effort to port the P-stade Oven library to Boost, called > OvenToBoost: https://github.com/faithandbrave/OvenToBoost. > If you are interested in seeing functionality like this in Boost, perhaps > you can consider contributing to this effort. > "taken" is what I was looking for. I will contact the project owners to offer my help. Thanks!! Regards, Fernando."
"On Sun, 2003-08-10 at 04:20, Craig Perras wrote: > If you haven't seen Fresco (successor to InterViews) before, I think it has a lot of interesting ideas. http://www.fresco.org/ > Just a word of warning. this link is not to the original fresco, but to Berlin/fresco which hi-jacked the original. It is a complete replacement for a windowing system such as X. As well aS A gui toolkit. The original fresco ( including interesting papers ) is available from TargetJr. I think it is in fresco-98.tgz The original fresco originally ran on Windows, Unix/X and I think Mac's. What it added over functionality in Interviews was platform indepence and Object Linking and embeding via a CORBA 1.x orb. It also had persistence via CORBA serrialization service. Interviews is still maintained by Vectaport and is available here http://www.ivtools.org/ivtools/index.html They have an excelent collection of papers and pointers to the original papers as well. I'm not a GUI specialist, but few GUI libs that I have seen have such an elegant design. That is very extensible. It may be a starting point for use with more modern C++ techniques. BTW the license is X style and compatible with boost iirc. /ikh"
"On Sat, Mar 22, 2008 at 04:54:26PM -0500, Rene Rivera wrote: > I went with: > > C:\DevRoots\Boost\boost-release>find.exe . -type f -not -regex > ".*[/][.]svn[/].*" -not -regex ".*\([.]bat\|[.]cmd\|[.] > com\|[.]csh\|[.]m4\|[.]pl\|[.]py\|[.]sh\|configure\|rst2latex\)" -exec > svn propdel "svn:executable" "{}" ";" > > And then ignored the jam changes. So this should now be fixed in the > release branch. I'm applying the same procedure to trunk now. Thanks a lot. Situation improved dramatically and it was indeed not very time consuming. I checked trunk and noticed: * Many *.sh files are not marked executable. This may be OK if these files are explicitely started in a subshell or included in the current shell via ". file.sh". (These files were not touched today!) But some of these files contain also a Shebang (e.g. #!/bin/sh) http://en.wikipedia.org/wiki/Shebang_(Unix) such as tools/regression/src/run_tests.sh. Is #!/bin/sh used if the file is not executable? I doubt it. So I ask myself whether the files are really needed. * Same for *.pl, *.py, ... * tools/jam/src/boehm_gc/NT_MAKEFILE Please remove svn:executable * tools/jam/src/boehm_gc/config.sub Please re-add svn:executable So, now I stop nitpicking :-) Jens"
">>> Realistically though, when is == not (at least) an equivalence >>> relation? >> >> Realistically, and in this context, when the two sides are not of the same >> type. > > In most of the cases that I care about, there is some underlying type like > "string" or "integer", on which an equivalence relation exists in some > formal sense. Then there are some concrete C++ types like > std::basic_string<char,allocator_1> or std::basic_string<char,allocator_2> > or int32_t or int64_t. operator== is defined on pairs of these concrete > types in some way that approximates to the equivalence relation on the > underlying formal type, but with some inevitable flakiness at the edges, > such as comparison between two char*s or comparison between integers with > different numbers of bits. Sure, but these types are inherently related. It should be reasonable to write the semantics of comparisons on related types in terms of the underlying type (or more abstract type, I guess). I can convince myself that those operations on those types have precise semantics: they define an equivalence relation. We attach meaning to symbols. I doubt that many people on this list would read the expression "a == b" as "a and b are operated on by some function with the name == that has some result". I tend to read it as "a is equal to b". If I read it that way, I happen to know something extra about the operator; it's an equivalence relation. I also happen to know something about the values: an expression involving a will yield the same result as the same expression involving b (with some notable exceptions). This additional knowledge seems like a good thing. I don't see how attaching specific meaning to operations impacts implementation flexibility. It certainly impacts design choices and choices about algorithm usage, but I hope in a positive way."
"----- Original Message ----- From: "Peter Dimov" <pdimov_at_[hidden]> To: <boost_at_[hidden]> Sent: Friday, September 13, 2002 3:16 PM Subject: Re: [boost] UBLAS_CHECK > From: "Kresimir Fresl" <fresl_at_[hidden]> > > > > Toon Knapen wrote: > > > > > the bounds checking mechanism throws an exception instead of performing > an > > > assert. But I have no clue how I can ask my debugger where the exception > was > > > thrown so I would prefer an assert() to be used. In the debugger, it's > then > > > easy to perform a stack_trace. > > > > Did you try to define BOOST_NO_EXCEPTIONS ? > > > > raise() functions of all exception classes in `ublas/exception.hpp' > > are defined as: > > > > virtual void raise () { > > #ifndef BOOST_NO_EXCEPTIONS > > throw *this; > > #else > > abort (); > > #endif > > } > > This should probably just call boost::throw_exception(*this), allowing > BOOST_NO_EXCEPTIONS users to handle the exception. Where do I find throw_exception? I searched the 1.28.0 distribution and found a definition in the lambda library only? > Also, I agree that BOOST_UBLAS_CHECK should just assert (by default). I noticed recent discussions regarding the question, whether preconditions should assert. I'm still unsure. > It's > OK to provide a "throw exception" option, of course; even so, throwing an > exception only in debug builds seems very odd. This is not odd, if you're counting flops. > The usual practice (for those > that embrace "logic error" exceptions - I don't) is to throw an exception in > release builds, and assert in debug builds. I'll think about it. Thanks Joerg"
""Carlo Wood" <carlo_at_[hidden]> wrote in message news:20040821201331.GA23261_at_alinoe.com... > On Sat, Aug 21, 2004 at 07:39:43AM -0400, David Abrahams wrote: > > When proposing design changes, first you have to describe the > > problems your changes are designed to solve, or nobody will > > understand the motivation. > > If you are not aware of the problems with boost::filesystem > then I just give up immdeately, instead of wasting my time > by trying to convince you about the need for a redesign. > I've seen several people already agreeing that there is a design > problem with the current boost::filesystem. This is a good way to have your future suggestions ignored. Since filesystem already has many users, you'll need to convince more than 'several people' that there is a problem before your proposal is accepted. Furthermore, how do you know that those people see the same problems as you do, if you're not willing to spell out in detail exactly what the problems are? Jonathan"
"From: "Thorsten Ottosen" <nesotto_at_[hidden]> > "JOAQUIN LOPEZ MU?Z" <joaquin_at_[hidden]> wrote in message > news:31c83531e9c8.31e9c831c835_at_tid.es... > > > >namespace boost{ > > namespace multi_index{ > > template<...> > > class indexed_container; > > } > > using multi_index::indexed_container; > >} > > I think multi_indexed_container (or multi_index_container) would be a > better name. A long name doesn't hurt here since > the container will take some lines to setup with typedef etc anyway. > > Then the class could be in the boost namespace and there could be a > helper namespace, index, which stored the index_list, unique etc. > > This would make the setup of the container look quite good IMO: > > typedef multi_indexed_container< > employee, > index::index_list< ^^^^^^^^^^ Why not just "index::list?" > index::ordered_unique<index::identity<employee> >, > index::ordered_non_unique<index::member<employee,int,&employee:age> >, > index::sequenced<> > > > > employee_set; > > Before I wasn't sure where member, identity etc came from. It was the same namespace before, but I very much like your suggestion. The lingering question in my mind is whether your "index" namespace should be called "multi_index." That would tie the namespace to the class better and means that the library could be called Boost.MultiIndex without leading to confusion."
"Joel de Guzman wrote: > >Oops sorry about that. I'll correct that ASAP. We are currently >finishing up for the release of Spirit V1.2. It should be available >by next week. The code is quite stable. It's just the documentation >that we are finishing. I'll ask Dan if we can setup a tarball of the >latest snapshot. The docs are outdated though and won't be ready >until next week. > We have released 1.2.0 release candidate 1 this morning, which can be downloaded from the following URL: http://sourceforge.net/project/showfiles.php?group_id=28447 If you are interested in spirit, please take a look. We do plan on submitting this library to boost, so any feedback will be appreciated. --Dan Nuffer"
"On Thu, Jun 28, 2018 at 3:11 AM Olaf van der Spek <ml_at_[hidden]> wrote: > On Wed, Jun 27, 2018 at 9:29 PM, James E. King III via Boost > <boost_at_[hidden]> wrote: > > CI not yet enabled on (and reasons): > > > > Boost.Assign fails to compile < > https://github.com/boostorg/assign/pull/16> > > with MSVC 2012 in Appveyor. > > Why does a failure prevent CI from being enabled? > > I prefer to get the build green before turning it on for every build after that. Otherwise one has to look at every build result manually. - Jim"
"On Mon, Sep 1, 2008 at 9:42 PM, Stjepan Rajko <stipe_at_[hidden]> wrote: > On Mon, Sep 1, 2008 at 4:23 PM, vicente.botet <vicente.botet_at_[hidden]> wrote: > >> [snip documentation bugs] > > Thanks for all the error-catching. As you see, there are some good > reasons behind me thinking that the Generic Support Layer is not ready > for review :-) But I'm glad you're giving it a look - I will give > the docs for that layer a pass tomorrow and hopefully make them a > little bit more up to snuff. > I have updated the generic support layer docs, and uploaded the new version: http://www.dancinghacker.com/code/dataflow/dataflow/support.html I (hopefully) corrected the errors you found as well as other ones. I have also updated the beginning of the VTK layer example to talk a little bit about the complemented ports it now uses (the latter part of the VTK layer example is still very much underdocumented). I also added another (undocumented) example of a support layer which is much simpler, but I'm not sure if it's any clearer without documentation. Thanks again, Stjepan"
"I'd being using boost for at least 6 years, and I don't remember any boost wiki. Do someone has access to check the request log of that wiki and confirm if there is traffic (aside from robots)? Maybe nobody is reading and that will make easier to decide to shut it down. Or maybe, that is the most visited page ever and it will not be a good idea. 2018-09-02 4:51 GMT-04:00 Raffi Enficiaud via Boost <boost_at_[hidden]>: > On 02.08.18 13:35, James E. King III via Boost wrote: > >> One thing Trac provides that github does not is a way to summarize the >> backlog (it has) for all components: >> >> https://svn.boost.org/trac10/report/19?asc=1&page=1 >> > > Yes, and I like that feature somehow. Is there any mean on GitHub to > populate release notes automatically from the issues and PRs that have been > merged on master between 2 tags? > > however the list of Maintainers in Trac is stale: >> >> https://svn.boost.org/trac10/report/15 >> > > Trac has been used and (still is) as a wiki and ticket tracking system. > > A wiki needs maintenance, this page you are pointing is outdated and not > maintained, better removing it. > > All in all, if we remove the ticketing system from trac making it read > only, there is no point providing a wiki like system as well, especially if > this one is not being maintained. > > Relevant information for development and use of boost should go to the > boost.org website, or to the boost superproject wiki on github (which has > been partially done). > > Raffi > > > > _______________________________________________ > Unsubscribe & other changes: http://lists.boost.org/mailman > /listinfo.cgi/boost >"
"Rob Stewart wrote: >I contend that you can provide a mechanism whereby clients can >ensure their type can only be instantiated by the Singleton >framework, but don't require that. > I already do :) You can use a type deriving from the singleton if you want true singleton behavior, or you can use a typedef if you want one globally managed resource and any number of local resources. class A : public singleton < A > { /*...*/ }; // only the singleton instance can exist class B { /*...*/ }; // can create any number of B instances typedef singleton < B > global_b; // but global_b manages the lifetime of one global B instance. There is a multiton for cases when you need multiple global instances that uses key based identification, and alternately you can derive a different type from B for each global instance you want managed. class Printer { /*...*/ }; class PrinterA : public Printer, public singleton < PrinterA > { }; class PrinterB : public Printer, public singleton < PrinterB > { }; -Jason"
"Dear All, This is related to the ongoing discussion of the Beast HTTP parser. I have been thinking in general about how best to implement parser APIs in modern and future C++. Specifically, I've been wondering whether the imminent arrival of low-overhead coroutines ought to change best practice for this sort of interface. In the past, I have found that there is a trade-off between parser implementation complexity and client code complexity. A "push" parser, which invokes client callbacks as tokens are processed, is easier to implement but harder to use as the client has to track its state between callbacks with e.g. an explicit FSM. On the other hand, a "pull parser" (possibly using an iterator interface) is easier for the client but instead now the parser may need the explicit state tracking. Now, with stackless coroutines due "real soon now", we can avoid needing explicit state on either side. In the parser we can co_yield tokens as they are processed and in the client we can consume them using input iterators. The use of co-routines doesn't need to be explicit in the API; the parser can be said to return a range<T>, and then return a generator<T>. Here's a very very rough sketch of what I have in mind, for the case of HTTP header parsing; note that I don't even have a compiler that supports coroutines yet so this is far from real code: generator<char> read_input(int fd) { char buf[4096]; while (1) { int r = ::read(fd,buf,4096); if (r == 0) return; for (int i = 0; i < r; ++i) { co_yield buf[i]; } } } template <typename INPUT_RANGE> generator< pair<string,string> > parse_header_lines(INPUT_RANGE input) { typedef INPUT_RANGE::const_iterator iter_t; iter_t i = input.begin(), e = input.end(); while (i != e) { iter_t j = std::find(i,e,':'); string k(i,j); // (That's broken, as iter_t is a single-pass input iterator. We // need to copy to the string and check for ':' at the same time. // It's trivial with a loop.) ++j; iter_t k = std::find(j,e,'\n'); string v(j,k); ++k; i = k; co_yield pair(k,v); } } void parse_http_headers(int fd) { map<string,string> headers; auto g = parse_header_lines( read_input(fd) ); for (auto h: g) { headers.insert(h); } } An "exercise for the reader" is to extend that to something that will parse headers followed by a body. Questions: how efficient is this in practice? Is this really simpler to write than a non-coroutine version? Will all of our code use this style in the (near?) future? How should we be writing code now so that it is compatible with this style in the future? Thanks for reading, Phil."
"On Sat, Nov 24, 2018 at 3:44 AM Jayesh Badwaik via Boost < boost_at_[hidden]> wrote: > > On Friday, 23 November 2018 20:58:44 CET Emil Dotchevski via Boost wrote: > > So you change that to: > > > > if( static_cast<unsigned>(x) < f() ) > > I would change the opposite, I would do > > if( x < static_cast<int>(f())) > > then, if the type of `x` changed in the function, I will now get a new > warning, and I can fix it. What warning will you get?"
"On 3/9/2011 11:14 AM, Steven Watanabe wrote: > AMDG > > On 03/09/2011 10:11 AM, Joachim Faulhaber wrote: >> 3.2.3 Specialization of boost::is_integral<T> >> ============================================= >> >> You'd have to provide an instantiation of boost type trait >> boost::is_integral for xint::integral_t, so meta code that is >> implemented for all intergal types will be able to work with xint >> instantly. > > I disagree. xint::integer_t is not an integral type > as defined by the standard. [basic.fundamental] +1 One would need an alternate metafunction for such purposes. std::numeric_limits<T>::is_specialized && std::numeric_limits<T>::is_integer ? - Jeff"
"Bill Kempf wrote: > > > > Try compiling it as follows: > > > > cl /MLd /GX /EHa foo.cpp ... > especially considering I *DID* check it (VC 6, SP 4), and I'm correct > that the catch block is never entered. Sorry. FWIW, I get the same result as Dave Abrahams. I am just curious, did you compile it from a command line with the same flags? Jacob Hammeken"
""Andreas Huber" <ahd6974-spamgroupstrap_at_[hidden]> writes: > While correcting license & copyright issues in the people pages I've > come across several pages where I don't know how to contact the > copyright owners. Does anybody know how to contact Mat Marcus, Paul > Moore or Vesa Karvonen by email? See the Cc: list"
"On Mon, Aug 14, 2017 at 8:31 PM, Robert Ramey via Boost wrote: > On 8/14/17 10:37 AM, John Maddock via Boost wrote: >> >> BTW is there any reason to continue using the Boostbook customisation >> layer? Is anyone actually using it? I'm fairly sure quickbook doesn't, and >> it would sure simplify the build process to leave out one level of XSL >> transformation. Sadly we would need an XSL expert to sort that mess out I >> suspect :( > > > I think there's a little more to this: > > a) There are special tags like class, struct, etc. etc. Which permit > tagging for different aspects of C++ syntax. Somehow I doubt anyone is > using this stuff. It would be pain to edit it and it would presume that > every class,struct etc would have the same documentation structure which > might be inconvenient. Also the documentation for this is reference and > doesn't give much in the way of sample output etc. Upshot I'm doubtful that > anyone is using it. > Is the Boost.Array documentation not using this? https://github.com/boostorg/array/tree/develop/doc Glen"
"> This seams to be implying something opposite: that empty can can be treated > as less abnormal than error. You're forgetting locality. Locally to the find loop, the valued or errored state returned by something() is the normal situation and you don't care which it returns. Locally to the find loop, failing to find what we are looking for is the abnormal situation. The programmer looking at the find loop won't be thinking in terms of errors or success of something(), but rather that the flow of execution in the find loop is correct or incorrect. I really should emphasise that this stuff, when used in practice, is nothing like as complicated as this thread of discussion is making it seem. Any programmer, even an undergrad, will look at that find loop and know exactly what it means and how it works intuitively. > It is my impression that the system of types in Boost.Outcome confuses two > meanings of "empty" > > option<T> -- either T or "empty" -- in this case "empty" looks like "just > another state of T", as in boost::optional > result<T> -- either T or an error or "empty" -- in this case it means > "abnormally empty" > > Am I right? If so, maybe you need two separate states "simply no T" and > "abnormal situation"? Empty is *defaulted* to the most abnormal state by Outcome's default semantics. So if you call .error() on a valued Outcome, you get back a default constructed error type, no exception thrown. Same goes for .exception(). But if you call .error() or .exception() on an empty Outcome, you *always* get an exception thrown. Therefore, if you write your Outcome using code without state checks before observation i.e. you call .error() without checking .has_error() beforehand, you get a stronger, more abortive default action than if the Outcome were errored, valued or excepted. You the programmer may wish to avoid the default actions, in which case you check state before access. You can then manually specify any other action you prefer. The "more abnormal" solely refers to my design choice of default semantics only for the empty state. Reviewers may think those choices misguided or plain wrong, and might suggest better default semantics. For example, some might feel that any time one tries to observe state where the state is different, you should always throw an exception. That would be a very conservative design choice and I'd disagree with it. But I would understand the rationale. I would also add that it is trivial to wrap an Outcome with replacement observer functions which change the default actions, or to customise the policy class to have different defaults. Niall"
"On Oct 26, 2011, at 6:05 AM, Alf P. Steinbach wrote: > On 26.10.2011 14:17, Yakov Galka wrote: > [snip argumentative noise] > >> This offends me. I'm facing the MAX_PATH limitation at my work. If >> you >> develop nothing more than desktop apps that interact directly with >> the user, >> then please don't infer from this that others don't need it >> either. MAX_PATH >> is a problem in a large scale systems where you have enormous >> amounts of >> data. > > You don't need such long paths for any size of data. Technically, you don't need Windows either. Josh"
"Eric Niebler wrote: > Richard Webb wrote: >> The Trunk test results are showing that a number of new failures (e.g. >> xpressive/parameter/bimap) have appeared in the past couple of days. >> >> The failures appear to have occured as a result of the change to result_of.hpp >> for Ticket #1535 (at least, reverting result_of.hpp to the previous version >> allows the xpressive tests to pass on VC9). >> >> Can anyone confirm this? > > Confirmed, thanks for noticing this. I have fixed xpressive on trunk and > merged the fix to the release branch for good measure. FWIW, xpressive > was missing a few #includes and surreptitiously getting them by > #including result_of.hpp. I'm sure the rest of the new failures are of a > similar nature. Sorry if my patch breaks down some libraries. I should have note dangerousness of that patch in trac. Regards,"
"> The following two types are not used anywhere > typedef typename ::boost::remove_cv::type rhs_nocv; > typedef typename ::boost::remove_cv< typename ::boost::remove_reference< > typename ::boost::remove_pointer::type >::type >::type rhs_noptr; > > Shouldn't them be removed? They are used, but not in the example of the doc. These shortcuts are used extensively in the macro FOBIDDEN_IF which determines if the operator is forbidden for fundamental types (to avoid compile time error). In the doc, I chose a simple case (unary_minus) where FORBIDDEN_IF is only ::boost::is_pointer< rhs_noref >::value Here is a more complex example (has_operator_plus.hpp): #define BOOST_TT_FORBIDDEN_IF\ ::boost::type_traits::ice_or<\ /* pointer with pointer */\ ::boost::type_traits::ice_and<\ ::boost::is_pointer< lhs_noref >::value,\ ::boost::is_pointer< rhs_noref >::value\ >::value,\ /* pointer with fundamental non integral */\ ::boost::type_traits::ice_and<\ ::boost::is_pointer< lhs_noref >::value,\ ::boost::is_fundamental< rhs_nocv >::value,\ ::boost::type_traits::ice_not< ::boost::is_integral< rhs_noref >::value >::value\ >::value,\ ::boost::type_traits::ice_and<\ ::boost::is_pointer< rhs_noref >::value,\ ::boost::is_fundamental< lhs_nocv >::value,\ ::boost::type_traits::ice_not< ::boost::is_integral< lhs_noref >::value >::value\ >::value,\ /* void* with fundamental */\ ::boost::type_traits::ice_and<\ ::boost::is_pointer< lhs_noref >::value,\ ::boost::is_void< lhs_noptr >::value,\ ::boost::is_fundamental< rhs_nocv >::value\ >::value,\ ::boost::type_traits::ice_and<\ ::boost::is_pointer< rhs_noref >::value,\ ::boost::is_void< rhs_noptr >::value,\ ::boost::is_fundamental< lhs_nocv >::value\ >::value\ >::value > I have not see the utility of removing the reference > typedef typename ::boost::remove_reference::type rhs_noref; It is just used to know if the operation is forbidden for fundamental types and pointers. It avoids having everywhere typename ::boost::remove_reference< ... >::type. When checking for existence of operator, full type qualification is used (i.e. LHS or RHS). Frédéric"
"> Chris Thomasson wrote: > > Sent: Wednesday, November 22, 2006 11:32 PM > To: boost_at_[hidden] > Subject: Re: [boost] Preliminary working prototypeofatomic_shared-- > multithreaded wrapper for shared_ptr. > > "Talbot, George" <Gtalbot_at_[hidden]> wrote in message > news:acfee74296c36aa7458ec7c5580b0b9c4564c67b_at_locuspharma.com... > > Hi, > > > I've attached to this e-mail a working prototype of a wrapper for > > shared_ptr that uses a spinlock so that the shared_ptr may be updated > > atomically from multiple threads. For example, two threads can both > > attempt to set the value of the same shared_ptr, and the last one will > > win. This wrapper includes a "compare_and_set" method for performing > > lock-free-style "read, copy, attempt swap, repeat" updating to a data > > structure, though, of course because the wrapper uses a spinlock, it > > isn't truly lock free. > > I suggest you take a look at a mostly lock-free implementation: > > http://appcore.home.comcast.net/vzoom/refcount/ > > Your wrapper uses the spinlock when it doesn't have to... A swap and a cas > to shared locations that contain pointers to the refcount > object do not need to be locked... I know. I was just doing a simple prototype first that has the interface that I want. I figure if I get everything working with the simple stupid spinlock, then I can go back and re-work with atomic operations. > Weak reference count modifications do not need to be > locked... That's good to know. > You don't need to use DWCAS either... Don't I need to do that for assignment and compare_and_set for the actual shared_ptr<>, since it's two words? (pointer to object and pointer to refcount.) This is good feedback. Thank you for the help."
"Beman Dawes wrote: > Eric Niebler wrote: >> We seem to be having a lot of problems >> with Boost.Test lately. This is really bad. Should we revert Boost.Test >> to something that works? > > Yes. This is a disaster. > > Can you do the revert? I'm tied up. It looks like a series of changes > where make on revisions 40065-40078, and then 40090. I've reverted all the Boost.Test changes since r40064. Sorry Gennadiy, this isn't the time for major changes to core infrastructure. If you have small safe bug fixes, please make sure they're well tested and resubmit."
"hi, As part of my course project, I am planning to make changes to the boost archetype classes so that they conform to the current ANSI/ISO C++ standard(INCITS/ISO/IEC 14882-1998). During the process, I will have to discuss quite a few things about these archetype classes and related issues. I wanted to know if i could post my queries on this mailing list or if i should contact the developer(s) of the archetype classes. Just to get a feel of the type of queries i would be asking, here are some questions i have in mind right now: 1. My primary source of the current archetype classes is this : http://www.boost.org/boost/concept_archetype.hpp Is there a more recent header, or is there any such header under development? 2. My professor suggested that since the archetypes are used only at compile time, most of the methods in those classes need NOT have bodies. Any comments? 3. There are several differences between the standard and the current archetype classes, especially the iterator archetype classes. For example, almost all the relational operators (operator==, operator!= etc) have a return type of bool whereas the standard requires a return type convertible to bool. Would changing the return type have any unwanted consequences (not particularly in the concept_archetype.hpp) ? Thank you for your valuable time spent for going through this long long mail. Vamshi. __________________________________________________ Do you Yahoo!? Faith Hill - Exclusive Performances, Videos & More http://faith.yahoo.com"
"I have just recently completed my first alpha release of a generic RPC library designed to support different protocols (JSON, XML, Protocol Buffers) and different transports (UDP, TCP, HTTP) in a generic manner. Currently only JSON over TCP is implemented. This library builds on top of my Boost.Reflect library which provides simple reflection along with a generic type-erasure construct, boost::reflect::any_ptr<T> Lastly all of this builds on top of my Boost.CMT (Collaborative Multi-Tasking Library) which seems to be along the same lines as Oliver's Boost.Strand library, but with a simpler interface. It is built on top of Boost.Context. This allows the RPC to be asynchronous, thread-safe, and free of nasty completion handlers. I have documentation of all three libraries posted here. http://bytemaster.github.com/dev/modules.html I would like to know if I am barking up the right tree here and if anyone has any feedback. If someone has a real project they would like to see this code incorporated into I would be more than willing to focus my development effort toward those needs."
"On 2016-03-08 6:18 AM, Rene Rivera wrote: > 1. Some people don't fancy auto-linking. > > 2. People responding with "+N".. Which of the following would you prefer? > And give rationale for your preference, and optionally give rationales for > not preferring others: > > A) Having file names with "32" *and* "64" on them? > > B) Having current names indicate 32 and adding "64" to file names otherwise? > > C) Having current names indicate the "default" system address-model and add > "32" or "64" to indicate the non-default? > > D) Having the current names and placing 32 bit address-model variants in > "stage/lib32" and 64 bit in "stage/lib64"? (Equivalently for install > location) > > E) Having the current names and placing 32 bit address-model variants in > "stage/lib" and 64 bit in "stage/lib64"? (Equivalently for install location) > > F) Having the current names and placing the "default" system address-model > variants in "stage/lib" and the non-default in "stage/lib32" or > "stage/lib64"? (Equivalently for install location) I would prefer option A. It fits current naming scheme where each available option is spelled out explicitly as part of the name: toolset, thread_opt, rt_opt. This would just add another option to this list: platform(x86, x64, arm). There is another alternative, which will suit better people who don't fancy auto-linking: use the composed name for folder and keep library names the same: vc140-x86-mt-1_60/ boost_system.lib boost_thread.lib ... vc140-x64-mt-1_60/ boost_system.lib boost_thread.lib ... Auto-linking would work exactly as it works now, but for people configuring projects manually things will become much easier: specify the same library names for all targets, just a different folder to look for libraries per each target. This would become even better if option names were to correspond to relevant toolset macro names. Than one could also specify the same lib folder for all targets: boost_1_60_0/lib/$(PlatformToolset)-$(PlatformTarget)-mt-$(Configuration)-1_60/ This would expand into: boost_1_60_0/lib/vc140-x64-mt-Debug-1_60/ boost_1_60_0/lib/vc140-x86-mt-Release-1_60/ etc."
"On 03/01/2017 12:56 PM, Antony Polukhin via Boost wrote: > 2017-02-21 13:52 GMT+03:00 ÐœÐ¸Ñ…Ð°Ð¸Ð» ÐœÐ°ÐºÑÐ¸Ð¼Ð¾Ð² via Boost <boost_at_[hidden]>: >> Dear community, >> >> I've recently started contributing to boost::variant. To speed up variant's >> compilation I'm implementing mpl::vector on variadic templates. For now >> status of new vector implementation is: > <...> >> made me wonder, is there interest in variadic templates implementation? Are >> there limitations for it's usefulness, which I did not see? > > I'm very interested in patching MPL to be able to use variadic templates. > There was a variadic template mpl try from 7 years ago: https://github.com/cppljevans/variadic_templates/tree/master/boost/mpl Maybe it could give you some ideas. OTOH, maybe it's *too* old :( HTH. -regards, Larry"
"On Wed, Oct 17, 2018 at 6:12 AM James E. King III via Boost <boost_at_[hidden]> wrote: > Perhaps working towards removing the singleton from the implementation would > be a worthy course of action. It has come up often in pull requests over > the last few years, correct? What problem(s) does the singleton solve in the > library, and could those issues be solved in a different way? Great minds think alike! There was a nice discussion yesterday on Cpplang Slack of why the singletons exist, in the #boost channel (between me and Peter D) you should sign up and access the history: http://slack.cpp.al Regards"
"Kornel Kisielewicz wrote: > Mind you, I'm not trying to convince anyone to the creation of a new > Boost.Patterns library (although I'd really like to do that if > possible), instead I'd like to ask you if there's a viable GSoC > proposal in this post, one that one day might turn into a useful part > of boost. I suppose there could be, but I'm not really convinced by the patterns you're proposing. I'd be more interested in tools and utilities that factor the common idioms as mixins or macros than in the GoF patterns."
"Jean-Christophe Roux wrote: > Here is basic use case. I have this ajaxian website with a button that, > on a click, calls a php script taking a couple of POST parameters and > returning a string. I suspect that C++ would nicely speed up the > process. What would be the best use of your library? Of course, I worry > about the time to start the process. The time to start the process is an issue that always exists with CGI, and can be reduced by using FastCGI or SCGI. Anyway, if you use PHP as an apache module, this is not only highly unsafe but also quite annoying, permissions-wise and stuff. The only right way to do such a thing is using CGI, FastCGI or SCGI."
"On 8/16/10 1:01 AM, Stefan Strasser wrote: > Zitat von Joel de Guzman <joel_at_[hidden]>: > >> class foo >> { >> public: >> >> int x() const; >> void x(int n); >> int y() const; >> void y(int n); >> >> private: >> // encapsulated >> }; >> >> Now, adapt that class to fusion. > > is the goal a (mutable) fusion sequence with value type int? > then there is no solution, as the class only exposes the value of its > members. > if the goal is just any representation of the class in sequence form, > I'd suggest to make the (now transparent) proxy object visible to the user. [snip] And as a matter of fact, that IS the intent. The proxy object is a public class in namespace boost::fusion::extension named class_member_proxy (terser name suggestion welcome). I hope you guys see now from the example above that it is a very typical representation of an OOP *class*. I'd say that this example is the most common form of class that needs to be adapted and that the only way to satisfy this requirement is to do it the way it is done now. It's not perfect, it's not as clean as I hoped. I too don't like proxies since C++ does not allow you to write perfect proxies. But I see no other way around. Regards,"
"Jeff Garland wrote: > > ... the non-template version [of the fixed-point decimal > proposal] definitely introduces inefficiencies when the > scale is known at compile time. > Well, objects carry an extra int around with them; and the scale is passed as an argument to the constructor. The representation of unity is calculated at construction time in both designs. That could be done with a recursive template, though. If enough folks prefer a template design, I can go back to it. Rounding modes could be part of the type as well, but I'm not sure that's desirable. > > ... as I recall the template version was already working? > Not with MSVC v5. I had to get rid of all the i18n stuff to get any output; and I wouldn't want to do that for the final version. Also, I hadn't tested completely enough to have instantiated all the member templates. Stephen Nutt (IIRC): > > It is not clear to me why [having the scale as part of the > type] would have added lots of member functions. > There would be member function templates for construction, assignment and the usual op= operators taking decimals of other scales as arguments; then specializations for efficiency when the scale is known to be the same. Jeff Garland: > > ... for the most part I'm not to worried about > interoperation of decimals with different scales. > Interest rates and currency. --Bill Seymour"
"On Fri, May 11, 2007 at 11:54:24AM -0400, Stefan Seefeld wrote: > > And there also was some debate on overloadable whitespace operator: > > http://www.research.att.com/~bs/whitespace98.pdf This is simply fantastic. I am going to revise all my way of writing code. This is the template metaprogramming, isn't? I have only a 2D-display, this explain why I am not able to read all those compilation errors! cheers domenico -----[ Domenico Andreoli, aka cavok --[ http://www.dandreoli.com/gpgkey.asc ---[ 3A0F 2F80 F79C 678A 8936 4FEE 0677 9033 A20E BC50"
"Thijs (M.A.) van den Berg wrote: > Now it has grows into a > large set of libraries for specific niches with varying level quality > (code, docs, maintenance support) Really? Is that what it is? Are you sure? Or is that a goal you have in mind? Is that what boost was while it was in svn? Or did boost become that by migrating to 100 *interdependent* git repos? Did migrating to 100 *interdependent* git repos help the above statement in any way? > , and perhaps varying levels of language > support (C++14 only libs?) and modularization makes sense. > > Some examples of environment that have solved the issues of having large > sets of libraries with dependencies and various levels of quality: Debian > Linux, R project, python pip. Are you saying you want similarity to those projects from boost? Boost is released as one tarball, as I linked in the original post, and that is not going to change. Or it is not a goal to change that, apparently. In that monolithic light, please walk me through the analogy how current boost (or a boost you have as a goal) relates to Debian Linux, because I don't get it. > Maybe we need an independent "apt-get" like tool for C++ libraries? Not > just for boost libraries, but various other C++ libraries as well? Are you saying this should be a goal? Is a modular release of boost (a tarball per library) a prerequisite for that or not? Tell me how things are now in your words and tell me what your goal is. Thanks, Steve."
"On 5 November 2017 at 13:10, Andrzej Krzemienski via Boost <boost_at_[hidden]> wrote: > Hi Lorenzo, > Issue 1 is a bug in the implementation of Optional that I introduced a > couple of days ago. This has been now reverted, but we will still see the > error reports for the next couple of days in the test matrix. > Issue 2 seems to be the communication problem between the compiler and the > standard library, but I do not know anything specific. FWIW I'm getting an error on the develop branch using g++ 4.4 in C++0x mode: ../../boost/optional/optional.hpp:954: error: â€˜boost::optional<T>::optional(boost::optional<T>&&)â€™ cannot be defaulted ../../boost/optional/optional.hpp:1031: error: â€˜boost::optional<T>& boost::optional<T>::operator=(boost::optional<T>&&)â€™ cannot be defaulted g++ 4.6 doesn't have this issue."
"Hello, Recently there was discussion about renaming boost/type_traits/is_POD.hpp to boost/type_traits/is_pod.hpp IIRC, someone actually renamed the ",v" file on the CVS server. This doesn't quite work. One should COPY the ",v" file to the new name, and then "cvs remove" the old name from the trunk. Finally, one should "cvs remove" the NEW name from any release branches and use "cvs tag -d" to delete the sticky-tags on the branches from the NEW name. All of this is to avoid the problem I just encountered. I checked out version Version_1_29_0 from CVS, only to discover that the "is_POD.hpp" header is not found. -Brad"
"On 01/16/2005 03:11 PM, Larry Evans wrote: > On 01/15/2005 05:26 PM, David Abrahams wrote: [snip] > > > > Finally, the kind of access being done is completely different from > > what's done with tuple. > > I've not looked *real* close at tuple, but I assumed boost::tuple had > the following type of access: [snip] > Could you elaborate on how the kinds of element access in boost::tuple > and that of tuple_type in get_ith_head_test.cpp are different? Maybe you meant the way element access was being done. I've just looked at boost/tuple/detail/tuple_basic.hpp. I see two templates which may be candidates for how tuple implements get. The first is: template< int N > struct get_class { template<class RET, class HT, class TT > inline static RET get(const cons<HT, TT>& t) { #if BOOST_WORKAROUND(__IBMCPP__,==600) // vacpp 6.0 is not very consistent regarding the member template keyword // Here it generates an error when the template keyword is used. return get_class<N-1>::get<RET>(t.tail); #else return get_class<N-1>::BOOST_NESTED_TEMPLATE get<RET>(t.tail); #endif } ... and the 2nd, which looks closer to what could be the implementation is prefixed with comment: // -cons type accessors ---------------------------------------- // typename tuples::element<N,T>::type gets the type of the // Nth element ot T, first element is at index 0 // ------------------------------------------------------- but the code for that looks very similar to get_ith_tail. The difference is that get_ith_tail uses specialization to split apart the Head and Tail parts and recurses on the Tail, whereas tuples:element uses the nested typedef for tail_type to recurse on the tail. Do you mean this is completely different, or is there some other code I should look at to see how tuple accesses its elements?"
"Hi, I don't know if it's place and time to do this question. I'm a student of Phisics from Padua and I'm interested in compute science like simulation, Monte Carlo Method, PDE, EDO, etc. I read that there's a projects about it and I would like to know if there is any chance work as a part of Gsoc. Andrea 2014/1/18 Bjorn Reese <breese_at_[hidden]> > On 12/29/2013 12:22 PM, Bjorn Reese wrote: > > Should we start collecting ideas? >> > > Another idea: a rolling hash [1]. > > [1] http://en.wikipedia.org/wiki/Rolling_hash > > > > _______________________________________________ > Unsubscribe & other changes: http://lists.boost.org/ > mailman/listinfo.cgi/boost >"
"Aside from editorial changes which I'll post as a patch set: The term "concept" is overused in this document, where "primitive", "construct", or "object" would be more appropriate. The rationale for the Lock object is somewhat roundabout. The second paragraph begins: "A lock object is not a synchronization primitive" But you've never defined "synchronization primitive", so this is not meaningful. The crux of the issue is buried in the least-emphasized part of the paragraph (the middle): "instances of a lock object are only going to be created, at least in theory, within block scope and won&#39;t be shared between threads" [what's with &#39;? I doubt that's legal, and the job could be done by "'" just as well, couldn't it?] But anyway, I'll attempt a rewording in my patch set. In the sequence of usage comparisons between thread_ref and noncopyable thread object, it's unclear in some cases which is which. A side-by-side table with descriptive headings would be easier."
"On Mon, Aug 22, 2022 at 11:34 AM Andrzej Krzemienski via Boost <boost_at_[hidden]> wrote: > I use URLs indirectly by using Boost.Beast, but Boost.Beast > offers a higher-level interface for providing parts of URL huh.. that's news to me :) Beast only gives you the string in the request message: https://github.com/boostorg/beast/blob/76043dec2cf67a2ba33b32bdcc129f5f0027b8be/include/boost/beast/http/message.hpp#L173 it is this string which users of both Beast and URL would want to parse, e.g. void handle_request( beast::request const& req ) { urls::url_view u( req.target() ); ... Just out of curiosity where do you see this higher level interface for providing URL parts that Beast provides? > There is one thing that I do not understand though. I read that: > 1. The library is tailored for environments that do not use exceptions > 2. url guarantees that it maintains its invariant of always storing a > string that represents a valid url. Yeah, I think that we (the library authors) and the documentation are not communicating things correctly. So I will try to make some statements that are definitely correct, and then perhaps we can sort out what it means for exceptionless environments: * Anything which allocates memory will throw on heap exhaustion (class url mainly) - redefine BOOST_THROW_EXCEPTION to call std::terminate or something * URL and authority parsing free functions and grammar rules do not throw (they use error_code) - they return views, which do not allocate * url_view, url, and static_url constructors will throw on syntax error - simply avoid these constructors and use the free functions instead * modifiers which take un-encoded inputs have a wide contract: all input strings are valid - however the url might need to reallocate memory to encode the result * modifiers which take encoded inputs have a precondition: the input is a valid encoding for the part - you can call the non-encoded function which will do the encoding for you * serialization of a url, url_view, or static_url throws nothing - because the string is always stored serialized * static_url avoids all allocation - but it will throw on overflow, and the caller is expected to size the variable appropriately, and prevent passing large inputs My thinking originally was that parsing into a view, storing a serialized string, and offering the static_url container could be meaningfully called "friendly for environments without exceptions." We should probably reframe this :) > So given the following code executed on a platform with exceptions > disabled, what happens? > > void test(url my_url) > { > my_url.set_port("twenty-one"); > } Well the invariant that the container always holds a valid URL will no longer be true. > if I were using urls in no-exceptions environment, I think I > would expect an interface like: > > error_code ec; > my_url.set_port("twenty-one", ec); Yes this is something we might formalize into the API, although we would use `result<void>` as the return type. But I'm not sure how helpful that is. This needs some thought. > if there is N types > storing the same logical data in N different ways, and I have a function > returning this logical data, I do not want to offer N functions with N > names. I may add a template, or I may use a universal type that can cheaply > convert to the N types. How do I do that if I do not want to put templates > in the interface of my library? Ah yeah that's actually quite easy. `url_view_base const&` will capture the read-only part of any URL, while `url_base&` will capture both the read-only and the modifiable part of any URL. No templates needed. You inspired this change when you reported the problem with slicing. Example code: // can be called with url_view, url, or static_url void f( boost::urls::url_view_base const& ); // can be called with url or static_url void f( boost::urls::url_base& ); We should probably document this usage. > Next, classes url_base and url_view_base are part of the library's public > API. Why? You can keep them as bases but not advertise them in the library > documentation. Do you expect any use cases for them? They are advertised in the reference: <https://master.url.cpp.al/url/ref/boost__urls__url_view_base.html> > Next. the design in url classes is that it is a mixture of the generic URL > as defined in the RFC, and the HTTP-speciffic stuff, such as paths and > parameters. It is never the case that I need both of this worlds at the > same time: I either need a generic URL that has a password but doesn't have > path or params, or I need a HTTP-like URL, where I do not need a password. > So if we think about strong types with strong invariants, I never get as > strong a type as I would need. For instance, I would never want to pass the > password in URL when using Boost.Beast, so having member set_password would > only be a potential for bugs. Password can in fact appear in HTTP. This is a valid CONNECT request: CONNECT user:pass_at_[hidden] HTTP/1.1\r\n\r\n Since that request-target is not a valid URL, you would need to call `parse_authority` instead. The return value from that function is result<authority_view>. > Am I suggesting anything? The only use case that I have for this library is > HTTP-like URLS. I would appreciate a http::url class that is tailored for > http or even REST protocols. Aside from offering the password, which could be restricted with business logic instead of a new type - I feel that boost::urls::url_view and boost::urls::url are pretty well suited for HTTP and REST. The hierarchical and structured interpretations of path and query and provided as separate containers with reference semantics, so they do not burden users of opaque schemes. There's a balance that is struck here - users are offered containers which works for all URLs, and while some of the API may not be of use to your particular use-case, there is some value having a vocabulary type which can be trafficked universally regardless of its contents. > Regarding the docs, while I agree with others that some examples of use > cases, such as percent encoding, would be desired, I also note that the > documentation stands up to the high standards of of Boost libraries: Well thanks for the kind words! But... well.. we still have work to do there. Thank you though! > I have two recommendations, though. One, the picture that associates IQs > with facial expressions: I strongly recommend that it is removed. It does > not bring any technical value, but it seems to be sending a hostile message. LMAO... I only put that in for the review, for some levity. It would of course not be in the final library. > Two, the colouring of different parts of URL syntax, as in > https://master.url.cpp.al/url/containers.html#url.containers.generic_syntax: > it help to quickly grasp things, but it also bring some confusion. For > instance, I cannot tell if the double-slash is part of authority, or if the > colon is part of the scheme. The colors suggest that they are, but the > member functions tell otherwise. Well it is using the ABNF syntax. We could state that explicitly, and point out that the colon, double slash, question mark, and pound sign are delimiters which separate the parts and are not considered to belong to their respective element. > I didn't have time to play with path and param views. They seem fine on the > surface, but I have a feeling that they would be clumsy to use in practice. > I observed that params allow duplicate keys? Is it legal? Yeah, duplicates are allowed. I think the path views are pretty OK. I'm not sure about params. I mean, we need the container and it should be iterator based, and it has to provide the key and value. But I don't know if "bool has_value" is best, or if we should use an optional, or if we should use `pair<string_view, optional<string_view>>` as was suggested. It would be nice if people with actual need for processing query params could kick the tires and weigh in on this. > Finally, I want to thank the authors for writing and sharing this library. > It is clear that a lot of effort and thought has been invested in it. Thank you for taking the time to write the review! Regards"
"Gary, My responses are below the questions/comments. > file: tokenizer_policy.hpp > fns : boost::tokenizer_policy::dereference and increment, both have a > statement > "using namespace std;" > but I don't see any calls to functions from that namespace. What am I > missing here? Or is this leftover junk? (I did see the comment that "assert" > was sometimes, global, but I thought it was always a MACRO. hence no > namespace issues are possible.) > I believe that tokenizer_policy::dereference and increment have assert(b.valid_). I believe if you include cassert, assert is in namespace std. If someone knows differently about assert, I would appreciate being enlightened. > In (again) > fn boost::csv_seperator::template<..> operator() > I would prefer the loop while (next != end) { ..... ++next; } > be replaced with > for(;next != end; ++next) {} > > it's not a big deal, but with loops that have an increment like this, IMO it > reads easier, as in I'm sure that "next" is going to be incremented. Took me > a minute to verify that it was indeed the case. > Good point. I originally wrote the function totally inline. Thus there were iterator increments all over the place. When I factored out the escape sequence processing. I left the structure the same. I tend to agree with out that for(;iter!=end;++iter) is the preferred form when possible. > Also, shouldn't the second argument InputIterator end, be InputIterator > const &end ? > (I just looked over some STLPort code for things like std::copy, and it > makes a copy of "end" so no doubt there are conversion comparison issues > that I'm forgetting, so this is a pretty weak suggestion.) > > Same for the the constructor in the class offset_separator? > The reason begin is a reference is that it needs to be changed by the parsing functor. Because the functor does not need to change end, I just followed the convention of the STL and used pass by value. > same class, member function operator(), wouldn't it be easier to read, > > if (!breturnpartiallast_ && (i < (c-1) ) ) return false; > > than the nested if's. > Looks good. > and > for (; i < c && next != end; ++i, ++next) > tok += *next; > to avoid the extra copy that > next++ makes? > > I think that will work and be more efficient. > In general the constructors with all default arguments should be declared > "explicit" for the well known reasons of inadvertent conversion. > Good point. Thanks. > Why are the data members of cvs_seperator public? or did you mean to use a > "class" instead of a "struct". > They should be private. > For template class punct_space_seperator, why not use a second class > element, the charTraits = std::char_traits<Char> > to mimic the std use of > basic_string. (Pass in the extra template argument to basic_string<> > > Could you explain this one more and maybe give an example? I am not sure I fully understand. > For the class offset_seperator, why not use an vector::iterator in place of > unsigned int curoffset_ ? Then instead of testing offset_.size(), you could > test curoffset_ != offset.end(), > and instead of doing c = offset_[curoffset_]; you could do c = *curoffset_; > (A small efficency I suppose, but I have a tendency to use iterators rather > than index's as if for some other reason the container changes, often the > rest of the code doesn't have to.) > The big reason for using a index instead of an iterator is operator= and copy constructor. A copy of the iterator will not be valid for the copy of the vector. However, the copy of the index, will be valid for the vector copy. Thus, the compiler generated versions of these are correct. > I'm going to spend some more time with this library as it looks really > useful. And I know that all the comments are really nitpicky. Sorry, but > that is the way I am. > -gary- Thanks for your comments, John R. Bandela"
"This issue is with gcc, but a much earlier version - 2.95. I had to compile my code recently with gcc 2.95 where I ran into lack of ostream issues. So this change should be done only if gcc 2.95 is not to be supported moving forward. -Rajat ----- Original Message ---- From: Beman Dawes <bdawes_at_[hidden]> To: boost_at_[hidden] Sent: Sunday, November 19, 2006 7:12:23 PM Subject: Re: [boost] mistaken uses of <iostream> Douglas Gregor wrote: > On Nov 18, 2006, at 10:20 AM, Howard Hinnant wrote: >> I did a brief survey of boost 1.33.1 and found many "relaxed" uses of >> <iostream> under the boost/ directory (i.e. non test-case code). So >> in practice it does appear that using <iostream> as a shortcut is >> considered acceptable practice. However I wanted to highlight the >> point just in case people do view this as a bug that has simply snuck >> in under the radar to date. > > IIRC, at one point we were supporting a platform that had <iostream> > but not <istream> or <ostream>, so I got in the habit of using > <iostream> despite its cost. That platform might not matter any more, > and I'd support fixing Boost's headers to avoid including > iostream.... just not for 1.34.0 :) I agree. I have a vague recollection the platform was GCC, although that was many years ago so I may be mistaken. Out of curiosity, I changed the uses of <iostream> in my local copy of the random library to use other std headers, and it still passes regression tests for GCC 3.3.4. --Beman _______________________________________________ Unsubscribe & other changes: http://lists.boost.org/mailman/listinfo.cgi/boost"
"Do you expect the errors that this will catch to be programmer bugs? If so, abort should be the default. On Mon, Jun 18, 2018 at 4:54 AM Damian Vicino via Boost < boost_at_[hidden]> wrote: > Hi, > I'm preparing my library safe_float to be proposed for review. > > The library was born in the GSOC2015, but it never reached a review ready > state. My plan is to change that in the next few months. > > At this point, I'm looking for some volunteers to proof-read the > documentation. Code is going through major rewrite, and I will send another > mail looking for help with reviewing the code when that is done. > > The most current documentation can be read directly from the web here: > https://sdavtaker.github.io/safefloat/ > > Any comment is appreciated. > > Best regards, > Damian > > _______________________________________________ > Unsubscribe & other changes: > http://lists.boost.org/mailman/listinfo.cgi/boost >"
"Stephan T. Lavavej <stl <at> exchange.microsoft.com> writes: > > [AgustÃn K-ballo BergÃ©] > > Builds successfully with msvc-12.0. However, the following trivial > > snippet results in an ICE: > > Repros with both VC12 and VC14. Filed as DevDiv#996370 "ICE with Boost > 1.56.0 RC1 - Assertion failed: > is<T>(), trees.h 626". Could that be the same bug as https://connect.microsoft.com/VisualStudio/feedback/details/915061/vc12- update-3-rc-boost-1-56-compiler-crash? That ICE is also caused by the Boost.Range free-standing operators. The mentioned workaround also applies to Boost.Lambda: replacing the anonymous enum in lambda/detail/operator_return_type_traits.hpp with static const ints makes the ICE go away."
"Hi... I looked at the documrntation or 'any' class. It looks good but it didn't tell any thing if i can use it as follows any x=foo(); It also didn't discuss this case any x=5; any y="5"; any z=x+y; Now what is z? A string or a numeric? Mohammed"
"On 8/24/2011 1:58 AM, Roman Perepelitsa wrote: > 2011/8/23 Eric Niebler <eric_at_[hidden]> > >> After playing around with functional languages, I've come to envy how >> easy they make it to curry functions. Call a 2-argument function with 1 >> argument and you get a function that takes 1 argument. Pass another >> argument and it evaluates the function. Simple. In contrast, C++ users >> have to use binders, which are not as nice. >> >> On a lark, I implemented a wrapper that turns any TR1-style function >> object into a "curryable" function object (attached). Successive >> function call invocations bind arguments until enough arguments are >> bound to invoke the wrapped function. With it you can do the following: >> >> curryable<std::plus<int> > p; >> auto curried = p(1); >> int i = curried(2); >> assert(i == 3); >> >> Is there any interest in such a thing? > > > I think it's a very useful thing to have! > > curryable should probably be renamed to curried (this is the term > http://en.wikipedia.org/wiki/Currying uses). A generator for curried objects > named curry would be a nice addition too, as would be the reverse - uncurry. Thanks. It's important to get the terminology right. But I thought uncurry had to do with tuples holding arguments. > By the way, don't you need to manually pass arity in the general case? What > if the underlying functor is callable with one argument, but also with two? As soon as enough arguments are collected to make a valid call of the curried function, it gets called. This seems reasonable to me. > I think this is the case with functors generated by bind -- they appear to > be callable with any number of arguments. Ouch. :-( One option, which I don't like, is to "fix" bind to disable any operator() overloads that result in an invalid invocation of the bound function. That can be done easily with the is_callable_with metafunction in my curryable implementation, but would reduce portability somewhat. > FWIW, Egg<http://p-stade.sourceforge.net/egg/doc/html/egg/function_adaptors.html>has > curryN (where N is a number literal) and uncurry. Of course, I'd prefer it if it just worked without needing to be told the arity. That's what I was aiming for."
""Michael Marcin" <mmarcin_at_[hidden]> writes: > My work likes to keep a minimal subset of boost in the project tree. One of > the libraries we are using (I can't remember which off hand) requires > transform_iterator.hpp which includes boost/function.hpp. I noticed when > merging in the latest RC updates that I had commented out this header as it > doesn't appear to be necessary and saves me from bringing yet another > library into the mini-boost folder. > > Is this dependency actually necessary? Doesn't seem like it should be. Why not take out the #include and see what breaks?"
">> If copyright weren't a problem, I'd suggest the Apache 2.0 licence which >> gives stronger guarantees to the end user (a Boost library doesn't >> actually have to have the Boost licence, it's just strongly >> recommended). But you don't own the copyright to the entire library. > > The library only has NumScale copyright notices, so they claim ownership of > the library, and could re-license it. They could relicence *subsequent editions* of it, but not any already released edition. Just the same as Oracle made subsequent editions of ZFS proprietary, but could not retract the licence for already released editions. > AFAIK the Boost Software License requires keeping the copyright notices of > any work it is derived from, so this is a violation of the BSL. > Boost.SIMD is derived from the NT2 library which was a BSL-licensed > collaboration between various parties. > > I warned NumScale about this a few years ago, but they dismissed it. It would be highly common for a software startup being spun out of a university to have the ownership of any relevant IP held by the university transferred or sold to it. Because the startup owns the copyright, and is not a licensee, it can do anything it likes with the copyrighted IP, including deleting any text such as prior copyright notices. You only need preserve licence notices where the licence you are placed under demands it because you don't own the IP and can't do whatever you want. Now, as to whether misrepresenting the provenance of software is moral or not is another question, but if you own the IP, it's legal. And it is certainly common in the industry, one contract I had with a household name multinational had me convert a third party software library over to eliminate all evidence of its true origin. They had bought a full owning copy from the IP originators, which is also possible BTW, but now it was theirs it laboriously needed to be made to look so. Niall"
"On Sun, 19 Jun 2011 12:29:41 -0500 Bryce Lelbach <blelbach_at_[hidden]> wrote: > The proposed Boost.Xint does not fulfill the thread-safety promises > that it makes. The library uses a custom allocator (allocator_t), > which uses global variables and does not protect them with a > synchronization primitive. [...] What global variables are those? The only non-local variables I see from a quick perusal of allocator_t are fixed_length and magnitude_datasize (allocator_t static consts) and minimum_digits (a global const). > Can the author of this library please make the custom allocation > strategy optional? [...] I think the better solution here is to not > tie Boost.Xint to a particular memory allocation scheme. If I work on it any further (still undecided), that's already on the to-do list."
"Peter Dimov wrote: > PS. <boost/function.hpp> and Phoenix don't play together on VC 7.1. > > C:\boost\trunk\boost\spirit\home\phoenix\core\detail\function_eval.hpp(107) > : error C2027: use of undefined type 'boost::function' > > C:\boost\trunk\boost\function\function_base.hpp(99) : see declaration of > 'boost::function' Thanks for spotting. Fixed. Regards,"
"-------- Original-Nachricht -------- Betreff: [move] problem with msvc-10 (BOOST_MOVABLE_BUT_NOT_COPYABLE) Datum: Wed, 24 Nov 2010 20:56:46 +0100 Von: Oliver Kowalke <oliver.kowalke_at_[hidden]> An: boost_at_[hidden] Hi, msvc-10 has some problems with boost.move. linker error: LNK2019: unresolved symbol "private __cdecl X::X(class X const&)" Example doc_file_descriptor.cpp (uses BOOST_MOVABLE_BUT_NOT_COPYABLE) does not compile too. g++-4.4.5 accepts the code. ? thx, Oliver #include <boost/move/move.hpp> #include <boost/shared_ptr.hpp> class X { private: BOOST_MOVABLE_BUT_NOT_COPYABLE( X); struct impl_t {}; boost::shared_ptr< impl_t > impl_; X( boost::shared_ptr< impl_t > const& impl); public: X(); static X create(); X( BOOST_RV_REF( X) other); X & operator=( BOOST_RV_REF( X) other); void swap( X & other); }; X::X() : impl_() {} X::X( boost::shared_ptr< impl_t > const& impl) : impl_( impl) {} X X::create() { boost::shared_ptr< impl_t > impl( new impl_t() ); return X( impl); } X::X( BOOST_RV_REF( X) other) : impl_() { impl_.swap( other.impl_); } X & X::operator=( BOOST_RV_REF( X) other) { if ( this != & other) { X tmp( other); swap( tmp); } return * this; } void X::swap( X & other) { impl_.swap( other.impl_); } int main(int argc, char * argv[]) { X x( X::create() ); return 0; }"
"On 10/06/2013 08:56 PM, Daniel James wrote: > Hi, > > I added a little release notes for config, and also a note about > removing support for older compilers in the future. If this concerns > you, please give it a quick check and let me know if you want any > changes. This release note is not a promise that future changes will > or won't be made, and it can be changed if appropriate. > > Sorry that this is a bit late. We can still change the release notes > after the beta (and final) release, so don't worry about that. Hello, I can't find a boost websvn instance. How can I see this? Thanks, Steve."
"At 12:33 PM +1000 9/25/01, Fisher; Damien Kaine wrote: >On Mon, 24 Sep 2001, Daryle Walker wrote: > >> on 9/24/01 7:29 PM, Jens Maurer at Jens.Maurer_at_[hidden] wrote: >> >> > Damien Fisher wrote: >> >> >> >> Well...why isn't there an XML parser in boost? >> > >> > Because nobody has written one and offered it for inclusion >> > into boost. Feel free to do so. >> >> I was just thinking about this right before reading this message. I heard >> that XML was supposed to be designed so a CS student could write a parser >> within a week. (I guess this means just enough to check for well-formed >> files, and not validation nor all the whiz-bang stuff like XSL, XPath, >> Schema, XQuery, etc.) >> >> Let me think about this a little more.... > >I disagree. > >Parsing a simple XML document is easy, and your right, a CS student could >do it. > >But, as with all W3C specs, doing the whole thing is a little bit >messier. Maybe a 3rd year CS student's level :). > >The main problem is not that the coding is difficult - it is not. But I >have never come across an XML parser whose interface I was really happy >with. They are all a little messy. > >The other thing is the "extra" stuff production XML parsers really have to >include - XSLT transforms, etc. And these have to be pretty high >performance. > >I have done a lot of work with this stuff and I would be quite interested >in contributing to this if it goes ahead. I would be interested as well. Let's start with a description of the interface that people would like to see. Let's nail that down first. P.S. After saying that, I have to point out that I will be unavailable from now until next Monday. ;-) I'll be happy to participate then."
"On 5/22/2011 10:15 PM, Gottlob Frege wrote: > On Sun, May 22, 2011 at 2:34 PM, Edward Diener<eldiener_at_[hidden]> wrote: >> On 5/18/2011 1:36 AM, Vicente Botet wrote: >>> >>> Edward Diener-3 wrote: >>> >>> Wow, I missed this point. For example, Boost.Thread make use of some >>> traits >>> of this kind. I guess that it should be no too much work to provide the >>> equivalent for free functions; isn't it? >> >> If it can be done it should be a separate library. >> >> My library is Type Traits Introspection, meaning it introspects a type. >> > > I would say a function signature is a type. At least it is once it > exists. You can argue about whether a type_exists<Type>::value trait > makes sense in general. There is already a library, called function_types, for introspecting a function signature."
"From: David Abrahams <david.abrahams_at_[hidden]> > From: "Greg Colvin" <gcolvin_at_[hidden]> > To: <boost_at_[hidden]> > Sent: Saturday, September 01, 2001 1:23 PM > Subject: Re: [boost] shared_xxx issues > > > From: David Abrahams <david.abrahams_at_[hidden]> > > > First Issue: > > > > > > I've just found myself wanting a really flexible smart pointer, along > the > > > lines of the one in Loki by Andrei Alexandrescu. For a long time I > thought > > > that I would rarely want more than shared_ptr, but I can see that this > is > > > going to come up again and again for me. Unfortunately, I couldn't use > > > Andrei's design because very few compilers will apply the empty base > > > optimization in cases of multiple inheritance. So, even if shared_ptr is > our > > > choice for submission to the committee I would really like to see a > > > policy-based smart pointer in boost. > > > > Which policies is it that you want? > > In this particular case, I wanted an embedded reference count, a specialized > allocator, and an embedded size which could be passed to the allocator upon > destruction. Wouldn't Peter's design handle the last two items? > > > Second Issue: > > > > > > I found the following code in shared_array (and I assume the analogous code > > > is in shared_ptr): > > > > > > void reset(T* p=0) > > > { > > > if ( px == p ) return; // fix: self-assignment safe > > > > > > What this does is to make a silent success of resetting a shared_ptr with > > > the pointer it owns. The problem with that is that resetting a shared_ptr to > > > any /other/ pointer which is managed by a shared_ptr is a fatal (and > > > hard-to-detect) error, which happens even to experienced programmers. I > > > don't think the trade-off is a good one. Making this special case (which we > > > can detect) silently work when all other cases will fail without complaint > > > is a mistake. I'd rather see an assert() here. > > > > Of course the problem with an assert() is that it only detects > > this one easy case, a harmless one, and misses the hard and truly > > dangerous cases, and thus might lead to a false sense of security. > > I think you have the right policy, but in the wrong place. That policy > applies well to documented external behavior, like the conditions under > which an exception will be thrown. Assertions should not be documented per > se, since they are just checks for preconditions, and not all preconditions > can be checked. All preconditions, however, should be documented. > > Admittedly, the chances that a shared_ptr will be reset to point at the same > object are slim, but if it /does/ happen, there's a good chance that the > same code could reset it to point at some other object which is already > managed (to see this, ask yourself, "why would a programmer ever > intentionally reset() a smart pointer to the same value?" I can think of > reasons, but it's a bit of a stretch). This is is the only chance we get to > catch a very common source of bugs. Currently, we have a precondition like > this one for reset (is it documented?): "the argument must not point to an > object whose lifetime is managed by another smart pointer...unless it's the > same one that you are calling reset on". I propose to take out the exception > for this one case so that we stand a chance of detecting real bugs. You've almost convinced me. What is bugging me is a desire to stay consistent with auto_ptr: void reset(X* p=0) throw(); Effects: If get() != p then delete get(). Postconditions: *this holds the pointer p. > > It is possible of course to maintain a list or set of pointers > > to all shared objects and assert that p is not in the set of shared > > objects, as my cyclic_ptr experiment did. > > But, as you also said, it doesn't work for multiple-inheritance. I'd forgetten that, but you're right. There is no conforming way to check this precondition. But it would be possible > > As a general rule any use of the raw pointer functions of shared_.* > > should be hidden away from ordinary use behind a create/recreate > > interface. I would be happy to deprecate all these functions > > if suitable replacements could be found. > > What is recreate? If you have a function like shared_ptr<stuff> create_stuff(T arg) { return shared_ptr<stuff> (new stuff(arg)); } then a function like void recreate_stuff(stuff_ptr& p, T arg) { p.reset(new stuff(arg)); } might be more efficient than my_stuff_ptr = create_stuff(arg);"
"Matt Calabrese wrote: > On 4/10/07, Ariane van der Steldt <ariane_at_[hidden]> wrote: > >>I was wondering if there's interest in a smart pointer, which is able to >>cope with circular references. I think it would make a nice addition to >>the smart_ptr classes already in boost. >> >>The code I have aims to solve this problem, by using two types of >>pointers. The execution thread will work with boost::intrusive_ptr >>(which are allocated on the stack) while classes wishing to point to >>other classes, will use a new type of pointer (named 'reference') that I >>designed. This pointer is aware of the owner of the pointer, in addition >>of the object it points to. >> > > > I might be more interested if I more clearly saw your proposed design and > solution. Could you provide a brief code example, even if it is just > pseudo-code, and detail exactly what the user witnesses (I.e. when > destruction occurs, etc.)? As well, what is the "non-standard" > initialization you speak of? Hmm, I admit the "non-standard" initialization is a badly chosen way to describe it. What I meant to say is that the reference constructor requires a parameter, the owner of the reference: if class A contains a reference with name ptr to class B, the constructor of class A needs be thus: A::A() : ptr(*this) { } which creates a variable ptr pointing to null, which knows its parent is *this. Had I stated this constructor: A::A(my_class* other) : ptr(*this, other) { } I would have created a ptr pointing to other. Had ptr been a boost::shared_ptr, this would have been the two constructors: A::A() : ptr() { } A::A(my_class* other) : ptr(other) { } but then, circular references would not be detected. I have some actual code from one of my test cases at the end of my post. Basically, the reference class has been designed to mimic the behaviour of shared_ptr. The referenced class is present to handle reference counters, reachability and provide a virtual destructor for the garbage collector. I'm not really happy that the name differs only one character. The garbage collector is a form of a mark sweep collector, the tri-colour variant to be specific. The basic algorithm is described on wikipedia: http://en.wikipedia.org/wiki/Mark_and_sweep#Basic_algorithm This implementation means that, in a multithreading environment, other threads can still create and destroy references while the garbage collector is running. Here's sample code using the reference system. --- small_loop.cc --- #include "small_loop.h" #include <string> #include <boost/test/unit_test.hpp> #include <reference/reference.h> namespace small_loop { int test_class_count = 0; class test_class : public reference::referenced { public: const std::string id; reference::reference<test_class> next; test_class(std::string id) : id(id), /* construct reference owned by *this */ next(*this) { ++test_class_count; return; } test_class(std::string id, const test_class& rhs) : id(id), /* construct reference owned by *this */ next(*this) { ++test_class_count; /* assignment */ next = rhs.next; return; } ~test_class() throw () { --test_class_count; return; } }; void test() { /* Construction of reachable test_class. */ boost::intrusive_ptr<test_class> test0 = new test_class("#00"); { /* Construction of reachable test_class. */ boost::intrusive_ptr<test_class> test1 = new test_class("#01"); /* Construction of reachable test_class. */ boost::intrusive_ptr<test_class> test2 = new test_class("#02"); BOOST_CHECK_EQUAL(test_class_count, 3); /* test_class->next is a pointer to test_class. * The following lines assign the next pointers * to form a circular list. */ test0->next = test1; test1->next = test2; test2->next = test1; /* test1 and test2 go out of scope, triggering * the garbage collector, since they contain a * circular reference. * However, the garbage collector will not erase * any of these 3 instances, since they are * reachable from test0. * * The garbage collector is called twice, * first when test2 goes out of scope and the * second time when test1 goes out of scope. */ } BOOST_CHECK_EQUAL(test_class_count, 3); /* The next statement runs the garbage collector, * which will actually remove all 3 created test * instances, since the last pointer to it has * gone out of scope. * If the line 'test2->next = test1' had not been * present, the delete operator would have been * called, instead of the garbage collector, * since there would not be any circular references * present. */ test0 = 0; BOOST_CHECK_EQUAL(test_class_count, 0); return; } } --- end of small_loop.cc ---"
"AMDG On 04/13/2013 09:10 AM, Christian Henning wrote: > > <snip> > > I'm not sure what that all means but don't you think the shell parameter > should be True? > I don't think so. When shell is True, the command is supposed to be a single string. In Christ, Steven Watanabe"
"On 28/09/10 11:49, Stewart, Robert wrote: > Francisco José Tapia wrote: >> >> Is there any interest in a library implementing counter trees, >> which permit us to access to the elements by the position, as >> in the same way than a vector. The insertion, deletion and >> access to elements are operations O(log N). > > How does this differ from Boost.MultiIndex which can provide > random access plus ordered, key-based indices in a single > container? AFAIK, in that case Boost.MultiIndex stores the data and an index separately as two distinct structures. Counter trees provide both features in the same data structure; which might be a good idea or not."
"On Thu, Mar 2, 2017 at 9:22 AM, Raffi Enficiaud via Boost < boost_at_[hidden]> wrote: > Le 02/03/2017 Ã 16:20, Rene Rivera via Boost a Ã©crit : > >> On Wed, Mar 1, 2017 at 5:23 PM, Raffi Enficiaud via Boost < >> boost_at_[hidden]> wrote: >> >> Hi all, >>> >>> On develop, I have the following error for gcc/linux and clang/osx: >>> >>> 01-Mar-2017 23:58:05 libs/python/build/Jamfile:155: in lib_boost_numpy >>> 01-Mar-2017 23:58:05 *** argument error >>> 01-Mar-2017 23:58:05 * rule lib ( names + : sources * : requirements * >>> : default-build * : usage-requirements * ) >>> 01-Mar-2017 23:58:05 * called with: ( : numpy/dtype.cpp >>> numpy/matrix.cpp >>> >> >> >> How are you configuring python in your user-config.jam? >> > > I am not touching anything about user-config.jam: the failure happens on a > build machine (specific build user, supposedly clean). If there is a > user-config.jam, then I do not know how it landed there :) OK.. Which means that the version number for whatever python it picks up is undetermined and blank. I'll have to figure out why that is."
"Don G wrote: > >>- User is not required to reference streams by >>pointer, streams are stack allocated or are simply >>members of another object. Internally they have a >>smart pointer to an implementaion handle. Consider >>them stack-based proxies. The acceptor and the >>connector return the handle that is asigned to the >>stream. > > > So is this choice just for user simplification? Internally, the user > is still holding a pointer, right? What are the copy semantics of the > objects held by the user? This is where things can be tricky any way > you go. Either the object is copyable and confusion can come via > aliasing, or they aren't which is probably better in this case, but > could possibly cause some idioms to not work (like "stream s = > my_clever_stream_creator()"). My preference was to use shared_ptr<> > as the semantics are well understood and objects can layer easily in > obvious ways, but the cost is "->" vs "." syntax. > Yes it holds a pointer, a shared_ptr actually, this makes it possible for some part of the library to temporarily hold a (potentially weak) reference to the handle without fear that it might be destroyed/closed. I think this will come handy with asynchronous I/O. [1] I think that stack semantics are much more intuitive for non polymorphic objects (i.e. iostreams versus streambuffers). Your example could be rewritten as 'my_clever_stream_creator(s)' without really losing expressivity in the non-polymorphic case. This is exactly how connectors and acceptors work in my library. Currently the wrapper is copyable, but i will probably correct this unless i find very good reasons not to (the only one i can find currently is two threads wanting to do parallel i/o on the same file: the stream classes are not thread safe, so each thread might want to have a copy). 1: Note that the internal file descriptor is closed when and only when the owner handle is closed. There is no close() call although shutdown() is available. Thus there is no risk that the operating system might reuse the same file descriptor number while there are stale FDs around. Usefull if you need a 'FD->handle' map. > >>- The preferred way to do input output is to use >>standard-like algorithms (i.e. copy) with buffered >>stream adaptors and specialized input/output >>iterators. I believe that an efficient library can >>be written this way and be very C++-user-friendly. >>Classic read/write are still available, but their >>semantics might be surprising. > > > I agree that this is the right approach for many users and protocols, > but most network programmers (including myself<g>) need access to the > primitive behaviors. They won't find them surprising unless the > wrapping violates expectations coming from sockets-like programming. > They are available, in fact they are necessary to implement the rest of the library ;-), but they do not try to be user-friendly: they have many parameters, complex return values, non trivial preconditions and postconditions. For example there is no guarantee that a write always writes the whole buffer in absence of errors, it might do a partial write for no reason at all (obviously minimizing the number of calls is a quality of implementation issue). > >>- All classes are concrete, no polymorphism is used >>(i.e. no virtuals). Polimorphic behaviour must >>currently be achieved with some external mean (i.e >>using the external polymorphism pattern. I think >>that the boost::IDL library would be great). > > > Here is where we are at different ends of the spectrum :). I didn't > see any SSL code, so I can only imagine how the http code would > handle SSL vs. non-SSL stream underneath. Ideally, this should not > require two template instantiations like http<stream> and > http<ssl_stream>, for example. > > In the end, I thought templates had little to offer at this level. > Parameterizing protocols by stream type seems (IMHO) to buy nothing > in particular except the removal of virtual at the expense of the > user having to specify <kind_of_stream> and _lots_ of extra code > generation. The app should be able to layer objects as it sees fit > and run-time polymorphism is (again, IMHO) the right solution to that > problem. > I did start with virtual interfaces based design (Part of it still visible, for example the address object is way too much complex for my current needs, also the domain object is a relic of a factory based structure). It took me a long time to find on a general stream interface that was at least partially statisfying. When i started implementing the concrete objects i've found that many methods looked almost the same, so i refactored the code and put the common code in an implementation class. Then I thought that the library user could find usefull to deal with the actual stream type, and promoted the implementation class as a public object, with a virtual interface adapter optionally applicable (i.e. the external polymorphism pattern, or type erasure). Even the virtual adapter could be generated with the use of templates. I was happy with this design untill I realized that I was just duplicating what could be better done with a dynamic_any or with boost::IDL, and i scraped it. Only the concrete objects were left and i have yet to find the need to put the interfaces back. Dynamic polymorphism can certanly increase flexibility without template bloat, but there would be really that much code generated? An http<tcp_stream> and an http<ssl_stream> certanly can share 99% of the code, what you really need is a parametrized function that fetches the data from the stream and put it in a buffer. Keep most of the code in a base class, or better, put the parametrized function (or functor) in a boost::function and store it to the non-templated http protocol object. Easy. I didn't remove virtuals just for the sake of it, but it is just an accident of design. I might consider putting them back in the internal handle, at least to give read/writes polymoprhic behaviour (this would mimic the iostream and streambuffer pair). BTW, i do not exactly understand what do you exactly mean with 'beeing free to layer objects'. >>- Errors can be reported both with exceptions and >>with error codes. Exceptions are used by default >>unless error callbacks are passed. This seems to >>work quite well. Internally only error codes are >>used and exceptions are thrown only at the most >>external abstracion layer. > > > This is a good idea, and very similar to what I have done as well. At > least for async. What is the behavior of blocking read in the face of > error? Is the user callback made inside read? If so, what does read() > return? An error is thrown, unless a callback is provided. If so the error code is passed to the callback. A throwing read returns the amount of data read, a 'callback augmented' read returns the callback itself (callbacks are passed by value as with standard algorithms). The amount of data read is passed to the callback along with the error code. > >>I will probably add status bits a-la iostreams. > > > What kind of bits? I can see eof and fail and those cannot be > cleared. Others? > Currently the only bits that i plan to have are: 'input buffer grown' and 'output buffer flushed' usefull for asynchronous i/o and buffered streams. I actually do not have (yet) eof and fail because initially the stream was supposed to be thread safe and it had to be stateless. I I will certanly add state to keep track of closed connections and obviously it will only be resetted if the internal handle is reinitialized. >>- File streams. The library actually try to be >>a generalized i/o framework, and file streams are >>provided for completeness. > > > At an abstract level, they are very similar and should behave in a > similar way. I haven't tried to tackle that part because it is an > area where there is already something in place, albeit not async, and > I didn't want to try to integrate into iostream (not my cup of tea). > I think that file I/O is as important in network programming as network I/O itself, so it is usefull to have an unified framework. BTW, polling for I/O readiness (i.e. the select model) does not make sense with files, i believe that the asynchronous I/O model is the only non blocking io model that fits all stream types. >>- The library can be extended simply by creating >>new handles. In addition to TCP streams there are >>Unix streams (come almost for free :-) and file >>streams. SSL/TLS was present but did get broken >>some time ago and didn't have the time to fix it. > > > I would be most curious to know how SSL fit in your library and how > other layers interact with or are shielded from it. > Nothing very complex, really. I did write a thin wrapper over OpenSSL. I only did take advantage of the ability to initalize a context with an already connected file descriptor, then wrapped the context along in an handle. The read/write methods simply forwarded the call to SSL_read/SSL_write. I didn't really take advantage of the BIO infrasturcture, that will probably be necessary to make an ssl_stream an adapter over any kind of stream. > >>- Input/Output buffer. > > [some good stuff was here<g>] > >>From the little I've read through the code, it looks like this is a > layer above the raw stream impl. I think that is exactly the right > way to go. :) > Yes, the buffered stream is just a layer above the standard stream. Also it should be very easy to implement a streambuffer on top of the buffered stream adaptor. I think that the buffered adaptor will greatly simplify the asynchronous buffer management: asynchronous reads put data in the internal input buffer that can be grown efficiently as much as needed (it is a deque); user code copies data from this buffer to its own buffer, or takes ownership of it. Asynchronous writes take data from the output buffer; user code copies data form therir internal buffers to this buffer, or relinquish ownership of their buffer or, if they want to keep ownership of the buffer and still avoid the extra copy, the must use a special buffer that is guaranteed to be immutable (i.e. once created it can never be changed, copies share the internal data using shared_ptrs. I do not have it yet, will add it when i'll attack the asynchronous io problem). If the user does not want to have automatic buffer management, it can still use the unbuffered functions, but then it is his job to garantee that buffers stay valid and unchanged untill the operation is completed (i.e. a mess!!). > >>Missing (definitelly not complete list): >> >>The library is fully sinchronous for now. I'm >>still considering how to add asynch support. I >>think i will implement it in the buffered adaptor >>I/O is done asynchronously to the internal >>buffers that can grow as much as it is necessary. >>Timeouts are definitelly a must-have. > > > Agreed on async and timeout. Can sync calls be manually/explicitly > canceled? In my experience (and opinion<g>), a reader/writer MT > design needs cancel semantics. Without it, such an app cannot be > responsive to outside stimuli. > No, not yet, still on my todo list. Well, you can obviously cancel a pending operation by shutting down the stream, but a much more gentle solution is needed :-). > >>Final notes: >> >>I've have seen that the current consens is to >>encode the the stream type in the address, so >>to allow a dynamic behaviour: the actual >>transport is selected only at runtime, based >>on the address string. I think this is a bad >>decision (i considered doing it while >>implementing my library) and this is why: > > > I am more and more convinced that this is not the right approach for > the library core, but from different reasons (see other posts). It > could be offered as a stand-alone library for an app that has the > need for this, but I think it is most likely a trivial map problem > (plus a little text manipulation). > Yes, as an add-on would be fine, but the transport-encoded address should not be a central concept. >>- C++ is a static language, let's leave these >>niceties to more dynamic languages. > > > I think C++ is quite dynamic (not in the java script way<g>) and > should exercise that power where appropriate :) It pains me to see > Java servers everywhere. C++ can and should have all the HTTP, SSL > and server stuff and be as easy to develop servlet-like things. One > does not need reflection, dynamic loading whatnot to play well in > that space. One does need standard (or at least defacto) libraries. > Without them, effort is fragmented and disjoint. > > Which is why I joined boost. :) > Well with static i meant :"do as much work at compile time as possible" which translates to "catch as many errors as early as possible" ;-). C++ is certanly dynamic, but i kind-of-like the way everything is NOT always an object. [Really off-topic] BTW, I would *love* complete, standard, compile-time reflection facilities. > > [...] > > >>- It is extremely insecure. In a network library >>security must be paramount. If the transport type >>were encoded in the address, it would be much >>harder to validate externally received addresses. > > > Good point. Validation is one thing, but meeting expectations of the > software is another. In some cases, just any transport may not be > appropriate and hence should be validated. This can be done from the > string form, of course, but it presents a wider interface. > Just to give an example: Stevens in Unix Network Programming Vol 1 shows an example of getaddrinfo that, as an extension, could return unix domain sockets in addition to ipv4 and ipv6 sockets. Glibc did actually implement the extension. It was removed later because of security concerns: see this post for details. http://sources.redhat.com/ml/libc-hacker/2001-05/msg00044.html You might want to treat streams polymophically once created, but at creation the type should be statically known by the user code, because it needs to be aware that not all streams have the same semantics. You might say that not all streams are 'created' equals :-). > > [...] > > >>Sorry for the long post, just tryin' to be usefull :-). > > > Don't be sorry. I am sure I've written longer posts and it was > helpful. > Well, this *certanly* was a long post. I hope i've cleraed some details of my library. Now, let's get back to code."
"On Friday 06 September 2002 11:18 am, David Bergman wrote: > I definitely vote for having the lexicographic ordering being the > default one, for all us STLish developers. It should be noted, and > understood, that the purpose of that ordering is to enforce a total > ordering for STL and similar purposes, and is in no way a > domain-specific statement about intervals for arithmetics. > > If developers want domain-relevant relations, he/she should define them > (or Boost.IntervalArithmetic could provide some useful ones, as given by > Joel's disection) How do developers get those domain-relevant relations used if there is already a default set of relations? I understand the reasoning against the std::less specialization, but I still wonder if it is the right way to go in this case. The std::less specialization based on the lexicographical ordering gives the 'STLish developers' the ability to stick intervals into maps & sets, but leaves the door open for other semantics to be used for the actual relational operators. Doug"
"> I anticipated that this would be a problem and already provided some > remedy (I won't delve on it), but did not push the reasoning far enough. > The next step, I think, is to try to get back to functions, as you > suggest, but free functions, not member functions. I already proposed a > > Consequently, using the first form, the use of operator% would appear, > only for additional options: > > ( push_front<1>( cont ) % ( _data = f ) % ( _repeat = n ) )( 1, 10, 100, > 1000 ); > I still hadn't pushed the reasoning far enough but another participant completed it : push_front<1>( cont, _data = f, _repeat = n )( 1, 10, 100, 1000 ); Although it appears in another message, I wanted to make sure it wasn't missed."
"On 9 October 2013 16:18, Nevin Liber <nevin_at_[hidden]> wrote: > On 9 October 2013 01:31, Thorsten Ottosen <thorsten.ottosen_at_[hidden]>wrote: > > You seem to be completely obsessed by the point that a precondition or >> invariant violation must always be checked by compiled-away assertions. >> > > You seem completely obsessed to call it a precondition or invariant > violation. Why? All you have to do is make it defined behavior in your > library; then it isn't a bug and apparently everyone will be happy. Sigh, that's what I've been suggesting from the start. http://lists.boost.org/Archives/boost/2013/10/206790.php"
"AMDG Sid Sacek wrote: > What do you mean, you see spam. > > Every time I look at the links posted for spam, I don't see any spam. What am I not seeing that you see? > I'd guess that someone has dealt with it. In Christ, Steven Watanabe"
"At 08:43 AM 5/12/2001, Daryle Walker wrote: >I'm not sure this counts as an example, but I'm curious about what >bit_string is like. I have an (inactive) project for an >arbitrary-precision >integer type for Boost. It strings together many bits for the value. I've >had two choices for the bit container: > >1. vector<bool> since it stores the bits compactly >2. deque<bool> to allow inserts from either end (for shifts) > >If bit_string could provide compact representation with efficient pushing >(and popping) from either end, it would be great! See below for the interface. Please don't criticize this interface in light of modern STL practice - it was designed before there was an STL. --Beman ----------- The header <bitstring> defines a class and several function signatures for representing and manipulating varying-length sequences of bits. class bit_string { public: bit_string(); bit_string(unsigned long val, size_t n); bit_string(const bit_string& str, size_t pos = 0, size_t n = NPOS); bit_string(const string& str, size_t pos = 0, size_t n = NPOS); bit_string& operator+=(const bit_string& rhs); bit_string& operator&=(const bit_string& rhs); bit_string& operator|=(const bit_string& rhs); bit_string& operator^=(const bit_string& rhs); bit_string& operator<<=(size_t pos); bit_string& operator>>=(size_t pos); bit_string& append(const bit_string& str, pos = 0, n = NPOS); bit_string& assign(const bit_string& str, pos = 0, n = NPOS); bit_string& insert(size_t pos1, const bit_string& str, size_t pos2 = 0, size_t n = NPOS); bit_string& remove(size_t pos = 0, size_t n = NPOS); bit_string& replace(size_t pos1, size_t n1, const bit_string& str, size_t pos2 = 0, size_t n2 = NPOS); bit_string& set(); bit_string& set(size_t pos, bool val = 1); bit_string& reset(); bit_string& reset(size_t pos); bit_string& toggle(); bit_string& toggle(size_t pos); string to_string() const; size_t count() const; size_t length() const; size_t resize(size_t n, bool val = 0); size_t trim(); size_t find(bool val, size_t pos = 0, size_t n = NPOS) const; size_t rfind(bool val, size_t pos = 0, size_t n = NPOS) const; bit_string substr(size_t pos, size_t n = NPOS) const; bool operator==(const bit_string& rhs) const; bool operator!=(const bit_string& rhs) const; bool test(size_t pos) const; bool any() const; bool none() const; bit_string operator<<(size_t pos) const; bit_string operator>>(size_t pos) const; bit_string operator~() const; private: // char* ptr; exposition only // size_t len; exposition only }; 2 The class bit_string describes an object that can store a sequence consisting of a varying number of bits. Such a sequence is also called a bit string (or simply a string if the type of the elements is clear from context). Storage for the string is allocated and freed as necessary by the member functions of class bit_string. 3 Each bit represents either the value zero (reset) or one (set). To toggle a bit is to change the value zero to one, or the value one to zero. Each bit has a non-negative position pos. When converting between an object of class bit_string of length len and a value of some integral type, bit position pos corresponds to the bit value 1 << (len - pos - 1).2) The integral value corresponding to two or more _________________________ 2) Note that bit position zero is the most-significant bit for an ob bits is the sum of their bit values. 4 For the sake of exposition, the maintained data is presented here as: --char* ptr, points to the sequence of bits, stored one bit per element;3) --size_t len, the length of the bit sequence. 5 The functions described in this subclause can report three kinds of errors, each associated with a distinct exception: --an invalid-argument error is associated with exceptions of type invalid_argument; --a length error is associated with exceptions of type length_error; --an out-of-range error is associated with exceptions of type out_of_range. ------ end ------"
"On Thu, Nov 20, 2008 at 10:49 AM, vicente.botet <vicente.botet_at_[hidden]> wrote: > Hi, > > is there an interest in a N2346 - Defaulted and Deleted Functions emulation http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2346.htm > > The idea been to use some macros that will use the =default, =delete if the compiler provides it and replace this macros by whatever has the same semantics. Alexandrescu introduced already two macros NON_ALIAS and NON_HEAP_ALLOCATED when talking about strict locks. > > Attached a draft for the default and deleted functions. > > Only one remark the macors must be used on the public part and without trailing ';', e.g. > > class X { > BOOST_NEW_DELETE(X) My concern is that: #define BOOST_DEFAULT_CONSTRUCTOR_DEFAULT(T) inline T(){}; emulates the syntax but not the semantics of #define BOOST_DEFAULT_CONSTRUCTOR_DEFAULT(T) T()=default; The point of using the C++0x T()=default syntax is probably to ensure that the class is a POD. In C++03, the class designer has to make a design tradeoff. If providing a default constructor is more important than making the class a POD, then your emulation is OK. But if the priorities are the other way around, then the macro should just eliminate the default constructor. I'm concerned about hiding that semantic difference inside a macro. --Beman"
"Marshall Clow wrote: > [ 347 open tickets today, 353 yesterday - Moving downward! ] But not all of these are bugs. Some are feature requests. Either the subject of this email is wrong, or else we should exclude feature requests from this list. I lean toward the latter because reaching 0 feature requests isn't a very meaningful goal, but reaching 0 bugs is."
"Hi, Andreas Huber-3 wrote: > > According to the schedule, John Torjo's Log2 library will be reviewed soon > (currently 3rd in the queue). There's another logging proposal by Andrey > Semashev (currently 13th in the queue). > > It seems to me that these proposals are sufficiently close in > functionality > that only one of them should be accepted into Boost. > > Therefore, wouldn't it make sense to review both libraries in one (longer) > formal review? > > Regards, > > -- > Andreas Huber > > When replying by private email, please remove the words spam and trap > from the address shown in the header. > > > _______________________________________________ > Unsubscribe & other changes: > http://lists.boost.org/mailman/listinfo.cgi/boost > > AFAIK, even if we have a review manager for the review of the John Torjo's library, the library has not been changed since it was rejected. I have never understood why it is on the review schedule. Anyway, I think that we should review a library as soon as the review manager and the author have found a date. Of course compare other libraries covering the same domain are welcome at the functional and performance level. Best, Vicente"
"> I think that 'alignment' should be checked: > BOOST_ASSERT( alignment & (alignment - 1 ) == 0 ); I'm positive you meant BOOST_ASSERT((alignment & (alignment - 1)) == 0); instead :-) Updated the documentation and examples accordingly. Glen"
"troy d. straszheim wrote: > Please try to keep your application up to date with mailing list archive > links (via gmane or whatever) to the heads of threads about your > proposals. Just add something like a "links to discussion" section at > the bottom. This will really help us. > > If no discussion has taken place here about your proposals, if you > update your proposal with a link to this message, you'll still get > points for having seen this message at all... :) Too bad I read this too late. :'("
"Should not axiom2 be a Corollary of axiom1... Even though life is indeed dangerous, and quite chaotic, in many aspects, we can here (in the world of formalization) enjoy the luxury of defining the rules ourselves. So, why should we strive to copy that unpredictability? I.e., it is not certain that the Laws of Life, or postulates of life's conditions, are applicable to formal languages. The "inevitable danger" will most likely arise in the dynamics of program execution anyhow, without us adding to that in the "static" rules of languages and libraries. I definitely believe that keeping the "inherent" danger of our constructs at a low level is a positive factor. The Users (i.e., programmers) can always experience the Danger of Life by clever pointer arithmetic, if they start to conceive the formal world of programming to dull; no need for us to help there... /David -----Original Message----- From: boost-bounces_at_[hidden] [mailto:boost-bounces_at_[hidden]] On Behalf Of Victor A. Wagner, Jr. Sent: Tuesday, August 06, 2002 5:09 AM To: boost_at_[hidden] Subject: Re: [boost] Re: Re: Re: Platform Neutrality-withoutreinterpret_cast<>andifdef Geez, I hate to have to chime in on Eric's side (since I disagree with some of what he says), but it _should_ be the "stated" or "posted" will of the community. I found the arguments ("they're not safe") for deleting semaphore so specious that I gave up on attempting any further criticism. Ben Franklin said (in respect to human interaction)"They that can give up essential liberty to obtain a little temporary safety deserve neither liberty nor safety." I believe the same applies here. Refusing to implement some method of being able to pass an exception (ok, maybe not ALL exceptions, I personally find the concept of "throw 7;" to be an abomination of the body of C++) across thread boundaries because it's not "safe' disappointing. axiom1: there is no such thing as "absolute safety". axiom2: attempting to reach "absolute safety" is like searching for the "end of the rainbow" axiom3: doing the same thing repeatedly and expecting different results (e.g. "we have achieved absolute safety") is insanity. axiom4: many things are inherently dangerous I'm suggesting that we quit using "it might not be safe if misused" as a mantra. It's a consideration, that's all. "Gee, this might be unsafe if I misuse it...I'd better be careful." We're not children here. We handle dangerous things every day (knives, driving, etc). The language cannot protect against a lot of things that will cause the program to blow up, why are we so worried about this one? as the guy in the next office said...waaaay back when: "If you make a system that even a fool can use, only a fool will use it." Dennis J. Maine At Monday 2002/08/05 14:50, you wrote: >Final warning, Eric: tone down the rhetoric or we will ban you from the >list. > >If any design philosophies are being ignored here (which I seriously >doubt), it's certainly not "brutal". >I'd say if anything you're ignoring what Bill said about the fact that the >current implementation is based on the will of the community. > >-Dave (still trying to be on vacation and getting seriously annoyed) > >----------------------------------------------------------- > David Abrahams * Boost Consulting >dave_at_[hidden] * http://www.boost-consulting.com > > >----- Original Message ----- >From: "Eric Woodruff" <Eric.Woodruff_at_[hidden]> >To: <boost_at_[hidden]> >Sent: Monday, August 05, 2002 5:09 PM >Subject: [boost] Re: Re: Re: Platform >Neutrality-withoutreinterpret_cast<>andifdef > > >Please explain how boost users are supposed to maintain a level of >confidence in the safety of this foundation that is aimed at addressing the >impotence of C++ itself, by providing things that were left out of the >standard, when the communities own design philosophies are brutally ignored >by its own members. > >Boost doesn't stand to make any profit, so then why doesn't it stand on >it's principles above the alternatives? It seems that upon examination, >boost is going the way of all other open projects that exist. This is >leading me to believe that inspecting of OpenSceneGraph, which also >provides an image of holding high-standards, will prove the same. > ----- Original Message ----- > From: William E. Kempf > Newsgroups: gmane.comp.lib.boost.devel > Sent: Monday, 2002:August:05 4:40 PM > Subject: Re: Re: Re: Platform >Neutrality -withoutreinterpret_cast<>andifdef > > > ----- Original Message ----- > From: "Eric Woodruff" <Eric.Woodruff_at_[hidden]> > To: <boost_at_[hidden]> > Sent: Monday, August 05, 2002 3:07 PM > Subject: [boost] Re: Re: Platform Neutrality - > withoutreinterpret_cast<>andifdef > > > > I can understand the hit taken in the readability of the mutex > > implementation for "efficiency," but it is unacceptable for thread. >I've > > read boost's biases and the thread implementation is a certain >violation > of > > the heart of boost's principles. > > Eric, I think you're getting confrontational. Boost went through formal > review and no one had the objections to the *implementation* that you do. > More over, Boost.Threads is hardly the only Boost library that uses > conditional compilation in this manner. If you're going to accuse me of > violating the heart of Boost's principles you'd better back it up with > citations. > > Truth be told, a pre-review version of the library used the PIMPL idiom >for > the reasons you cited, and it received numerous complaints for having >done > so. The current usage of conditional compilation is a result of the >Boost > membership requesting this. > > Bill Kempf > _______________________________________________ > Unsubscribe & other changes: >http://lists.boost.org/mailman/listinfo.cgi/boost > > > >_______________________________________________ >Unsubscribe & other changes: http://lists.boost.org/mailman/listinfo.cgi/boost Victor A. Wagner Jr. http://rudbek.com PGP RSA fingerprint = 4D20 EBF6 0101 B069 3817 8DBF C846 E47A PGP D-H fingerprint = 98BC 65E3 1A19 43EC 3908 65B9 F755 E6F4 63BB 9D93 The five most dangerous words in the English language: "There oughta be a law" _______________________________________________ Unsubscribe & other changes: http://lists.boost.org/mailman/listinfo.cgi/boost"
"I noticed in serializations basic_iarchive that when you're not building for debug the next line here (317 in basic_iarchive.cpp) has a warning for unused variable new_cid. The BOOST_ASSERT is instantiated as ((void)0) so new_cid really isn't used. Could the register_type call be moved into the assert? class_id_type new_cid = register_type(bpis_ptr->get_basic_serializer()); int i = cid; cobject_id_vector[i].bpis_ptr = bpis_ptr; BOOST_ASSERT(new_cid == cid); Something like: BOOST_ASSERT(register_type(bpis_ptr->get_basic_serializer()) == cid); Then the new_cid variable wouldn't be needed and the call to register_type would disappear with the BOOST_ASSERT if you aren't building for debug. Or, does the call to register_type have an important side effect that is required? Patrick"
"On 03/01/2010 05:42 PM, Daniel Larimer wrote: > > On Mar 1, 2010, at 9:22 AM, Rutger ter Borg wrote: > >> Daniel Larimer wrote: >> >> [snip] >>> It is one thing to dump data into a file, it is quite another to >>> pull it out and do something useful with it. >> >> Yes, but that's not logging, is it? :-) > > I guess my point is that "unreadable" binary logs are just as good as > "no binary logs". If you make the job of logging easier, but do > nothing on the replay (post processing) side then you really have not > saved many users anything considering that the infrastructure > (source/sink/filters) is practically the same. By the time I write a > "generic replay service", I would be one small step away from a > "generic logging service". The end result is that the output of > Boost.Log is most suitable for human analysis without an eye toward > making machine analysis easier. Well, since the library provides no binary logging sink out of box, it does not provide a tool to read them. And it doesn't provide a binary sink because its quite difficult to develop one to be generic. I'm not saying there won't be one in the future, it's just not at the top of the list. That said, nothing prevents you to write one for your needs. I believe the tools the library provides will help to do this in less time than that would require to build it from the ground. You get the whole library infrastructure as it is, all you need is to define the way to store log records. Regarding the replay feature, I really don't quite understand what exactly this is. Is it a tool to read binary logs or something more?"
"Hi, I've made this pull request: https://github.com/boostorg/iterator/pull/4 which makes operators defined for iterator_facade conditionally defined depending on the iterator category. As a side effect this change fixes Boost.Graph tests broken by the recent change to boost::next()/prior() [1]. Could someone take a look and merge it? [1] http://lists.boost.org/Archives/boost/2014/06/214788.php"
"> Hello. I'm russian student. My department is Applied Math. I need to make > my magister work and I would like to relate it with Boost.Math > development. I think this work could be something like implementation of > tasks mentioned in TODO-list. New feature development may take a long > time. In the best case, I would be glad to take job and reviewer for it. > If anyone has an idea - I'm ready to take serious and big job for 1,5 > years. Thanks. I'm still trying to catch up with my extensive list of TODOs from summer and Boost. At any rate, ... In addition to John's detailed responses... I've got a few ideas for Boost.Math that might be acceptable for the scope of your project. I would be interested in looking into new functions such as those related to the Lerch transcendental (Zeta, Hurwitz Zeta, Polygamma for wider argument range, etc.). In addition, there are still numerous extensions to multiprecision in association with Boost.Math that could be investigated, optimized, better tested, etc., etc., etc... But first up, may I ask a few questions? * Has your project of concept been approved? * Do you need such approval? * Do you have a magister (thesis) adviser? * What degree are you pursuing with this thesis? * When would you like to begin, if this is feasible? Sincerely, Chris. On Wednesday, October 30, 2013 2:51 AM, Bikineev <ant.bikineev_at_[hidden]> wrote: Hello. I'm russian student. My department is Applied Math. I need to make my magister work and I would like to relate it with Boost.Math development. I think this work could be something like implementation of tasks mentioned in TODO-list. New feature development may take a long time. In the best case, I would be glad to take job and reviewer for it. If anyone has an idea - I'm ready to take serious and big job for 1,5 years. Thanks. _______________________________________________ Unsubscribe & other changes: http://lists.boost.org/mailman/listinfo.cgi/boost"
"In-Reply-To: <B59D39CC-3457-11D6-8200-003065D18932_at_[hidden]> On Sun, 10 Mar 2002 13:50:36 -0500 Howard Hinnant (hinnant_at_[hidden]) wrote: > Note that the base class got destructed first. During the period that > Derived was busy relocating its members, it was operating with a > destructed Base. This isn't quite right. Although the source Base is destructed, the destination Base has now been constructed. And it is the destination Derived which is busy relocating the members. It need not and should not invoke code of the source Derived. It can talk to its own Base, if it wishes. > In a nutshell, I find changing the order of destruction of base classes > too scary. Therefore I believe that Derived will have to ask Base to > move construct itself, leaving behind a valid Base that Derived can > communicate with during its own destruction, after which ~Base() would > run. I sympathise. However, although during a move the source Base is valid, it is crippled by the lack of resources. I think asking it to do stuff in its crippled state is almost as scary. -- Dave Harris"
"On 14/11/2013 09:17, Quoth Antony Polukhin: > * we loose the meaning of name() as a "fast short nonreadable name" and get > something indeterminated instead Where is that meaning assigned? I don't believe the standard specifies what form the return value will take, just that it's some unique string literal."
"David Abrahams wrote: >>> If possible, at this late stage, the names should be changed. >> >> <another universe mode> >> Of course, since boost.filesystem is used by exactly zero real-world >> projects right now (because nobody was able to grok the meaning of 'leaf'), >> it's OK to change the names to more sane ones. >> </another universe mode> >> >> <this universe mode> >> Given that boost.filesystem appears to be highly popular, and apparently >> users don't care about conceptual clarify of 'leaf', changing those names >> will basically cause everybody to change, or conditionally change, their >> code, without any practical benefit. >> </this universe mode> > > It's easy enough to leave them deprecated, or even officially removed, > but available for backward-compatibility. Did you read all the messages in this thread? If you want to rename 'leaf' to 'basename', you cannot do that without breaking backward compatibility (no matter if you leave 'leaf' around as deprecated). - Volodya"
"Andrey Semashev wrote: >> 1) Why does mplcore exist? Why is its content not in core? > > Because it has a distinct set of functionality which may not be needed > by a Core user. Pick any two things in core. One of them might be needed by some user of it while the other is not. > Merging MPL.Core with Core would make Core heavier and > add more dependencies to it, which contradicts its incentive. ... or it could consume those dependencies (or at least be in the same repo and the same modularized release tarball) and really be core. >> 4) Why is static_assert not part of core? What is the value of it being >> seprate? > > Frankly, I would merge it with Assert or Config, although I did not > analyze reports to see the consequences. In any case, it's a leaf > library, so it doesn't add much. What do you think the term 'leaf' means? What the separation 'adds' is extra/different/separate things you need to have/get before you can use a higher-level library. > >> 5) What if core actually contained 'core stuff'? What if core contained >> 'toolchain normalization' (such as static_assert emulation, a >> BOOST_STATIC_CONSTANT macro, etc) and facilities essential (ie, core) to >> the rest of boost? > > The problem is that the set of "essential facilities" differ from one > Boost library to another. Some only needs Config, other need stuff > from Core and Preprocessor, third require MPL, TypeTraits and Utility. True... > The solution is to make multiple such fundamental libs, each > implementing its part of common functionality and having minimal > dependencies. Leading to the apparent 'ideal' of one class per library. An alternative solution would be to group the (small amount of) fundamental stuff together in one repo/library. That's at least what QtCore does, for example. It doesn't matter if two classes within it are technically unrelated. The suggestion is providing a one-stop-shop (download tarball or repo) for the core stuff which between 60 and 88 of the libraries in boost use, because it is 'core'. Then the challenge is balance between keeping it small enough and keeping it relevant enough (by actually having core stuff in it). >> 6) What if core was bigger? What if using boost library Foo only required >> me to download/install boost core and a *small* handful of other >> *independent* (not interdependent, as most of boost is now) dependencies >> in order to use it? This trend of creating tens of tiny 1/2/3 file >> "libraries" and "sublibs" runs/sprints against that kind of scenario. > > This would be a step towards monolithic Boost. No, not really. It would be analysis of what the core stuff is, and then grouping that core stuff together. A dependency on Boost.Core should not be a problem and should provide core stuff. Boost.Core should be designed so that that is true. [Aside: current boost is not much less monolithic than it was in svn. It's released/downloadable monolithically] > What if my library only > needs BOOST_ASSERT? Do I have to pull half of MPL and TypeTraits along > in this "bigger core"? Yes. You as a developer would install boost-core.git or boost-core.tar.gz and then you would develop mylib, whatever it is. A user could download/install boost-core.tar.gz and mylib.tar.gz instead of boost-mplcore.tar.gz, boost-static_assert.tar.gz and boost-assert.tar.gz before getting to mylib.tar.gz. Very little depends on only one of these 'low level' libraries. > As I see it, the problem with the current state is not the amount of > core libraries but the unnecessary transitive dependencies they > impose. It's not a problem to download Core and MPL.Core separately, > as long as these libs don't require much themselves (like Utility or > TypeTraits, for example). Similarly, if they don't require much themselves (and if most dependers use both of them), it's not a problem to combine them. Thanks, Steve."
"Pierre T. wrote > Hello, > > I put my proposal on google-melange: > > https://google-melange.appspot.com/gsoc/proposal/review/google/gsoc2013/trademark/25002 > > Badly, I have troubles with the html formatting because we can't easily > add CSS and because the CSS of the page interferes with the html code. > It's the result of converting a latex file into a html file. So please > follow the link in the additional info to get a good PDF version. > > Do you think I need to format by hand the proposal or does the link to > the pdf is enough? Yes. I would prefer if you can provide a proposal that is well formatted in addition to your pdf file. Note that not all the mentors would open the pdf file when evaluating your proposal. > Any comments and suggestions would be appreciated. Best, Vicente"
"Hi, I'm getting a little historical today and I'm looking for previous versions of boost (prior to 1.16.0). I'm putting all versions in a cvs repository at home so that I can see how the library evolved, with diffs and such Yes, I don't have anything better to do and I'm tired of programming. The versions I don't have are: 1.16.0 , 1.15.1 , 1.14.2 , 1.14.0 , 1.13.0 , 1.12.0 , 1.11.2 , 1.11.1 , 1.11.0 , 1.10.4 , 1.10.3 and all others prior 1.10.3, which don't have a well defined version number. Do you people perhaps own one of these versions? If so, where I can download them? I might add that I've already googled a lot. If you own the version and want to send me, please upload to ftp://ftp.rodsoft.org/incoming . Thank you for your help. With permission of Beman Dawes I can put the repository online for everyone that is interested. Thank you once again, Rodolfo Lima. PS: this post should be in boost.user list, but i think there's a problem that I cannot post there, and sending mails to boost-users-owner_at_[hidden] to ask for help doesn't help either."
"Thore Karlsen <sid_at_[hidden]> writes: >>should be IMO: >>"" -> 0 tokens >>"abc/abc" -> 2 tokens >>"abc/abc/" -> 3 tokens >> >> >>Thoughts? > > In some ways I agree with you, but I think it may be more consistent to > output an empty token for an empty string as long as other empty tokens > are kept. However, I can see arguments for and against both ways. > > Does anyone know what other libraries/languages do in this situation? > Scripting languages typically have a split() function, but I haven't > tested this particular case. Like John said: python -c "print ''.split('/'), 'abc/abc'.split('/'), 'abc/abc/'.split('/')" [''] ['abc', 'abc'] ['abc', 'abc', '']"
">>> Great. Does anyone else have comments / concerns about a (size_t) >>> constructor? >> >> I still don't like the idea. If you really want to add this feature, please > > Why not? I'll chime in. None of boost::{shared,scoped}_{ptr,array}<T> allocate T instances within their constructors. That's (part of) what make_shared is intended to do. Avoiding redundant type specifications is auto/BOOST_AUTO's job. Rather than adding potentially ambiguous constructor overloads to well-defined, heavily-used classes, spend the time implementing boost::make_{shared,scoped}_array instead. auto + make_{shared,scoped}_array will accomplish what you want (avoiding specifying the type twice) and the functionality will benefit a much broader audience. - Rhys"
"David Abrahams skrev: > on Sat Nov 22 2008, Tomas Puverle <Tomas.Puverle-AT-morganstanley.com> wrote: > >> Anyway, I think a lot of people on this forum are missing the point: I'm not >> claiming that the old behaviour is in some way better or worse. >> I am saying the following: >> 1) Is the behavioural change too much of a diversion from previous expected >> (documented) functionality that the new change is in fact a defect > > We haven't established that, IMO. Unless I missed it, nobody has shown > where in the old documentation it was stated that a default-constructed > iterator range is empty. Well, I think the docs stated that if( rng ) was valid, and conversion to bool was based on .empty(). -Thorsten"
"Vladimir Prus <> wrote: > Duft Markus wrote: > >> Hi all! >> >> I have a question regarding the boost build on Windows: I'm building >> boost with the following bjam command: >> >> cmd.exe /C ./tools/build/jam_src/${bindir}/bjam.exe -d2 >> -sTOOLS=${toolchain} "-sBUILD=release <threading>multi >> <cxxflags>-D_USE_32BIT_TIME_T <runtime-link>dynamic" >> "-s${vc_root}=${vcvars32}" > > You appears to be using Boost 1.33.*, with Boost.Build V1, right? Hi! Ah, yes, sorry, i forgot to mention the version. Of course it's 1.33.0... > >> Everything works fine so far, but: I want only the shared libraries >> (dlls), and am settings appropriate defines to use those versions in >> all other software i build. Thus the static libraries are completely >> useless for me (at least i think so, am i wrong?) >> >> Can i somehow disable static library builds? > > I'm not sure this is easily possible in the version you're using. In > Boost 1.34.*, using Boost.Build V2, you'd use: > > link=shared > > on the command like to build only shared libraries. Hm, ok, i tried that one allready without success as far as i remember. It's not really tragic, but building boost takes twice as long as it could, right now... Cheers, Markus > > - Volodya > > > _______________________________________________ > Unsubscribe & other changes: > http://lists.boost.org/mailman/listinfo.cgi/boost"
"In article <4.3.2.7.2.20020708113102.00b96888_at_[hidden]>, Beman Dawes <boost_at_[hidden]> wrote: >At 01:18 PM 7/6/2002, Greg Comeau wrote: > >* I've downloaded the latest boost but I'm unclear how to reproduce > > the compiler status pages. > >We are in a transition from the old way of generating compiler status pages >(regression.cpp ran the tests and produced the status pages) and the new >way (bjam to run the tests, separate programs to produce status pages). > >I'm hoping to have a beta release of the status page generation programs >ready today (Monday) or tomorrow. This should make it much easier to view >the bjam results. > >I'll post a message when the status generation beta release is ready. Thanks. In the meantime, I have had success in figuring out the current way, and have rectified some libcomo issues, so Comeau strict mode now passes about 7 more tests. Will be playing a bunch more..."
"AMDG Attached is a patch for operators.hpp that resolves http://sourceforge.net/tracker/index.php?func=detail&aid=1602075&group_id=7586&atid=107586 <http://sourceforge.net/tracker/index.php?func=detail&aid=1602075&group_id=7586&atid=107586> and a patch for operator_return_type_traits.hpp that adds specializations for subscript_action with boost::array and plus_action with std::basic_string. It also fixes the problem of stripping off const too soon which causes errors with #include <ostream> #include <string> #include <boost/lambda/lambda.hpp> int main() { const std::string s = "hello"; std::cout << (boost::lambda::_1[4])(s) << std::endl; } In Christ, Steven Watanabe *** operators.hpp.orig Mon Dec 18 10:42:56 2006 --- operators.hpp Mon Dec 18 10:41:56 2006 *************** *** 266,274 **** > \ OPER_NAME (const lambda_functor<Arg>& a, CONSTB(&b)[N]) \ { \ ! return lambda_functor< \ lambda_functor_base<ACTION, tuple<lambda_functor<Arg>, CONSTB(&)[N]> > \ ! >(tuple<lambda_functor<Arg>, CONSTB(&)[N]>(a, b)); \ } --- 266,274 ---- > \ OPER_NAME (const lambda_functor<Arg>& a, CONSTB(&b)[N]) \ { \ ! return \ lambda_functor_base<ACTION, tuple<lambda_functor<Arg>, CONSTB(&)[N]> > \ ! (tuple<lambda_functor<Arg>, CONSTB(&)[N]>(a, b)); \ } *** operator_return_type_traits.hpp.orig Mon Dec 18 10:42:30 2006 --- operator_return_type_traits.hpp Mon Dec 18 11:15:00 2006 *************** *** 1,942 **** ! // operator_return_type_traits.hpp -- Boost Lambda Library ------------------ ! ! // Copyright (C) 1999, 2000 Jaakko Järvi (jaakko.jarvi_at_[hidden]) ! // ! // Distributed under the Boost Software License, Version 1.0. (See ! // accompanying file LICENSE_1_0.txt or copy at ! // http://www.boost.org/LICENSE_1_0.txt) ! // ! // For more information, see www.boost.org ! ! #ifndef BOOST_LAMBDA_OPERATOR_RETURN_TYPE_TRAITS_HPP ! #define BOOST_LAMBDA_OPERATOR_RETURN_TYPE_TRAITS_HPP ! ! #include "boost/lambda/detail/is_instance_of.hpp" ! #include "boost/type_traits/same_traits.hpp" ! ! #include "boost/indirect_reference.hpp" ! ! #include <cstddef> // needed for the ptrdiff_t ! #include <iosfwd> // for istream and ostream ! ! #include <iterator> // needed for operator& ! ! namespace boost { ! namespace lambda { ! namespace detail { ! ! // -- general helper templates for type deduction ------------------ ! ! // Much of the type deduction code for standard arithmetic types from Gary Powell ! ! template <class A> struct promote_code { static const int value = -1; }; ! // this means that a code is not defined for A ! ! // -- the next 5 types are needed in if_then_else_return ! // the promotion order is not important, but they must have distinct values. ! template <> struct promote_code<bool> { static const int value = 10; }; ! template <> struct promote_code<char> { static const int value = 20; }; ! template <> struct promote_code<unsigned char> { static const int value = 30; }; ! template <> struct promote_code<signed char> { static const int value = 40; }; ! template <> struct promote_code<short int> { static const int value = 50; }; ! // ---------- ! ! template <> struct promote_code<int> { static const int value = 100; }; ! template <> struct promote_code<unsigned int> { static const int value = 200; }; ! template <> struct promote_code<long> { static const int value = 300; }; ! template <> struct promote_code<unsigned long> { static const int value = 400; }; ! ! template <> struct promote_code<float> { static const int value = 500; }; ! template <> struct promote_code<double> { static const int value = 600; }; ! template <> struct promote_code<long double> { static const int value = 700; }; ! ! // TODO: wchar_t ! ! // forward delcaration of complex. ! ! } // namespace detail ! } // namespace lambda ! } // namespace boost ! ! namespace std { ! template<class T> class complex; ! } ! ! namespace boost { ! namespace lambda { ! namespace detail { ! ! template <> struct promote_code< std::complex<float> > { static const int value = 800; }; ! template <> struct promote_code< std::complex<double> > { static const int value = 900; }; ! template <> struct promote_code< std::complex<long double> > { static const int value = 1000; }; ! ! // -- int promotion ------------------------------------------- ! template <class T> struct promote_to_int { typedef T type; }; ! ! template <> struct promote_to_int<bool> { typedef int type; }; ! template <> struct promote_to_int<char> { typedef int type; }; ! template <> struct promote_to_int<unsigned char> { typedef int type; }; ! template <> struct promote_to_int<signed char> { typedef int type; }; ! template <> struct promote_to_int<short int> { typedef int type; }; ! ! // The unsigned short int promotion rule is this: ! // unsigned short int to signed int if a signed int can hold all values ! // of unsigned short int, otherwise go to unsigned int. ! template <> struct promote_to_int<unsigned short int> ! { ! typedef ! detail::IF<sizeof(int) <= sizeof(unsigned short int), ! // I had the logic reversed but ">" messes up the parsing. ! unsigned int, ! int>::RET type; ! }; ! ! ! // TODO: think, should there be default behaviour for non-standard types? ! ! } // namespace detail ! ! // ------------------------------------------ ! // Unary actions ---------------------------- ! // ------------------------------------------ ! ! template<class Act, class A> ! struct plain_return_type_1 { ! typedef detail::unspecified type; ! }; ! ! ! ! template<class Act, class A> ! struct plain_return_type_1<unary_arithmetic_action<Act>, A> { ! typedef A type; ! }; ! ! template<class Act, class A> ! struct return_type_1<unary_arithmetic_action<Act>, A> { ! typedef ! typename plain_return_type_1< ! unary_arithmetic_action<Act>, ! typename detail::remove_reference_and_cv<A>::type ! >::type type; ! }; ! ! ! template<class A> ! struct plain_return_type_1<bitwise_action<not_action>, A> { ! typedef A type; ! }; ! ! // bitwise not, operator~() ! template<class A> struct return_type_1<bitwise_action<not_action>, A> { ! typedef ! typename plain_return_type_1< ! bitwise_action<not_action>, ! typename detail::remove_reference_and_cv<A>::type ! >::type type; ! }; ! ! ! // prefix increment and decrement operators return ! // their argument by default as a non-const reference ! template<class Act, class A> ! struct plain_return_type_1<pre_increment_decrement_action<Act>, A> { ! typedef A& type; ! }; ! ! template<class Act, class A> ! struct return_type_1<pre_increment_decrement_action<Act>, A> { ! typedef ! typename plain_return_type_1< ! pre_increment_decrement_action<Act>, ! typename detail::remove_reference_and_cv<A>::type ! >::type type; ! }; ! ! // post decrement just returns the same plain type. ! template<class Act, class A> ! struct plain_return_type_1<post_increment_decrement_action<Act>, A> { ! typedef A type; ! }; ! ! template<class Act, class A> ! struct return_type_1<post_increment_decrement_action<Act>, A> ! { ! typedef ! typename plain_return_type_1< ! post_increment_decrement_action<Act>, ! typename detail::remove_reference_and_cv<A>::type ! >::type type; ! }; ! ! // logical not, operator!() ! template<class A> ! struct plain_return_type_1<logical_action<not_action>, A> { ! typedef bool type; ! }; ! ! template<class A> ! struct return_type_1<logical_action<not_action>, A> { ! typedef ! typename plain_return_type_1< ! logical_action<not_action>, ! typename detail::remove_reference_and_cv<A>::type ! >::type type; ! }; ! ! // address of action --------------------------------------- ! ! ! template<class A> ! struct return_type_1<other_action<addressof_action>, A> { ! typedef ! typename plain_return_type_1< ! other_action<addressof_action>, ! typename detail::remove_reference_and_cv<A>::type ! >::type type1; ! ! // If no user defined specialization for A, then return the ! // cv qualified pointer to A ! typedef typename detail::IF< ! boost::is_same<type1, detail::unspecified>::value, ! typename boost::remove_reference<A>::type*, ! type1 ! >::RET type; ! }; ! ! // contentsof action ------------------------------------ ! ! // TODO: this deduction may lead to fail directly, ! // (if A has no specialization for iterator_traits and has no ! // typedef A::reference. ! // There is no easy way around this, cause there doesn't seem to be a way ! // to test whether a class is an iterator or not. ! ! // The default works with std::iterators. ! ! namespace detail { ! ! // A is a nonreference type ! template <class A> struct contentsof_type { ! typedef typename boost::indirect_reference<A>::type type; ! }; ! ! // this is since the nullary () in lambda_functor is always instantiated ! template <> struct contentsof_type<null_type> { ! typedef detail::unspecified type; ! }; ! ! ! template <class A> struct contentsof_type<const A> { ! typedef typename contentsof_type<A>::type type1; ! // return a reference to the underlying const type ! // the IF is because the A::reference in the primary template could ! // be some class type rather than a real reference, hence ! // we do not want to make it a reference here either ! typedef typename detail::IF< ! is_reference<type1>::value, ! const typename boost::remove_reference<type1>::type &, ! const type1 ! >::RET type; ! }; ! ! template <class A> struct contentsof_type<volatile A> { ! typedef typename contentsof_type<A>::type type1; ! typedef typename detail::IF< ! is_reference<type1>::value, ! volatile typename boost::remove_reference<type1>::type &, ! volatile type1 ! >::RET type; ! }; ! ! template <class A> struct contentsof_type<const volatile A> { ! typedef typename contentsof_type<A>::type type1; ! typedef typename detail::IF< ! is_reference<type1>::value, ! const volatile typename boost::remove_reference<type1>::type &, ! const volatile type1 ! >::RET type; ! }; ! ! // standard iterator traits should take care of the pointer types ! // but just to be on the safe side, we have the specializations here: ! // these work even if A is cv-qualified. ! template <class A> struct contentsof_type<A*> { ! typedef A& type; ! }; ! template <class A> struct contentsof_type<A* const> { ! typedef A& type; ! }; ! template <class A> struct contentsof_type<A* volatile> { ! typedef A& type; ! }; ! template <class A> struct contentsof_type<A* const volatile> { ! typedef A& type; ! }; ! ! template<class A, int N> struct contentsof_type<A[N]> { ! typedef A& type; ! }; ! template<class A, int N> struct contentsof_type<const A[N]> { ! typedef const A& type; ! }; ! template<class A, int N> struct contentsof_type<volatile A[N]> { ! typedef volatile A& type; ! }; ! template<class A, int N> struct contentsof_type<const volatile A[N]> { ! typedef const volatile A& type; ! }; ! ! ! ! ! ! } // end detail ! ! template<class A> ! struct return_type_1<other_action<contentsof_action>, A> { ! ! typedef ! typename plain_return_type_1< ! other_action<contentsof_action>, ! typename detail::remove_reference_and_cv<A>::type ! >::type type1; ! ! // If no user defined specialization for A, then return the ! // cv qualified pointer to A ! typedef typename ! detail::IF_type< ! boost::is_same<type1, detail::unspecified>::value, ! detail::contentsof_type< ! typename boost::remove_reference<A>::type ! >, ! detail::identity_mapping<type1> ! >::type type; ! }; ! ! ! // ------------------------------------------------------------------ ! // binary actions --------------------------------------------------- ! // ------------------------------------------------------------------ ! ! // here the default case is: no user defined versions: ! template <class Act, class A, class B> ! struct plain_return_type_2 { ! typedef detail::unspecified type; ! }; ! ! namespace detail { ! ! // error classes ! class illegal_pointer_arithmetic{}; ! ! // pointer arithmetic type deductions ---------------------- ! // value = false means that this is not a pointer arithmetic case ! // value = true means, that this can be a pointer arithmetic case, but not necessarily is ! // This means, that for user defined operators for pointer types, say for some operator+(X, *Y), ! // the deductions must be coded at an earliel level (return_type_2). ! ! template<class Act, class A, class B> ! struct pointer_arithmetic_traits { static const bool value = false; }; ! ! template<class A, class B> ! struct pointer_arithmetic_traits<plus_action, A, B> { ! ! typedef typename ! array_to_pointer<typename boost::remove_reference<A>::type>::type AP; ! typedef typename ! array_to_pointer<typename boost::remove_reference<B>::type>::type BP; ! ! static const bool is_pointer_A = boost::is_pointer<AP>::value; ! static const bool is_pointer_B = boost::is_pointer<BP>::value; ! ! static const bool value = is_pointer_A || is_pointer_B; ! ! // can't add two pointers. ! // note, that we do not check wether the other type is valid for ! // addition with a pointer. ! // the compiler will catch it in the apply function ! ! typedef typename ! detail::IF< ! is_pointer_A && is_pointer_B, ! detail::return_type_deduction_failure< ! detail::illegal_pointer_arithmetic ! >, ! typename detail::IF<is_pointer_A, AP, BP>::RET ! >::RET type; ! ! }; ! ! template<class A, class B> ! struct pointer_arithmetic_traits<minus_action, A, B> { ! typedef typename ! array_to_pointer<typename boost::remove_reference<A>::type>::type AP; ! typedef typename ! array_to_pointer<typename boost::remove_reference<B>::type>::type BP; ! ! static const bool is_pointer_A = boost::is_pointer<AP>::value; ! static const bool is_pointer_B = boost::is_pointer<BP>::value; ! ! static const bool value = is_pointer_A || is_pointer_B; ! ! static const bool same_pointer_type = ! is_pointer_A && is_pointer_B && ! boost::is_same< ! typename boost::remove_const< ! typename boost::remove_pointer< ! typename boost::remove_const<AP>::type ! >::type ! >::type, ! typename boost::remove_const< ! typename boost::remove_pointer< ! typename boost::remove_const<BP>::type ! >::type ! >::type ! >::value; ! ! // ptr - ptr has type ptrdiff_t ! // note, that we do not check if, in ptr - B, B is ! // valid for subtraction with a pointer. ! // the compiler will catch it in the apply function ! ! typedef typename ! detail::IF< ! same_pointer_type, const std::ptrdiff_t, ! typename detail::IF< ! is_pointer_A, ! AP, ! detail::return_type_deduction_failure<detail::illegal_pointer_arithmetic> ! >::RET ! >::RET type; ! }; ! ! } // namespace detail ! ! // -- arithmetic actions --------------------------------------------- ! ! namespace detail { ! ! template<bool is_pointer_arithmetic, class Act, class A, class B> ! struct return_type_2_arithmetic_phase_1; ! ! template<class A, class B> struct return_type_2_arithmetic_phase_2; ! template<class A, class B> struct return_type_2_arithmetic_phase_3; ! ! } // namespace detail ! ! ! // drop any qualifiers from the argument types within arithmetic_action ! template<class A, class B, class Act> ! struct return_type_2<arithmetic_action<Act>, A, B> ! { ! typedef typename detail::remove_reference_and_cv<A>::type plain_A; ! typedef typename detail::remove_reference_and_cv<B>::type plain_B; ! ! typedef typename ! plain_return_type_2<arithmetic_action<Act>, plain_A, plain_B>::type type1; ! ! // if user defined return type, do not enter the whole arithmetic deductions ! typedef typename ! detail::IF_type< ! boost::is_same<type1, detail::unspecified>::value, ! detail::return_type_2_arithmetic_phase_1< ! detail::pointer_arithmetic_traits<Act, A, B>::value, Act, A, B ! >, ! plain_return_type_2<arithmetic_action<Act>, plain_A, plain_B> ! >::type type; ! }; ! ! namespace detail { ! ! // perform integral promotion, no pointer arithmetic ! template<bool is_pointer_arithmetic, class Act, class A, class B> ! struct return_type_2_arithmetic_phase_1 ! { ! typedef typename ! return_type_2_arithmetic_phase_2< ! typename remove_reference_and_cv<A>::type, ! typename remove_reference_and_cv<B>::type ! >::type type; ! }; ! ! // pointer_arithmetic ! template<class Act, class A, class B> ! struct return_type_2_arithmetic_phase_1<true, Act, A, B> ! { ! typedef typename ! pointer_arithmetic_traits<Act, A, B>::type type; ! }; ! ! template<class A, class B> ! struct return_type_2_arithmetic_phase_2 { ! typedef typename ! return_type_2_arithmetic_phase_3< ! typename promote_to_int<A>::type, ! typename promote_to_int<B>::type ! >::type type; ! }; ! ! // specialization for unsigned int. ! // We only have to do these two specialization because the value promotion will ! // take care of the other cases. ! // The unsigned int promotion rule is this: ! // unsigned int to long if a long can hold all values of unsigned int, ! // otherwise go to unsigned long. ! ! // struct so I don't have to type this twice. ! struct promotion_of_unsigned_int ! { ! typedef ! detail::IF<sizeof(long) <= sizeof(unsigned int), ! unsigned long, ! long>::RET type; ! }; ! ! template<> ! struct return_type_2_arithmetic_phase_2<unsigned int, long> ! { ! typedef promotion_of_unsigned_int::type type; ! }; ! template<> ! struct return_type_2_arithmetic_phase_2<long, unsigned int> ! { ! typedef promotion_of_unsigned_int::type type; ! }; ! ! ! template<class A, class B> struct return_type_2_arithmetic_phase_3 { ! enum { promote_code_A_value = promote_code<A>::value, ! promote_code_B_value = promote_code<B>::value }; // enums for KCC ! typedef typename ! detail::IF< ! promote_code_A_value == -1 || promote_code_B_value == -1, ! detail::return_type_deduction_failure<return_type_2_arithmetic_phase_3>, ! typename detail::IF< ! ((int)promote_code_A_value > (int)promote_code_B_value), ! A, ! B ! >::RET ! >::RET type; ! }; ! ! } // namespace detail ! ! // -- bitwise actions ------------------------------------------- ! // note: for integral types deuduction is similar to arithmetic actions. ! ! // drop any qualifiers from the argument types within arithmetic action ! template<class A, class B, class Act> ! struct return_type_2<bitwise_action<Act>, A, B> ! { ! ! typedef typename detail::remove_reference_and_cv<A>::type plain_A; ! typedef typename detail::remove_reference_and_cv<B>::type plain_B; ! ! typedef typename ! plain_return_type_2<bitwise_action<Act>, plain_A, plain_B>::type type1; ! ! // if user defined return type, do not enter type deductions ! typedef typename ! detail::IF_type< ! boost::is_same<type1, detail::unspecified>::value, ! return_type_2<arithmetic_action<plus_action>, A, B>, ! plain_return_type_2<bitwise_action<Act>, plain_A, plain_B> ! >::type type; ! ! // plus_action is just a random pick, has to be a concrete instance ! ! // TODO: This check is only valid for built-in types, overloaded types might ! // accept floating point operators ! ! // bitwise operators not defined for floating point types ! // these test are not strictly needed here, since the error will be caught in ! // the apply function ! BOOST_STATIC_ASSERT(!(boost::is_float<plain_A>::value && boost::is_float<plain_B>::value)); ! ! }; ! ! namespace detail { ! ! #ifdef BOOST_NO_TEMPLATED_STREAMS ! ! template<class A, class B> ! struct leftshift_type { ! ! typedef typename detail::IF< ! boost::is_convertible< ! typename boost::remove_reference<A>::type*, ! std::ostream* ! >::value, ! std::ostream&, ! typename detail::remove_reference_and_cv<A>::type ! >::RET type; ! }; ! ! template<class A, class B> ! struct rightshift_type { ! ! typedef typename detail::IF< ! ! boost::is_convertible< ! typename boost::remove_reference<A>::type*, ! std::istream* ! >::value, ! std::istream&, ! typename detail::remove_reference_and_cv<A>::type ! >::RET type; ! }; ! ! #else ! ! template <class T> struct get_ostream_type { ! typedef std::basic_ostream<typename T::char_type, ! typename T::traits_type>& type; ! }; ! ! template <class T> struct get_istream_type { ! typedef std::basic_istream<typename T::char_type, ! typename T::traits_type>& type; ! }; ! ! template<class A, class B> ! struct leftshift_type { ! private: ! typedef typename boost::remove_reference<A>::type plainA; ! public: ! typedef typename detail::IF_type< ! is_instance_of_2<plainA, std::basic_ostream>::value, ! get_ostream_type<plainA>, //reference to the stream ! detail::remove_reference_and_cv<A> ! >::type type; ! }; ! ! template<class A, class B> ! struct rightshift_type { ! private: ! typedef typename boost::remove_reference<A>::type plainA; ! public: ! typedef typename detail::IF_type< ! is_instance_of_2<plainA, std::basic_istream>::value, ! get_istream_type<plainA>, //reference to the stream ! detail::remove_reference_and_cv<A> ! >::type type; ! }; ! ! ! #endif ! ! } // end detail ! ! // ostream ! template<class A, class B> ! struct return_type_2<bitwise_action<leftshift_action>, A, B> ! { ! typedef typename detail::remove_reference_and_cv<A>::type plain_A; ! typedef typename detail::remove_reference_and_cv<B>::type plain_B; ! ! typedef typename ! plain_return_type_2<bitwise_action<leftshift_action>, plain_A, plain_B>::type type1; ! ! // if user defined return type, do not enter type deductions ! typedef typename ! detail::IF_type< ! boost::is_same<type1, detail::unspecified>::value, ! detail::leftshift_type<A, B>, ! plain_return_type_2<bitwise_action<leftshift_action>, plain_A, plain_B> ! >::type type; ! }; ! ! // istream ! template<class A, class B> ! struct return_type_2<bitwise_action<rightshift_action>, A, B> ! { ! typedef typename detail::remove_reference_and_cv<A>::type plain_A; ! typedef typename detail::remove_reference_and_cv<B>::type plain_B; ! ! typedef typename ! plain_return_type_2<bitwise_action<rightshift_action>, plain_A, plain_B>::type type1; ! ! // if user defined return type, do not enter type deductions ! typedef typename ! detail::IF_type< ! boost::is_same<type1, detail::unspecified>::value, ! detail::rightshift_type<A, B>, ! plain_return_type_2<bitwise_action<rightshift_action>, plain_A, plain_B> ! >::type type; ! }; ! ! // -- logical actions ---------------------------------------- ! // always bool ! // NOTE: this may not be true for some weird user-defined types, ! template<class A, class B, class Act> ! struct plain_return_type_2<logical_action<Act>, A, B> { ! typedef bool type; ! }; ! ! template<class A, class B, class Act> ! struct return_type_2<logical_action<Act>, A, B> { ! ! typedef typename detail::remove_reference_and_cv<A>::type plain_A; ! typedef typename detail::remove_reference_and_cv<B>::type plain_B; ! ! typedef typename ! plain_return_type_2<logical_action<Act>, plain_A, plain_B>::type type; ! ! }; ! ! ! // -- relational actions ---------------------------------------- ! // always bool ! // NOTE: this may not be true for some weird user-defined types, ! template<class A, class B, class Act> ! struct plain_return_type_2<relational_action<Act>, A, B> { ! typedef bool type; ! }; ! ! template<class A, class B, class Act> ! struct return_type_2<relational_action<Act>, A, B> { ! ! typedef typename detail::remove_reference_and_cv<A>::type plain_A; ! typedef typename detail::remove_reference_and_cv<B>::type plain_B; ! ! typedef typename ! plain_return_type_2<relational_action<Act>, plain_A, plain_B>::type type; ! }; ! ! // Assingment actions ----------------------------------------------- ! // return type is the type of the first argument as reference ! ! // note that cv-qualifiers are preserved. ! // Yes, assignment operator can be const! ! ! // NOTE: this may not be true for some weird user-defined types, ! ! template<class A, class B, class Act> ! struct return_type_2<arithmetic_assignment_action<Act>, A, B> { ! ! typedef typename detail::remove_reference_and_cv<A>::type plain_A; ! typedef typename detail::remove_reference_and_cv<B>::type plain_B; ! ! typedef typename ! plain_return_type_2< ! arithmetic_assignment_action<Act>, plain_A, plain_B ! >::type type1; ! ! typedef typename ! detail::IF< ! boost::is_same<type1, detail::unspecified>::value, ! typename boost::add_reference<A>::type, ! type1 ! >::RET type; ! }; ! ! template<class A, class B, class Act> ! struct return_type_2<bitwise_assignment_action<Act>, A, B> { ! ! typedef typename detail::remove_reference_and_cv<A>::type plain_A; ! typedef typename detail::remove_reference_and_cv<B>::type plain_B; ! ! typedef typename ! plain_return_type_2< ! bitwise_assignment_action<Act>, plain_A, plain_B ! >::type type1; ! ! typedef typename ! detail::IF< ! boost::is_same<type1, detail::unspecified>::value, ! typename boost::add_reference<A>::type, ! type1 ! >::RET type; ! }; ! ! template<class A, class B> ! struct return_type_2<other_action<assignment_action>, A, B> { ! typedef typename detail::remove_reference_and_cv<A>::type plain_A; ! typedef typename detail::remove_reference_and_cv<B>::type plain_B; ! ! typedef typename ! plain_return_type_2< ! other_action<assignment_action>, plain_A, plain_B ! >::type type1; ! ! typedef typename ! detail::IF< ! boost::is_same<type1, detail::unspecified>::value, ! typename boost::add_reference<A>::type, ! type1 ! >::RET type; ! }; ! ! // -- other actions ---------------------------------------- ! ! // comma action ---------------------------------- ! // Note: this may not be true for some weird user-defined types, ! ! // NOTE! This only tries the plain_return_type_2 layer and gives ! // detail::unspecified as default. If no such specialization is found, the ! // type rule in the spcecialization of the return_type_2_prot is used ! // to give the type of the right argument (which can be a reference too) ! // (The built in operator, can return a l- or rvalue). ! template<class A, class B> ! struct return_type_2<other_action<comma_action>, A, B> { ! ! typedef typename detail::remove_reference_and_cv<A>::type plain_A; ! typedef typename detail::remove_reference_and_cv<B>::type plain_B; ! ! typedef typename ! plain_return_type_2< ! other_action<comma_action>, plain_A, plain_B ! >::type type; ! }; ! ! // subscript action ----------------------------------------------- ! ! ! namespace detail { ! // A and B are nonreference types ! template <class A, class B> struct subscript_type { ! typedef detail::unspecified type; ! }; ! ! template <class A, class B> struct subscript_type<A*, B> { ! typedef A& type; ! }; ! template <class A, class B> struct subscript_type<A* const, B> { ! typedef A& type; ! }; ! template <class A, class B> struct subscript_type<A* volatile, B> { ! typedef A& type; ! }; ! template <class A, class B> struct subscript_type<A* const volatile, B> { ! typedef A& type; ! }; ! ! ! template<class A, class B, int N> struct subscript_type<A[N], B> { ! typedef A& type; ! }; ! ! // these 3 specializations are needed to make gcc <3 happy ! template<class A, class B, int N> struct subscript_type<const A[N], B> { ! typedef const A& type; ! }; ! template<class A, class B, int N> struct subscript_type<volatile A[N], B> { ! typedef volatile A& type; ! }; ! template<class A, class B, int N> struct subscript_type<const volatile A[N], B> { ! typedef const volatile A& type; ! }; ! ! } // end detail ! ! template<class A, class B> ! struct return_type_2<other_action<subscript_action>, A, B> { ! ! typedef typename detail::remove_reference_and_cv<A>::type plain_A; ! typedef typename detail::remove_reference_and_cv<B>::type plain_B; ! ! typedef typename boost::remove_reference<A>::type nonref_A; ! typedef typename boost::remove_reference<B>::type nonref_B; ! ! typedef typename ! plain_return_type_2< ! other_action<subscript_action>, plain_A, plain_B ! >::type type1; ! ! typedef typename ! detail::IF_type< ! boost::is_same<type1, detail::unspecified>::value, ! detail::subscript_type<nonref_A, nonref_B>, ! plain_return_type_2<other_action<subscript_action>, plain_A, plain_B> ! >::type type; ! ! }; ! ! ! } // namespace lambda ! } // namespace boost ! ! ! // Forward declarations are incompatible with the libstdc++ debug mode. ! #if BOOST_WORKAROUND(__GNUC__, >= 3) && defined(_GLIBCXX_DEBUG) ! #include <string> ! #include <vector> ! #include <map> ! #include <deque> ! #else ! ! // The GCC 2.95.x uses a non-conformant deque ! #if BOOST_WORKAROUND(__GNUC__, == 2) && __GNUC_MINOR__ <= 96 ! #include <deque> ! #else ! ! namespace std { ! template <class T, class Allocator> class deque; ! } ! ! #endif ! ! namespace std { ! template <class Char, class Traits, class Allocator> class basic_string; ! template <class T, class Allocator> class vector; ! template <class Key, class T, class Cmp, class Allocator> class map; ! template <class Key, class T, class Cmp, class Allocator> class multimap; ! } ! ! #endif ! ! ! ! namespace boost { ! namespace lambda { ! ! template<class Key, class T, class Cmp, class Allocator, class B> ! struct plain_return_type_2<other_action<subscript_action>, std::map<Key, T, Cmp, Allocator>, B> { ! typedef T& type; ! // T == std::map<Key, T, Cmp, Allocator>::mapped_type; ! }; ! ! template<class Key, class T, class Cmp, class Allocator, class B> ! struct plain_return_type_2<other_action<subscript_action>, std::multimap<Key, T, Cmp, Allocator>, B> { ! typedef T& type; ! // T == std::map<Key, T, Cmp, Allocator>::mapped_type; ! }; ! ! // deque ! template<class T, class Allocator, class B> ! struct plain_return_type_2<other_action<subscript_action>, std::deque<T, Allocator>, B> { ! typedef typename std::deque<T, Allocator>::reference type; ! }; ! template<class T, class Allocator, class B> ! struct plain_return_type_2<other_action<subscript_action>, const std::deque<T, Allocator>, B> { ! typedef typename std::deque<T, Allocator>::const_reference type; ! }; ! ! // vector ! template<class T, class Allocator, class B> ! struct plain_return_type_2<other_action<subscript_action>, std::vector<T, Allocator>, B> { ! typedef typename std::vector<T, Allocator>::reference type; ! }; ! template<class T, class Allocator, class B> ! struct plain_return_type_2<other_action<subscript_action>, const std::vector<T, Allocator>, B> { ! typedef typename std::vector<T, Allocator>::const_reference type; ! }; ! ! // basic_string ! template<class Char, class Traits, class Allocator, class B> ! struct plain_return_type_2<other_action<subscript_action>, std::basic_string<Char, Traits, Allocator>, B> { ! typedef typename std::basic_string<Char, Traits, Allocator>::reference type; ! }; ! template<class Char, class Traits, class Allocator, class B> ! struct plain_return_type_2<other_action<subscript_action>, const std::basic_string<Char, Traits, Allocator>, B> { ! typedef typename std::basic_string<Char, Traits, Allocator>::const_reference type; ! }; ! ! ! } // namespace lambda ! } // namespace boost ! ! #endif ! ! --- 1,1004 ---- ! // operator_return_type_traits.hpp -- Boost Lambda Library ------------------ ! ! // Copyright (C) 1999, 2000 Jaakko Järvi (jaakko.jarvi_at_[hidden]) ! // ! // Distributed under the Boost Software License, Version 1.0. (See ! // accompanying file LICENSE_1_0.txt or copy at ! // http://www.boost.org/LICENSE_1_0.txt) ! // ! // For more information, see www.boost.org ! ! #ifndef BOOST_LAMBDA_OPERATOR_RETURN_TYPE_TRAITS_HPP ! #define BOOST_LAMBDA_OPERATOR_RETURN_TYPE_TRAITS_HPP ! ! #include "boost/lambda/detail/is_instance_of.hpp" ! #include "boost/type_traits/same_traits.hpp" ! #include "boost/type_traits/cv_traits.hpp" ! #include "boost/type_traits/remove_reference.hpp" ! ! #include "boost/indirect_reference.hpp" ! ! #include <cstddef> // needed for the ptrdiff_t ! #include <iosfwd> // for istream and ostream ! ! #include <iterator> // needed for operator& ! ! namespace boost { ! namespace lambda { ! namespace detail { ! ! // -- general helper templates for type deduction ------------------ ! ! // Much of the type deduction code for standard arithmetic types from Gary Powell ! ! template <class A> struct promote_code { static const int value = -1; }; ! // this means that a code is not defined for A ! ! // -- the next 5 types are needed in if_then_else_return ! // the promotion order is not important, but they must have distinct values. ! template <> struct promote_code<bool> { static const int value = 10; }; ! template <> struct promote_code<char> { static const int value = 20; }; ! template <> struct promote_code<unsigned char> { static const int value = 30; }; ! template <> struct promote_code<signed char> { static const int value = 40; }; ! template <> struct promote_code<short int> { static const int value = 50; }; ! // ---------- ! ! template <> struct promote_code<int> { static const int value = 100; }; ! template <> struct promote_code<unsigned int> { static const int value = 200; }; ! template <> struct promote_code<long> { static const int value = 300; }; ! template <> struct promote_code<unsigned long> { static const int value = 400; }; ! ! template <> struct promote_code<float> { static const int value = 500; }; ! template <> struct promote_code<double> { static const int value = 600; }; ! template <> struct promote_code<long double> { static const int value = 700; }; ! ! // TODO: wchar_t ! ! // forward delcaration of complex. ! ! } // namespace detail ! } // namespace lambda ! } // namespace boost ! ! namespace std { ! template<class T> class complex; ! } ! ! namespace boost { ! namespace lambda { ! namespace detail { ! ! template <> struct promote_code< std::complex<float> > { static const int value = 800; }; ! template <> struct promote_code< std::complex<double> > { static const int value = 900; }; ! template <> struct promote_code< std::complex<long double> > { static const int value = 1000; }; ! ! // -- int promotion ------------------------------------------- ! template <class T> struct promote_to_int { typedef T type; }; ! ! template <> struct promote_to_int<bool> { typedef int type; }; ! template <> struct promote_to_int<char> { typedef int type; }; ! template <> struct promote_to_int<unsigned char> { typedef int type; }; ! template <> struct promote_to_int<signed char> { typedef int type; }; ! template <> struct promote_to_int<short int> { typedef int type; }; ! ! // The unsigned short int promotion rule is this: ! // unsigned short int to signed int if a signed int can hold all values ! // of unsigned short int, otherwise go to unsigned int. ! template <> struct promote_to_int<unsigned short int> ! { ! typedef ! detail::IF<sizeof(int) <= sizeof(unsigned short int), ! // I had the logic reversed but ">" messes up the parsing. ! unsigned int, ! int>::RET type; ! }; ! ! ! // TODO: think, should there be default behaviour for non-standard types? ! ! } // namespace detail ! ! // ------------------------------------------ ! // Unary actions ---------------------------- ! // ------------------------------------------ ! ! template<class Act, class A> ! struct plain_return_type_1 { ! typedef typename detail::IF_type<(is_const<A>::value || is_volatile<A>::value), ! plain_return_type_1<Act, typename remove_cv<A>::type>, ! detail::identity_mapping<detail::unspecified> ! >::type type; ! }; ! ! ! ! template<class Act, class A> ! struct plain_return_type_1<unary_arithmetic_action<Act>, A> { ! typedef A type; ! }; ! ! template<class Act, class A> ! struct return_type_1<unary_arithmetic_action<Act>, A> { ! typedef ! typename plain_return_type_1< ! unary_arithmetic_action<Act>, ! typename boost::remove_reference<A>::type ! >::type type; ! }; ! ! ! template<class A> ! struct plain_return_type_1<bitwise_action<not_action>, A> { ! typedef A type; ! }; ! ! // bitwise not, operator~() ! template<class A> struct return_type_1<bitwise_action<not_action>, A> { ! typedef ! typename plain_return_type_1< ! bitwise_action<not_action>, ! typename boost::remove_reference<A>::type ! >::type type; ! }; ! ! ! // prefix increment and decrement operators return ! // their argument by default as a non-const reference ! template<class Act, class A> ! struct plain_return_type_1<pre_increment_decrement_action<Act>, A> { ! typedef A& type; ! }; ! ! template<class Act, class A> ! struct return_type_1<pre_increment_decrement_action<Act>, A> { ! typedef ! typename plain_return_type_1< ! pre_increment_decrement_action<Act>, ! typename boost::remove_reference<A>::type ! >::type type; ! }; ! ! // post decrement just returns the same plain type. ! template<class Act, class A> ! struct plain_return_type_1<post_increment_decrement_action<Act>, A> { ! typedef A type; ! }; ! ! template<class Act, class A> ! struct return_type_1<post_increment_decrement_action<Act>, A> ! { ! typedef ! typename plain_return_type_1< ! post_increment_decrement_action<Act>, ! typename boost::remove_reference<A>::type ! >::type type; ! }; ! ! // logical not, operator!() ! template<class A> ! struct plain_return_type_1<logical_action<not_action>, A> { ! typedef bool type; ! }; ! ! template<class A> ! struct return_type_1<logical_action<not_action>, A> { ! typedef ! typename plain_return_type_1< ! logical_action<not_action>, ! typename boost::remove_reference<A>::type ! >::type type; ! }; ! ! // address of action --------------------------------------- ! ! ! template<class A> ! struct return_type_1<other_action<addressof_action>, A> { ! typedef ! typename plain_return_type_1< ! other_action<addressof_action>, ! typename boost::remove_reference<A>::type ! >::type type1; ! ! // If no user defined specialization for A, then return the ! // cv qualified pointer to A ! typedef typename detail::IF< ! boost::is_same<type1, detail::unspecified>::value, ! typename boost::remove_reference<A>::type*, ! type1 ! >::RET type; ! }; ! ! // contentsof action ------------------------------------ ! ! // TODO: this deduction may lead to fail directly, ! // (if A has no specialization for iterator_traits and has no ! // typedef A::reference. ! // There is no easy way around this, cause there doesn't seem to be a way ! // to test whether a class is an iterator or not. ! ! // The default works with std::iterators. ! ! namespace detail { ! ! // A is a nonreference type ! template <class A> struct contentsof_type { ! typedef typename boost::indirect_reference<A>::type type; ! }; ! ! // this is since the nullary () in lambda_functor is always instantiated ! template <> struct contentsof_type<null_type> { ! typedef detail::unspecified type; ! }; ! ! ! template <class A> struct contentsof_type<const A> { ! typedef typename contentsof_type<A>::type type1; ! // return a reference to the underlying const type ! // the IF is because the A::reference in the primary template could ! // be some class type rather than a real reference, hence ! // we do not want to make it a reference here either ! typedef typename detail::IF< ! is_reference<type1>::value, ! const typename boost::remove_reference<type1>::type &, ! const type1 ! >::RET type; ! }; ! ! template <class A> struct contentsof_type<volatile A> { ! typedef typename contentsof_type<A>::type type1; ! typedef typename detail::IF< ! is_reference<type1>::value, ! volatile typename boost::remove_reference<type1>::type &, ! volatile type1 ! >::RET type; ! }; ! ! template <class A> struct contentsof_type<const volatile A> { ! typedef typename contentsof_type<A>::type type1; ! typedef typename detail::IF< ! is_reference<type1>::value, ! const volatile typename boost::remove_reference<type1>::type &, ! const volatile type1 ! >::RET type; ! }; ! ! // standard iterator traits should take care of the pointer types ! // but just to be on the safe side, we have the specializations here: ! // these work even if A is cv-qualified. ! template <class A> struct contentsof_type<A*> { ! typedef A& type; ! }; ! template <class A> struct contentsof_type<A* const> { ! typedef A& type; ! }; ! template <class A> struct contentsof_type<A* volatile> { ! typedef A& type; ! }; ! template <class A> struct contentsof_type<A* const volatile> { ! typedef A& type; ! }; ! ! template<class A, int N> struct contentsof_type<A[N]> { ! typedef A& type; ! }; ! template<class A, int N> struct contentsof_type<const A[N]> { ! typedef const A& type; ! }; ! template<class A, int N> struct contentsof_type<volatile A[N]> { ! typedef volatile A& type; ! }; ! template<class A, int N> struct contentsof_type<const volatile A[N]> { ! typedef const volatile A& type; ! }; ! ! ! ! ! ! } // end detail ! ! template<class A> ! struct return_type_1<other_action<contentsof_action>, A> { ! ! typedef ! typename plain_return_type_1< ! other_action<contentsof_action>, ! typename boost::remove_reference<A>::type ! >::type type1; ! ! // If no user defined specialization for A, then return the ! // cv qualified pointer to A ! typedef typename ! detail::IF_type< ! boost::is_same<type1, detail::unspecified>::value, ! detail::contentsof_type< ! typename boost::remove_reference<A>::type ! >, ! detail::identity_mapping<type1> ! >::type type; ! }; ! ! ! // ------------------------------------------------------------------ ! // binary actions --------------------------------------------------- ! // ------------------------------------------------------------------ ! ! // here the default case is: no user defined versions: ! template <class Act, class A, class B> ! struct plain_return_type_2 { ! typedef typename detail::IF_type<(is_const<A>::value || is_volatile<A>::value || is_const<B>::value || is_volatile<B>::value), ! plain_return_type_2<Act, typename remove_cv<A>::type, typename remove_cv<B>::type>, ! detail::identity_mapping<detail::unspecified> ! >::type type; ! }; ! ! namespace detail { ! ! // error classes ! class illegal_pointer_arithmetic{}; ! ! // pointer arithmetic type deductions ---------------------- ! // value = false means that this is not a pointer arithmetic case ! // value = true means, that this can be a pointer arithmetic case, but not necessarily is ! // This means, that for user defined operators for pointer types, say for some operator+(X, *Y), ! // the deductions must be coded at an earliel level (return_type_2). ! ! template<class Act, class A, class B> ! struct pointer_arithmetic_traits { static const bool value = false; }; ! ! template<class A, class B> ! struct pointer_arithmetic_traits<plus_action, A, B> { ! ! typedef typename ! array_to_pointer<typename boost::remove_reference<A>::type>::type AP; ! typedef typename ! array_to_pointer<typename boost::remove_reference<B>::type>::type BP; ! ! static const bool is_pointer_A = boost::is_pointer<AP>::value; ! static const bool is_pointer_B = boost::is_pointer<BP>::value; ! ! static const bool value = is_pointer_A || is_pointer_B; ! ! // can't add two pointers. ! // note, that we do not check wether the other type is valid for ! // addition with a pointer. ! // the compiler will catch it in the apply function ! ! typedef typename ! detail::IF< ! is_pointer_A && is_pointer_B, ! detail::return_type_deduction_failure< ! detail::illegal_pointer_arithmetic ! >, ! typename detail::IF<is_pointer_A, AP, BP>::RET ! >::RET type; ! ! }; ! ! template<class A, class B> ! struct pointer_arithmetic_traits<minus_action, A, B> { ! typedef typename ! array_to_pointer<typename boost::remove_reference<A>::type>::type AP; ! typedef typename ! array_to_pointer<typename boost::remove_reference<B>::type>::type BP; ! ! static const bool is_pointer_A = boost::is_pointer<AP>::value; ! static const bool is_pointer_B = boost::is_pointer<BP>::value; ! ! static const bool value = is_pointer_A || is_pointer_B; ! ! static const bool same_pointer_type = ! is_pointer_A && is_pointer_B && ! boost::is_same< ! typename boost::remove_const< ! typename boost::remove_pointer< ! typename boost::remove_const<AP>::type ! >::type ! >::type, ! typename boost::remove_const< ! typename boost::remove_pointer< ! typename boost::remove_const<BP>::type ! >::type ! >::type ! >::value; ! ! // ptr - ptr has type ptrdiff_t ! // note, that we do not check if, in ptr - B, B is ! // valid for subtraction with a pointer. ! // the compiler will catch it in the apply function ! ! typedef typename ! detail::IF< ! same_pointer_type, const std::ptrdiff_t, ! typename detail::IF< ! is_pointer_A, ! AP, ! detail::return_type_deduction_failure<detail::illegal_pointer_arithmetic> ! >::RET ! >::RET type; ! }; ! ! } // namespace detail ! ! // -- arithmetic actions --------------------------------------------- ! ! namespace detail { ! ! template<bool is_pointer_arithmetic, class Act, class A, class B> ! struct return_type_2_arithmetic_phase_1; ! ! template<class A, class B> struct return_type_2_arithmetic_phase_2; ! template<class A, class B> struct return_type_2_arithmetic_phase_3; ! ! } // namespace detail ! ! ! // drop any qualifiers from the argument types within arithmetic_action ! template<class A, class B, class Act> ! struct return_type_2<arithmetic_action<Act>, A, B> ! { ! typedef typename remove_reference<A>::type plain_A; ! typedef typename remove_reference<B>::type plain_B; ! ! typedef typename ! plain_return_type_2<arithmetic_action<Act>, plain_A, plain_B>::type type1; ! ! // if user defined return type, do not enter the whole arithmetic deductions ! typedef typename ! detail::IF_type< ! boost::is_same<type1, detail::unspecified>::value, ! detail::return_type_2_arithmetic_phase_1< ! detail::pointer_arithmetic_traits<Act, A, B>::value, Act, A, B ! >, ! plain_return_type_2<arithmetic_action<Act>, plain_A, plain_B> ! >::type type; ! }; ! ! namespace detail { ! ! // perform integral promotion, no pointer arithmetic ! template<bool is_pointer_arithmetic, class Act, class A, class B> ! struct return_type_2_arithmetic_phase_1 ! { ! typedef typename ! return_type_2_arithmetic_phase_2< ! typename remove_reference_and_cv<A>::type, ! typename remove_reference_and_cv<B>::type ! >::type type; ! }; ! ! // pointer_arithmetic ! template<class Act, class A, class B> ! struct return_type_2_arithmetic_phase_1<true, Act, A, B> ! { ! typedef typename ! pointer_arithmetic_traits<Act, A, B>::type type; ! }; ! ! template<class A, class B> ! struct return_type_2_arithmetic_phase_2 { ! typedef typename ! return_type_2_arithmetic_phase_3< ! typename promote_to_int<A>::type, ! typename promote_to_int<B>::type ! >::type type; ! }; ! ! // specialization for unsigned int. ! // We only have to do these two specialization because the value promotion will ! // take care of the other cases. ! // The unsigned int promotion rule is this: ! // unsigned int to long if a long can hold all values of unsigned int, ! // otherwise go to unsigned long. ! ! // struct so I don't have to type this twice. ! struct promotion_of_unsigned_int ! { ! typedef ! detail::IF<sizeof(long) <= sizeof(unsigned int), ! unsigned long, ! long>::RET type; ! }; ! ! template<> ! struct return_type_2_arithmetic_phase_2<unsigned int, long> ! { ! typedef promotion_of_unsigned_int::type type; ! }; ! template<> ! struct return_type_2_arithmetic_phase_2<long, unsigned int> ! { ! typedef promotion_of_unsigned_int::type type; ! }; ! ! ! template<class A, class B> struct return_type_2_arithmetic_phase_3 { ! enum { promote_code_A_value = promote_code<A>::value, ! promote_code_B_value = promote_code<B>::value }; // enums for KCC ! typedef typename ! detail::IF< ! promote_code_A_value == -1 || promote_code_B_value == -1, ! detail::return_type_deduction_failure<return_type_2_arithmetic_phase_3>, ! typename detail::IF< ! ((int)promote_code_A_value > (int)promote_code_B_value), ! A, ! B ! >::RET ! >::RET type; ! }; ! ! } // namespace detail ! ! // -- bitwise actions ------------------------------------------- ! // note: for integral types deuduction is similar to arithmetic actions. ! ! // drop any qualifiers from the argument types within arithmetic action ! template<class A, class B, class Act> ! struct return_type_2<bitwise_action<Act>, A, B> ! { ! ! typedef typename boost::remove_reference<A>::type plain_A; ! typedef typename boost::remove_reference<B>::type plain_B; ! ! typedef typename ! plain_return_type_2<bitwise_action<Act>, plain_A, plain_B>::type type1; ! ! // if user defined return type, do not enter type deductions ! typedef typename ! detail::IF_type< ! boost::is_same<type1, detail::unspecified>::value, ! return_type_2<arithmetic_action<plus_action>, A, B>, ! plain_return_type_2<bitwise_action<Act>, plain_A, plain_B> ! >::type type; ! ! // plus_action is just a random pick, has to be a concrete instance ! ! // TODO: This check is only valid for built-in types, overloaded types might ! // accept floating point operators ! ! // bitwise operators not defined for floating point types ! // these test are not strictly needed here, since the error will be caught in ! // the apply function ! BOOST_STATIC_ASSERT(!(boost::is_float<plain_A>::value && boost::is_float<plain_B>::value)); ! ! }; ! ! namespace detail { ! ! #ifdef BOOST_NO_TEMPLATED_STREAMS ! ! template<class A, class B> ! struct leftshift_type { ! ! typedef typename detail::IF< ! boost::is_convertible< ! typename boost::remove_reference<A>::type*, ! std::ostream* ! >::value, ! std::ostream&, ! typename detail::remove_reference_and_cv<A>::type ! >::RET type; ! }; ! ! template<class A, class B> ! struct rightshift_type { ! ! typedef typename detail::IF< ! ! boost::is_convertible< ! typename boost::remove_reference<A>::type*, ! std::istream* ! >::value, ! std::istream&, ! typename detail::remove_reference_and_cv<A>::type ! >::RET type; ! }; ! ! #else ! ! template <class T> struct get_ostream_type { ! typedef std::basic_ostream<typename T::char_type, ! typename T::traits_type>& type; ! }; ! ! template <class T> struct get_istream_type { ! typedef std::basic_istream<typename T::char_type, ! typename T::traits_type>& type; ! }; ! ! template<class A, class B> ! struct leftshift_type { ! private: ! typedef typename boost::remove_reference<A>::type plainA; ! public: ! typedef typename detail::IF_type< ! is_instance_of_2<plainA, std::basic_ostream>::value, ! get_ostream_type<plainA>, //reference to the stream ! detail::remove_reference_and_cv<A> ! >::type type; ! }; ! ! template<class A, class B> ! struct rightshift_type { ! private: ! typedef typename boost::remove_reference<A>::type plainA; ! public: ! typedef typename detail::IF_type< ! is_instance_of_2<plainA, std::basic_istream>::value, ! get_istream_type<plainA>, //reference to the stream ! detail::remove_reference_and_cv<A> ! >::type type; ! }; ! ! ! #endif ! ! } // end detail ! ! // ostream ! template<class A, class B> ! struct return_type_2<bitwise_action<leftshift_action>, A, B> ! { ! typedef typename boost::remove_reference<A>::type plain_A; ! typedef typename boost::remove_reference<B>::type plain_B; ! ! typedef typename ! plain_return_type_2<bitwise_action<leftshift_action>, plain_A, plain_B>::type type1; ! ! // if user defined return type, do not enter type deductions ! typedef typename ! detail::IF_type< ! boost::is_same<type1, detail::unspecified>::value, ! detail::leftshift_type<A, B>, ! plain_return_type_2<bitwise_action<leftshift_action>, plain_A, plain_B> ! >::type type; ! }; ! ! // istream ! template<class A, class B> ! struct return_type_2<bitwise_action<rightshift_action>, A, B> ! { ! typedef typename boost::remove_reference<A>::type plain_A; ! typedef typename boost::remove_reference<B>::type plain_B; ! ! typedef typename ! plain_return_type_2<bitwise_action<rightshift_action>, plain_A, plain_B>::type type1; ! ! // if user defined return type, do not enter type deductions ! typedef typename ! detail::IF_type< ! boost::is_same<type1, detail::unspecified>::value, ! detail::rightshift_type<A, B>, ! plain_return_type_2<bitwise_action<rightshift_action>, plain_A, plain_B> ! >::type type; ! }; ! ! // -- logical actions ---------------------------------------- ! // always bool ! // NOTE: this may not be true for some weird user-defined types, ! template<class A, class B, class Act> ! struct plain_return_type_2<logical_action<Act>, A, B> { ! typedef bool type; ! }; ! ! template<class A, class B, class Act> ! struct return_type_2<logical_action<Act>, A, B> { ! ! typedef typename boost::remove_reference<A>::type plain_A; ! typedef typename boost::remove_reference<B>::type plain_B; ! ! typedef typename ! plain_return_type_2<logical_action<Act>, plain_A, plain_B>::type type; ! ! }; ! ! ! // -- relational actions ---------------------------------------- ! // always bool ! // NOTE: this may not be true for some weird user-defined types, ! template<class A, class B, class Act> ! struct plain_return_type_2<relational_action<Act>, A, B> { ! typedef bool type; ! }; ! ! template<class A, class B, class Act> ! struct return_type_2<relational_action<Act>, A, B> { ! ! typedef typename boost::remove_reference<A>::type plain_A; ! typedef typename boost::remove_reference<B>::type plain_B; ! ! typedef typename ! plain_return_type_2<relational_action<Act>, plain_A, plain_B>::type type; ! }; ! ! // Assingment actions ----------------------------------------------- ! // return type is the type of the first argument as reference ! ! // note that cv-qualifiers are preserved. ! // Yes, assignment operator can be const! ! ! // NOTE: this may not be true for some weird user-defined types, ! ! template<class A, class B, class Act> ! struct return_type_2<arithmetic_assignment_action<Act>, A, B> { ! ! typedef typename boost::remove_reference<A>::type plain_A; ! typedef typename boost::remove_reference<B>::type plain_B; ! ! typedef typename ! plain_return_type_2< ! arithmetic_assignment_action<Act>, plain_A, plain_B ! >::type type1; ! ! typedef typename ! detail::IF< ! boost::is_same<type1, detail::unspecified>::value, ! typename boost::add_reference<A>::type, ! type1 ! >::RET type; ! }; ! ! template<class A, class B, class Act> ! struct return_type_2<bitwise_assignment_action<Act>, A, B> { ! ! typedef typename boost::remove_reference<A>::type plain_A; ! typedef typename boost::remove_reference<B>::type plain_B; ! ! typedef typename ! plain_return_type_2< ! bitwise_assignment_action<Act>, plain_A, plain_B ! >::type type1; ! ! typedef typename ! detail::IF< ! boost::is_same<type1, detail::unspecified>::value, ! typename boost::add_reference<A>::type, ! type1 ! >::RET type; ! }; ! ! template<class A, class B> ! struct return_type_2<other_action<assignment_action>, A, B> { ! typedef typename boost::remove_reference<A>::type plain_A; ! typedef typename boost::remove_reference<B>::type plain_B; ! ! typedef typename ! plain_return_type_2< ! other_action<assignment_action>, plain_A, plain_B ! >::type type1; ! ! typedef typename ! detail::IF< ! boost::is_same<type1, detail::unspecified>::value, ! typename boost::add_reference<A>::type, ! type1 ! >::RET type; ! }; ! ! // -- other actions ---------------------------------------- ! ! // comma action ---------------------------------- ! // Note: this may not be true for some weird user-defined types, ! ! // NOTE! This only tries the plain_return_type_2 layer and gives ! // detail::unspecified as default. If no such specialization is found, the ! // type rule in the spcecialization of the return_type_2_prot is used ! // to give the type of the right argument (which can be a reference too) ! // (The built in operator, can return a l- or rvalue). ! template<class A, class B> ! struct return_type_2<other_action<comma_action>, A, B> { ! ! typedef typename remove_reference<A>::type plain_A; ! typedef typename remove_reference<B>::type plain_B; ! ! typedef typename ! plain_return_type_2< ! other_action<comma_action>, plain_A, plain_B ! >::type type; ! }; ! ! // subscript action ----------------------------------------------- ! ! ! namespace detail { ! // A and B are nonreference types ! template <class A, class B> struct subscript_type { ! typedef detail::unspecified type; ! }; ! ! template <class A, class B> struct subscript_type<A*, B> { ! typedef A& type; ! }; ! template <class A, class B> struct subscript_type<A* const, B> { ! typedef A& type; ! }; ! template <class A, class B> struct subscript_type<A* volatile, B> { ! typedef A& type; ! }; ! template <class A, class B> struct subscript_type<A* const volatile, B> { ! typedef A& type; ! }; ! ! ! template<class A, class B, int N> struct subscript_type<A[N], B> { ! typedef A& type; ! }; ! ! // these 3 specializations are needed to make gcc <3 happy ! template<class A, class B, int N> struct subscript_type<const A[N], B> { ! typedef const A& type; ! }; ! template<class A, class B, int N> struct subscript_type<volatile A[N], B> { ! typedef volatile A& type; ! }; ! template<class A, class B, int N> struct subscript_type<const volatile A[N], B> { ! typedef const volatile A& type; ! }; ! ! } // end detail ! ! template<class A, class B> ! struct return_type_2<other_action<subscript_action>, A, B> { ! ! typedef typename remove_reference<A>::type plain_A; ! typedef typename remove_reference<B>::type plain_B; ! ! typedef typename boost::remove_reference<A>::type nonref_A; ! typedef typename boost::remove_reference<B>::type nonref_B; ! ! typedef typename ! plain_return_type_2< ! other_action<subscript_action>, plain_A, plain_B ! >::type type1; ! ! typedef typename ! detail::IF_type< ! boost::is_same<type1, detail::unspecified>::value, ! detail::subscript_type<nonref_A, nonref_B>, ! plain_return_type_2<other_action<subscript_action>, plain_A, plain_B> ! >::type type; ! ! }; ! ! ! } // namespace lambda ! } // namespace boost ! ! ! // Forward declarations are incompatible with the libstdc++ debug mode. ! #if BOOST_WORKAROUND(__GNUC__, >= 3) && defined(_GLIBCXX_DEBUG) ! #include <string> ! #include <vector> ! #include <map> ! #include <deque> ! #else ! ! // The GCC 2.95.x uses a non-conformant deque ! #if BOOST_WORKAROUND(__GNUC__, == 2) && __GNUC_MINOR__ <= 96 ! #include <deque> ! #else ! ! namespace std { ! template <class T, class Allocator> class deque; ! } ! ! #endif ! ! namespace std { ! template <class Char, class Traits, class Allocator> class basic_string; ! template <class T, class Allocator> class vector; ! template <class Key, class T, class Cmp, class Allocator> class map; ! template <class Key, class T, class Cmp, class Allocator> class multimap; ! } ! ! #endif ! ! ! namespace boost { ! template <class T, std::size_t N> class array; ! } ! ! ! namespace boost { ! namespace lambda { ! ! template<class Key, class T, class Cmp, class Allocator, class B> ! struct plain_return_type_2<other_action<subscript_action>, std::map<Key, T, Cmp, Allocator>, B> { ! typedef T& type; ! // T == std::map<Key, T, Cmp, Allocator>::mapped_type; ! }; ! ! template<class Key, class T, class Cmp, class Allocator, class B> ! struct plain_return_type_2<other_action<subscript_action>, std::multimap<Key, T, Cmp, Allocator>, B> { ! typedef T& type; ! // T == std::map<Key, T, Cmp, Allocator>::mapped_type; ! }; ! ! // deque ! template<class T, class Allocator, class B> ! struct plain_return_type_2<other_action<subscript_action>, std::deque<T, Allocator>, B> { ! typedef typename std::deque<T, Allocator>::reference type; ! }; ! template<class T, class Allocator, class B> ! struct plain_return_type_2<other_action<subscript_action>, const std::deque<T, Allocator>, B> { ! typedef typename std::deque<T, Allocator>::const_reference type; ! }; ! ! // vector ! template<class T, class Allocator, class B> ! struct plain_return_type_2<other_action<subscript_action>, std::vector<T, Allocator>, B> { ! typedef typename std::vector<T, Allocator>::reference type; ! }; ! template<class T, class Allocator, class B> ! struct plain_return_type_2<other_action<subscript_action>, const std::vector<T, Allocator>, B> { ! typedef typename std::vector<T, Allocator>::const_reference type; ! }; ! ! // basic_string ! template<class Char, class Traits, class Allocator, class B> ! struct plain_return_type_2<other_action<subscript_action>, std::basic_string<Char, Traits, Allocator>, B> { ! typedef typename std::basic_string<Char, Traits, Allocator>::reference type; ! }; ! template<class Char, class Traits, class Allocator, class B> ! struct plain_return_type_2<other_action<subscript_action>, const std::basic_string<Char, Traits, Allocator>, B> { ! typedef typename std::basic_string<Char, Traits, Allocator>::const_reference type; ! }; ! ! template<class T, int N, class B> ! struct return_type_2<other_action<subscript_action>, boost::array<T, N>, B> { ! typedef typename boost::array<T, N>::reference type; ! }; ! template<class T, int N, class B> ! struct return_type_2<other_action<subscript_action>, const boost::array<T, N>, B> { ! typedef typename boost::array<T, N>::const_reference type; ! }; ! ! ! // -- plus_action for basic_string ----------------------------------------------------------------- ! template<class Char, class Traits> ! struct plain_return_type_2<arithmetic_action<plus_action>, std::basic_string<Char, Traits>, std::basic_string<Char, Traits> > { ! typedef std::basic_string<Char, Traits> type; ! }; ! // -- pointer versions ----------------------------------------------------------------------------- ! template<class Char, class Traits> ! struct plain_return_type_2<arithmetic_action<plus_action>, std::basic_string<Char, Traits>, Char*> { ! typedef std::basic_string<Char, Traits> type; ! }; ! template<class Char, class Traits> ! struct plain_return_type_2<arithmetic_action<plus_action>, std::basic_string<Char, Traits>, const Char*> { ! typedef std::basic_string<Char, Traits> type; ! }; ! template<class Char, class Traits> ! struct plain_return_type_2<Char*, arithmetic_action<plus_action>, std::basic_string<Char, Traits> > { ! typedef std::basic_string<Char, Traits> type; ! }; ! template<class Char, class Traits> ! struct plain_return_type_2<const Char*, arithmetic_action<plus_action>, std::basic_string<Char, Traits> > { ! typedef std::basic_string<Char, Traits> type; ! }; ! // -- array versions --------------------------------------------------------------------------------- ! template<class Char, class Traits, int N> ! struct plain_return_type_2<arithmetic_action<plus_action>, std::basic_string<Char, Traits>, Char[N]> { ! typedef std::basic_string<Char, Traits> type; ! }; ! template<class Char, class Traits, int N> ! struct plain_return_type_2<arithmetic_action<plus_action>, std::basic_string<Char, Traits>, const Char[N]> { ! typedef std::basic_string<Char, Traits> type; ! }; ! template<class Char, class Traits, int N> ! struct plain_return_type_2<Char[N], arithmetic_action<plus_action>, std::basic_string<Char, Traits> > { ! typedef std::basic_string<Char, Traits> type; ! }; ! template<class Char, class Traits, int N> ! struct plain_return_type_2<const Char[N], arithmetic_action<plus_action>, std::basic_string<Char, Traits> > { ! typedef std::basic_string<Char, Traits> type; ! }; ! ! ! } // namespace lambda ! } // namespace boost ! ! #endif ! !"
"Hello. After latest cvs update, i've got errors like: gcc-C++-action bin\boost\libs\thread\build\boost_thread.dll\mingw\debug\threading-multi\con dition.obj In file included from d:/sources/boost/libs/thread/src/condition.cpp:18: d:/sources/boost/libs/thread/src/timeconv.inl: In function `void <unnamed>::to_time(int, boost::xtime&)': d:/sources/boost/libs/thread/src/timeconv.inl:24: error: template-argument ` boost::<anonymous enum>' uses anonymous type d:/sources/boost/libs/thread/src/timeconv.inl: In function `void <unnamed>::to_duration(boost::xtime, int&)': d:/sources/boost/libs/thread/src/timeconv.inl:92: error: template-argument ` boost::<anonymous enum>' uses anonymous type d:/sources/boost/libs/thread/src/timeconv.inl: In function `void <unnamed>::to_microduration(const boost::xtime&, int&)': d:/sources/boost/libs/thread/src/timeconv.inl:114: error: template-argument ` boost::<anonymous enum>' uses anonymous type "g++" -c -Wall -ftemplate-depth-100 -DBOOST_THREAD_BUILD_DLL=1 -g -O0 -f no-inline -mthreads -mthreads -mno-cygwin -I"bin\boost\libs\thread\build" -I"d:\sources\boost" -o "bin\boost\libs\thread\build\boost_thread.dll\mingw\debug\threading-multi\co ndition.obj" "d:\sources\boost\libs\thread\build\../src/condition.cpp" Error lines in timeconv.inl file contains: assert(res == boost::TIME_UTC) where res is int, and boost::TIME_UTC is enum. When i changed it to assert(res == static_cast<int>(boost::TIME_UTC)); it starts to compile. But I don't understand what's happend, there aren't changes in boost::thread. Any ideas? WinXP, mingw 3.3.1 Regards, Janusz"
"Johan Råde wrote: > > Take a look at the Boost Property Tree library. > It contains a very basic XML parser. > It will be part of Boost 1.34 and is available in the Boost Vault. Funny, I was just wondering about that yesterday. Boost.Property Tree isn't available in the RC_1_34_0 branch (at least not yet) and doesn't show up in the regression tests. // Johan (Nilsson)"
""Peter Dimov" <pdimov_at_[hidden]> writes: > From: "David Abrahams" <dave_at_[hidden]> > >> I realize my case is somewhat unusual. I can't really argue that it >> warrants publicizing deleter introspection for >> everybody... however, since we're all part of a big happy Boost >> family and I /could/ always switch to a map if the shared_ptr >> implementation changes, how bad would it be for me to use my hack? > > There isn't anything bad. What I really ask is your opinion on > whether get_deleter<> should be proposed for the TR, i.e. whether > the technique of storing private data in shared_ptr deleters and > then getting it back when you happen to encounter one of your > shared_ptrs is of general utility, considering that a general > alternative (map<weak_ptr<void>, Data>) exists. I think that considering the alternatives require: 1. Periodic map sweeps (we might as well be doing GC ;->), or 2. Solving the constructor forwarding problem for tacking on additional data to the pointed-to class IMO it's worth giving serious consideration to deleter introspection. It seems like a fairly general class of problem to want to find out the actual resource that is being managed by a given shared_ptr. -Dave"
"> From: boost-bounces_at_[hidden] > [mailto:boost-bounces_at_[hidden]] On Behalf Of Darren Cook I'll go into this in more detail: > I've been reviewing some code [1], and wondered if there was > something in > Boost to save having to write out the convenience functions > by hand. It > seems the Preprocessor library is what I need, but after > reading the docs > I'm confused as to how to go about using it. The library is effectively a programming language. There is no simple answer for the question "how to use it." However, there are examples that use the library to do various things, but they, by no means, cover the gamut of possible uses. Hence, the documentation on each element of the library shows what each element of the library can do (there are many). How you put those together is up to you. However, the learning curve is inherent--just as it is with any programming language. You have to get to know (at least some of) the language through experimentation before you can use it to solve your real problems. > Here is some (hopefully constructive) feedback on the docs, > ranging from > important to petty: > > 1. /libs/preprocessor/doc/index.html > There is no explanation or introductory text. In fact I > looked at this > page and thought the docs had not been written yet and just > the headers and > been placed ready. But just to see if it was a Mozilla issue > I checked the > source and discovered the they were actually links. Specifics: This is the what the documentation needs most--an introductory text. > a) Use conventional blue for links > b) Explain what will be found in each section, even > with just a sentence. > c) Paragraph at the top of this page explaining what > the preprocessor > library is. A relatively primitive and strange programming language built atop Cpp. :) > 2. /libs/preprocessor/doc/topics.html > Should use same layout style as first page (i.e. first > page is black > text, this page is grey text with bullets; needs consistency). > > 3. Generally for HTML titles, I think > "Boost.Preprocessor:Topics" is > better than "topics.html". It does have a consistent layout and style. Both of these two issues are the result of viewing the page outside of the frame where it normally goes. This is fine and doesn't harm anything, but then you get the title issue and the style may not appear as uniform. > 4. /libs/preprocessor/doc/topics/motivation.html. In the > "The Motivation > Example Revisited" section I wanted to know: > a) What feature each of the three headers is loading in. <inc.hpp> brings in BOOST_PP_INC, <comma_if.hpp> brings in BOOST_PP_COMMA_IF, and <repetition.hpp> brings in BOOST_PP_REPEAT and BOOST_PP_ENUM_PARAMS. These things should be self-evident though. > b) A breakdown of what each line is doing (or links to > the reference > docs for each Boost macro used) Yes. > c) If "MAX_IS_FUNCTION_TESTER_PARAMS" is required, or > if 15 can be > directly embedded, e.g.: > BOOST_PP_REPEAT(BOOST_PP_INC(15), IS_FUNCTION_TESTER, _) Yes, it can be. However, the intent is to make the code expand to some arity specified elsewhere as a configuration option. MAX_IS_FUNCTION_TESTER_PARAMS is just used for a default value. > If the example had been built up in two or three steps > it would have > helped (I don't understand the library enough to know if any > intermediate > steps are possible however). There isn't much to the example. Especially if you look at the reference documentation for each primitive used--they are pretty straightforward. The library is simply too large to explain the meaning of everything used in examples inline. The intent of the example here is not to show how to do XYZ, but rather to show that XYZ can be done. > 5. /libs/preprocessor/doc/topics/incompatible.html > Refers to 1.28 as the previous release. Maybe this page > can be dropped now? Yes, probably. > 6. /libs/preprocessor/doc/topics/techniques.html > This page badly needs an introductory paragraph stating > what it is all > about. I assumed it was going to show me the various ways you > can use the > library to simplify your code. But it is defining macros that > start with > "BOOST_" so is this explaining how the library was written? This is an artifact from before my time. BOOST_PP_DEF is used as some arbitrary user-defined macro. Personally, I don't think anyone should ever define BOOST_PP_ prefixed macros unless it is specifically required by a library element. Also, I don't recommend using all-caps identifiers for *temporary* macro names--using all-caps here actually *increases* the likelihood of a name conflict. > The second example is supposed to show use of > "BOOST_PP_EMPTY" but the > example only uses (well, defines, not uses) BOOST_PP_DEF. I thought I fixed this one already. E.g. the idea is: #define MACRO(id, cv_qualifier) cv_qualifier() int id; MACRO(x, const BOOST_PP_EMPTY) // const int x; MACRO(y, BOOST_PP_EMPTY) // int y; > It would be helpful if all examples showed the code that > they generated > so the two can be compared side by side. Maybe in some cases, but the documentation also needs to encourage experimentation. There are literally hundreds of examples in the documentation. > 7. The reference page is intimidating - can it be broken > down into sections? I assume that you're referring the index of macros. It could be broken down a little bit, but that would decrease its utility. (It's just an alphabetical index of library primitives.) The headers section is broken down in a more logical fashion (though it is also a reference-like section). > 8. I think my comments for 4, 6, and 7 are because there > is no page that > leads me from "here is my old code" to "here is how you'd use > this library > to rewrite it". That is because the library is a programming language. It is not a simplistic input -> output tool--the primitives are too low-level for that. There is a learning curve, and there is a degree of lateral thinking involved. However, the library is powerful (despite the fact that it has its hands tied by buggy--but popular--preprocessors), but the learning process is not a simple sequence of linear steps. It isn't overly difficult to learn either. (I know because I did it myself at one point.) If you want to learn it, go through all of the macros in the reference section and experiment with them. This will give you a good idea of what's in the library and what you can do with it. It will also give you a degree of familiarity that just reading documentation won't. That degree of familiarity is the foundation for the lateral thinking required to actually solve real problems in the future rather than toy examples used to experiment. That said, the documentation definitely needs improvement. The most important things that it needs are a simple introductory section and a general outline of what broad categories of facilities are available. (I have a big list of improvements that I need to make.) Regards, Paul Mensonides"
""Gabriel Dos Reis" <gdr_at_[hidden]> wrote in message news:m34r7rvovp.fsf_at_uniton.integrable-solutions.net... > [...] > There is no formal vote about these thingies yet. Well, I just wanted to know what the most popular opinion was, and you give some interesting info here. > [...] > template<typename T> > Vec = std::vector<T, MyAlloc<T> >; This looks cool! Is someone going to write a proposal for this before April? Or does this type of change not get considered at that time? > [...] > Oh well, I believe we're very far from any actual definitive form of > "template typedef" or "template aliasing". Well, I thought Herb's proposal was more or less "definitive". Is that not what's likely to be presented to the committee? If we got template aliasing as you describe above, then Herb's proposal is just fine with me. Dave"
"On Thu, 6 Jul 2006 14:27:57 +0300, "Peter Dimov" <pdimov_at_[hidden]> wrote: >I know. Is this a real problem? Well, doesn't seem false to me :) >Are you sure that making BOOST_ASSERT fail >when assert works a good idea? It happens to work, and relies on undefined behavior. I think it's a good idea to catch that. > It will just encourage people to not use it. >Not that they need much encouragement. Almost everyone ignores BOOST_ASSERT >(and the users' requests to please not do so). I'll assume you mean "not to ignore". Well, all I can promise is that I'll change all asserts in dynamic_bitset to BOOST_ASSERT. I can't do more, sorry. While we are at it, I've never liked too much the idea to switch off (or on) all asserts from any boost library. I would often desire a higher degree of control; one thing I can imagine is passing type information to assertion_failed(), so that I can see what library the assert is coming from and decide what to do with that."
"John Maddock wrote: >> I also see a gcc crash in the test "array_constexpr": >>[...] >> More as I find it out. ;-) > > Just so you know, this is causing all the C++0x mode Boost.Math tests to > fail currently. The "array_constexpr" test runs fine on g++-4.8.0-20130203 (and clang). I also tried some Boost.Math examples, but they failed on g++-4.8 (and ran successfully on clang). Regards, Michel"
"> Joaquín Mª López Muñoz wrote: . . . > Good question. I should have explained of course. > Well vacpp has only in some circurmstances a problem with the in class > member initialization. For instance following does not work (confirmed > by IBM): > > class A > { > public: > static const int value = true ; > } ; > > int main() > { > int v1 = A::value ; // does work > bool v2 = A::value ; // does not work > return 0 ; > } ; Hello, I know i argue with eminent C++ specialists in this group, but i think the code above is not correct. To my best knowledge even with the inclass line static const int value = true ; you have to give a definition outside of the class: int A::value; Apart from that return 0; should be unnecessary and there is a spurious semicolon after the last brace; Greetings Franz"
"Hi all, I'm currently working through your reviews (much to be done ;-) and just encountered the issue of namespace, file and macro names. The following seems to be boost's consensus in my understanding: a) Namespace The current CVS path of ublas in boost is /boost/numeric/ublas /libs/numeric/ublas and the current namespace is boost::numerics <- !!! I've already been advised to unify these in the past. So I'm going to use /boost/numeric/ublas /libs/numeric/ublas as paths and boost::numeric::ublas as namespace. b) File names I'm going to change file names to the usual .hpp extension, eliminate abbreviations (e. g. matrix_as.h -> matrix_assign.hpp, matrix_et.h -> matrix_expression.hpp, matrix_pr.h -> matrix_proxy.hpp, matrix_sp.h -> matrix_sparse.hpp) and fix the hermitian spelling. c) Macro names For readability I'd prefer to use BOOST_UBLAS as macro prefix instead of BOOST_NUMERIC_UBLAS. Any objections? Joerg"
"2013/3/13 Christian Henning <chhenning_at_[hidden]> > On Wed, Mar 13, 2013 at 4:53 PM, Andrew Hundt <athundt_at_[hidden]> wrote: > > I've been using gil for about 2 years now, and it appears the only > > development being done on the library itself is being done by Christian > > Henning in the io_library and some of the extensions he has created, in > > addition to some minor fixes. I think his latest is at: > > https://code.google.com/p/gil-contributions/ > > The latest is on the boost trunk. Christian, you mean the io extension, do you? I don't see numeric in trunk. > The new io extension will be > released either with 1.53 or 1.54. I have been travelling and I might > have missed the deadline to include gil::io into the release branch. > Need to check with the release team. > > I accordance with the original creators we have decided that I'm the > official maintainer. > I also have some comments about point2 from gil/utilities.hpp: {{{ template <typename T> class point2 { public: [...] //--- these 3 functions don't add anything, do they? why not remove them rely on defaults? point2(const point2& p) : x(p.x), y(p.y) {} ~point2() {} point2& operator=(const point2& p) { x=p.x; y=p.y; return *this; } [...] point2& operator/=(double t) { x/=t; y/=t; return *this; } T x,y; [...] }; [...] template <typename T> GIL_FORCEINLINE point2<double> operator/(const point2<T>& p, double t) { return t==0 ? point2<double>(0,0):point2<double>(p.x/t,p.y/t); } /// \ingroup PointModel template <typename T> GIL_FORCEINLINE point2<T> operator*(const point2<T>& p, std::ptrdiff_t t) { return point2<T>(p.x*t,p.y*t); } /// \ingroup PointModel template <typename T> GIL_FORCEINLINE point2<T> operator*(std::ptrdiff_t t, const point2<T>& p) { return point2<T>(p.x*t,p.y*t); } }}} So point2 has miltiplication by ptrdiff_t, and division by double. This was very confusing for me - that multiplying point2<double> by 0.5 gave me point2(0,0). But this probably is as it is for a reason, so I'm not sure if my idea for fixing this is the right way to go: I'd just add * and / for point2<T> and T, and add multiplication by double. I'd be happy to try to implement this change with some tests, if you think it's the right way to go ;-) Cheers, Kris"
">> You missed out the error message! > > Just warnings and no error message. > >> But again, does the current version >> have the same failure? > > The current version has similar failures. I don't see an error message > with the failures in either the current version or the version2 version > for gcc-3.4.5, just lots of warnings with "...failed gcc.compile.c++ ... > " messages. Are the type_traits tests set to fail if any warnings occur ? Ah yes, it has warnings-as-error turned on. >> There are out of date mentions in the docs - it all needs a *lot* of >> revising. > > I could not find any mention of compiler requirements in the type_traits > docs, much less out of date mentions, other than in the topic "Support > for Compiler Intrinsics". Each trait should list what compiler features it requires for correct functionality. John."
"Vesa Karvonen wrote: > I'm thinking of submitting a small CPP or C Pre Processor > meta programming library into Boost. For this reason I have > uploaded a trivial demo subset of the library into the Files > section/Vault. You can find the files under the CPP folder. > The rest of this message contains a motivated example of the > use of a particular feature of the library. Funny, I've been using something like this for about half a year too. First time I saw a simple example of the technique in the Lambda library (LL_REPEAT, IIRC), and extending it to handle self-referential situations was trivial :). Actually, if you look at 'boost::mpl' library headers (http://groups.yahoo.com/group/boost/files/mpl/mpl-apr-28-01.zip), you'll find a few examples of the technique applied as well: // from 'mpl/switch_on.hpp' template<typename T, BOOST_MPL_ENUMERATE_DEFAULT_PARAMS(class C, null_argument)> struct switch_on : mpl::detail::switch_impl< T, mpl::type_list<BOOST_MPL_ENUMERATE_PARAMS(C)> >::result_type { }; // from 'mpl/list/factory.hpp' #define BOOST_MPL_LIST_FACTORY_SPEC(N) \ template<> \ struct list_factory_part1<N> \ { \ template<class Tag, BOOST_MPL_ENUMERATE_PARAMS(typename T)> \ struct part2 \ { \ typedef BOOST_MPL_ENUMERATE_N(N \ , typename mpl::list_traits<Tag>::template make_node<T) \ , typename mpl::list_traits<Tag>::null_node BOOST_MPL_REPEAT_N(N \ , >::type) type; \ }; \ }; BOOST_MPL_ENUMERATE_USER_MACROS(BOOST_MPL_, LIST_FACTORY_SPEC) and a couple of others. The macros themselves are in the 'mpl/enumeration_macros.hpp' and 'mpl/basic_macros.hpp' headers. Two-part naming of the enumerated macro ("BOOST_MPL_, LIST_FACTORY_SPEC") is a (historical) implementation artifact, but the rest is more or less equivalent to your BOOST_LST0 and BOOST_LST1 approach, except that the names of these are much longer - BOOST_MPL_ENUMERATE_MACRO_CALLS and BOOST_MPL_ENUMERATE_USER_MACROS respectively :). Well, actually there are some differences in techniques, but IMO they are rather minor. I would like to see both approaches merged into something simple and elegant that would become an official boost library :). **************** An aside note: Besides 'boost::mpl', I've been using the technique a lot in other projects, and I find it a really useful alternative to external code generation/preprocessing. However, as others already mentioned, it has its own problems, and the main source of those is that the technique is still preprocessor-based. It would be really great to have the language to support compile-time type lists in template parameters and function signatures, so instead of template<typename R, ENUMERATE_ARGUMENTS_N(10, typename T)> inline function< R, ENUMERATE_ARGUMENTS_N(10, T) > make_function(R (*f)( ENUMERATE_ARGUMENTS_N(10, T) )) { return function2<R, ENUMERATE_ARGUMENTS_N(10, T)>(f); } one could write something like this: template<typename R, typename[10] Ts> inline function< R, Ts> make_function(R (*f)(Ts) { return function2<R, Ts>(f); } Of course, something like the above requires a core language change (if someone writes a proposal :), and that won't happen any time soon (if ever), so IMO the discussed library has its place here. Aleksey"
">I am using VC6SP5 and Boost version 1.24.0. Here is the test code that I am >using: You really had me worried for a time there - you are passing regex compile flags to the match flags (they are different things) you should use: int main(void) { boost::regex e(".*Test.*", FLAGS); boost::cmatch m; if(regex_match("A Test", m, e)) { cout << "matched \"A Test\"" << endl; } if(regex_match("Testing 123", m, e)) { cout << "matched \"Testing 123\"" << endl; } if(regex_match("foo", m, e)) { cout << "matched \"foo\"" << endl; } return(true); } - John Maddock http://ourworld.compuserve.com/homepages/john_maddock/"
"--- Eric Niebler wrote: > The download counters for xpressive.zip and > foreach.zip dropped to 1 for some reason. I seem to recall > this happening before. There seems to be some bug wrt the > download counters -- possible some race condition? The counter for mpl_math.zip dropped to nil. Cromwell D. Enage __________________________________________ Yahoo! DSL – Something to write home about. Just $16.99/mo. or less. dsl.yahoo.com"
"From: "David Abrahams" <dave_at_[hidden]> > #1 shared_ptr<Base> when there's no _accessible_ ~Base, to prevent > deletion; > #2 Template parameter being an incomplete type at destruction time; > #3 Using shared_ptr<void> to retain ownership but strip type information > (similar to void*); > #4 Encapsulating allocation details via custom deallocators; > #5 Passing shared_ptr's across EXE/DLL boundaries that use different heaps. > > #2 and #4 both require the addition of the custom deallocator, right? Hmm. I _think_ that #2 doesn't require a deallocator to be instantiated, although #5 does. > Most compilers will do #5 correctly if the destructor is virtual, right? Right. > BTW, implementation notions: > > 1. Should we think about optimizing away storage for the deleter when it's > known to be stateless? We might, although I'm not convinced that it's worth it. > 2. Should we think about avoiding vtbl bloat a la boost::function? What does "vtbl bloat" mean?"
"Hi Andrew, Andrew Hundt wrote: > I like the style and how they are more low profile when they are carved out > as white. I also think it is good that boost is a bit smaller than the > library name. For the icons themselves I would change a couple of the ones > that look like they could easily apply to something else. > Here are my thoughts on each icon: > > 1. array - What about something like a solar panel look or some other > analogous array of physical material or objects? The current one looks a > bit like a dotted line. I like this one: http://en.wikipedia.org/wiki/Very_Large_Array ;) There are more variants in array.svg / png but I don't like any of them. I just picked the best IMO. So if you have some idea it definietly should be tested. > 2. atomic - I like that one, did you also consider the classic atom > symbol? This one is public domain and could be applied once the colors are > swapped: http://www.clker.com/clipart-atom-1.html Sure may look ok. > 3. bimap - seems good If there were existing logos I wanted to use some key elements from them. > 4. bind - nice Just needs polishing. > 5. boost book - love it Yes, I like it too. Taken from the original logo. > 6. build - I guess this is the existing logo, but I would like if this > was the container logo better. Check build.png > 7. circular buffer - love it > 8. config - I know a gear is frequently used for configuration, but > perhaps it should be saved for something that is for run time configuration > rather than compile time? Yes, I know what you mean. Some switches, control lights? > 9. container - perhaps it could be a simple treasure chest outline? The > current one looks like it would be for a build system. Yes it's a good idea, however I'd prefer more industrial chest. Check also container.png (connected dots - a metaphor for a list). > 10. function - I like it > 11. fusion - love it I just thought that one ball could be some different shape, e.g. a square or triangle becasue it's a fusion of two different things. > 12. geometry - nice, I wonder what would a simplified boost logo in a > boost logo would look like for this? Hmm, worth trying. > 13. inspect - magnifying glass is frequently used for search, though I > don't have an alternative idea off hand. A magnifying glass on a Inspector Gadget's remote arm ;) > 14. lock free - lock is frequently used for security, perhaps an open > door? Door means 'exit' to me. It could be something which is related to some kind of synchronization (or rather the lack of it), like disabled stop lights or opened rail-semaphore. > 15. log - ok but not inspiring, perhaps there is a good way to capture > streams aka arrows going into a drive, container, or that stack of > cylinders that is sometimes used to represent data storage? This is more suitable for serialization. But I can make it more complex, e.g. add a writing board. > 16. MPL - I like it > 17. numeric conversion - what if the arrows were made a little smaller > and there was a 2.0 on one end and a 2 on the other? Good idea! We have also Conversion (could have only arrows, probably different shape) and LexicalCast (with letters). > 18. polygon - why not a simplified version of one of those nice shapes > in the polygon documentation? This supposed to be a fragment of voronoi diagram ;) Sure, we can for sure choose some picture which will look nice but it musn't be too complicated. > 19. program options - this is decent, what about literally putting the > text "--po" sans quotes there in the boost font? That would capture it 100% > unambiguously Sure. > 20. SmartPtr - It is good > 21. static assert - not as enthusiastic about this one. perhaps an > exclamation mark alone or an exclamation mark with sparks aka static? Yes, this is nice idea. > 22. test - fair enough, it clicks Also taken from the old logo ;) > 23. tuple - nice, but needs to be better distinguished from variant > 24. unordered - what about the numbers 1,3,2 in little boxes? I'd also scatter them, they could look nice. > 25. utility - the standard utility logo works for me > 26. variant - I would change this to distinguish it from tuple, maybe a > circle in a box and a triangle in a box? Yes this probably also needs some changes. We must remember that we also have Any which is more or less similar. Well Variant is an alternative for dynamic polimorphism so maybe something related to that? > By the way what tool do you use to make those? Inkscape If you like to play with it I can give you access to the repo. As I've said, more versions can be found in separate files. Since the final decision should be made by libraries authors/maintainers I'd like to hear what they think about it. Regards, Adam"
"On 03/15/2016 09:07 PM, Glen Fernandes wrote: > On Tue, Mar 15, 2016 at 8:58 PM, Phil Bouchard <philippeb8_at_[hidden]> wrote: >> >> Yes you're right. I need to make my references const. >> > [snip] >> >> Thanks for the clarifications. > > No problem. Remember the goal isn't to provide convoluted interfaces > that are strange to people who are used to a simpler convention > established in the C++ standard library (or Boost, or any other > library that supports C++ allocator concepts). > > The Allocator class template in the example you have is a valid C++ > stateful allocator. Observe how it is used with existing C++ standard > library facilities that are allocator aware: > > int c1 = 0, c2 = 0; > > vector<char, Allocator<char> > v(Allocator<char>(c1, c2)); > > list<int, Allocator<int> > l(Allocator<int>(c1, c2)); > > function<void(int)> f(allocator_arg, Allocator<void>(c1, c2), [](int){ }); > > auto p = allocate_shared<double>(Allocator<double>(c1, c2), 1.5); > > With your root_ptr, the interface for creation should be equally > simple. No temporaries required. No extremely long type definitions > required. And certainly no expressions that look like: new > (temporary) Type(temporary, ...) (i.e. an expression that looks like > 'temporary' is both the subject of the placement-new and an argument > to the constructor of Type). I'm still working on it but right now I have already simplified the syntax, by adding a wrapper function, to: int main() { int n1 = 0, m1 = 0; int n2 = 0, m2 = 0; { typedef boost::node<U, Allocator<U> > node; boost::root_ptr<U> p1, p2, p3; node::allocator_type a1(n1, m1); node::allocator_type a2(n2, m2); node::allocator_type a3(n2, m2); p1 = node::allocate(a1, 1, 'a'); p2 = node::allocate(a2, 2, 'b'); p3 = node::allocate(a3, 3, 'c'); if (n1 != 1 || m1 != 1 || n2 != 2 || m2 != 2) { throw 3; } } if (n1 != 0 || m1 != 0 || n2 != 0 || m2 != 0) { throw 4; } } -Phil"
"Phil Endecott wrote: > There are some good instructions at > http://beta.boost.org/doc/libs/1_34_1/more/getting_started/unix-variants.html, > section 5.1 "Easy Build and Install". That's for 1.34.1, and I've just > been on a wild goose chase looking for the 1.35 equivalent. I can't > find it at beta.boost.org, but I recall reading something here about > the "more" content and beta.boost.org, so I won't revisit that. In the > download, it seems to be in more/getting_started. That took me a > _long_ time to find: I was doing all sorts of greps in the doc > directory. Where the two links to the getting started docs not obvious from the boost-root/index.html file? Or is it the boost-root/index.html file itself? > Can't more be a subdir of doc? Or can't getting_started > just live in doc? Having a bulging doc directory and then stashing the > first documentation that you're going to need somewhere else just seems > calculated to confuse. True, but only if you are browsing around the files without reading the "front" page. Although integrating the getting started docs with the BoostBook docs is worth looking into."
"On Aug 2, 2012, at 3:17 AM, Olaf van der Spek <ml_at_[hidden]> wrote: > On Thu, Aug 2, 2012 at 2:36 AM, Daniel Larimer <dlarimer_at_[hidden]> wrote: >> I have been increasingly frustrated with how long it takes to compile c++ code. After spending some time in Java and C# I can feel the pain of compile times much sharper than I use to. After seeing that Java and C# were able to achieve some level of generics without requiring 'everything in the header' and knowing that C compiles an order of magnitude faster than c++ I set about to find a way to increase my compile times. > > Did you try PCH (precompiled headers)? Yes, PCH have their own problems and are ineffective for situations where you are actively editing the headers. The compiler still has to process them too. > >> One of the common recommendations is to 'forward declare' everything and to use the PIMPL (private implementation pattern). Unfortunately, PIMPL usually implies heap allocation and if you ever want to return-by-value you are stuck including the entire header for the types you use in your header. > > It'd be nice if a future version of C++ allowed pimpl without space overhead. > Keep in mind the other use case is this: class X { public: fwd<test,24> getByValue()const; } Not shown in my initial example is that fwd<> automatically casts to test or anything test automatically casts to. In this case, even an efficient malloc will not save class X. Perhaps fwd<> could be implemented via the heap... but that is an expensive way to solve the alignment problem. > Olaf > > _______________________________________________ > Unsubscribe & other changes: http://lists.boost.org/mailman/listinfo.cgi/boost"
"On 12 June 2012 18:08, Ion Gaztañaga <igaztanaga_at_[hidden]> wrote: > If I modify my implementation because I no longer need the internal copy > (e.g. the copy was required by an internal function/helper function), I > can't optimize the code and change the signature of the function to take a > reference, as name mangling changes and I'll need to recompile the caller. > If I offer both lvalue and rvalue reference variants I type a bit more but > I can safely change the implementation. On 13 June 2012 12:48, Mathias Gaunard <mathias.gaunard_at_[hidden]> wrote: > On 06/13/2012 04:12 PM, Peter Dimov wrote: > > Or 2^N overloads, if there's more than one argument to consume. >> > > In which case, make your constructor a template so that all those > overloads get generated through template instantiation, making use of the > template type resolution mechanism specifically designed for perfect > forwarding. > But if your constructor is a template, that code resides in the header, so don't you end up recompiling the caller anyway?"
"Right now every library enabled and disables internal debug support individually. Its impossible to do it now from single place. Suggestion for guidelines: - If BOOST_NDEBUG is defined then all libraries will switch off any debug support (asserts, pre- and post-condition checking, invariants etc). There would be no exception. - If BOOST_DEBUG is defined then all available debug suport will be switched on. There would be no exceptions. - If neither of macros is defined then libraries will behave as they behave now - picking their own choice using library specific macros. This would allow fine grained customization. Enforcing this rule would require quite a lot of effort and cooperation though. For example all assert()s would need to convert to BOOST_ASSERT()s. /Pavel"
""Francois Barel" <frabar666_at_[hidden]> writes: > I'd like to bring to your attention ticket #1470 > (http://svn.boost.org/trac/boost/ticket/1470), which seems to have > been missed for v1.35.0, maybe because I set the milestone to "TBD". I had a brief look at this. Boost.Thread is not the only library that has problems with non-default calling conventions: Boost.Test also has lots of problems. Consequently I was unable to run the tests to ensure that nothing was broken. I'm not going to check in a change unless I can be sure that the tests run fine. Anthony"
"Martin Wille wrote: > Johan Nilsson wrote: > >>>> [A bit off-topic] Is it intentional to have the 1.34.1 updates go >>>> under the RC_1_34_0 branch? >>> Yes. >> Isn't it a bit illogical to have 1.34.1 go under RC_1_34_0 (with emphasis on >> the trailing zero)? > > Yes, it is. Nevertheless, there's a tradition to do it that way for > Boost. I hope this will get fixed by the new procedures, too. Yeah. I think the branch should be called '1_34', since all minor (bug-fix) releases are spun off of that. Speaking of numbering, we also discussed removing the leading '1', since it doesn't appear to bear any meaning. And, since there is no attempt being made to be backward-compatible (neither API nor ABI), a simple linear numbering scheme appears just natural... Regards, Stefan"
"Tom Kent wrote: > Since sometime yesterday, all the gcc/clang develop runners I maintain (not > sure about Visual Studio, that machine has been down for updates) have been > failing, before the tests suite can even start running. Master still looks good. > > They end with the following: > - bzip2 : yes [30] > - lzma : yes [30] > - zstd : no [30] > - lzma : yes (cached) [30] > - has_lzma_cputhreads builds : no [2] > - auto_ptr : yes [3] > error: Unable to find file or target named > error: '/python//numpy' > error: referred to from project at > error: '../libs/python/build' > > > I believe this is because of the python ( > https://github.com/boostorg/python/pull/362) and build ( > https://github.com/boostorg/build/pull/726) pull requests that were merged > in around that time. The question is, why is this causing an issue... This is because the Build change has only been merged to https://github.com/bfgroup/b2, where the development has moved, and is not yet in boostorg/build's develop branch."
""Brock Peabody" <brock.peabody_at_[hidden]> writes: >> On Behalf Of David Abrahams > >> And what about the one Daniel Wallin posted, which doesn't require >> all exceptions to be registered in one big compile-time list? > > I'd rather be able to put them all in a list than to have to manually > register each one. ?? it seems equivalent to me. > However, given a runtime registration mechanism I guess it shouldn't > be too difficult to implement a compile to interface on top and it > would probably compile faster than a version implemented completely > at compile time. Yup. More importantly, it works even if different libraries register separate translators for exceptions in the same class hierarchy, without regard to registration order."
"> The following four libraries do not have "components" in trac > (lockfree already has the component in trac): > > - atomic > - coroutine > - multiprecision > - odeint (numeric/odeint) Done, I set atomic's maintainer to be the same as lockfree - is this right? Odeint currently has no maintainer set - for some reason "karsten" isn't recognised as a valid user id by the Trac - I don't understand that, any ideas anyone? John."
"> I think Daryle's point is that we want to attach a name to these > subtypes for printing. Probably this could be handled by the usual > "curiously recursive template." > > class metal_weight: public SI_weight_extender<metal_weight> > { > static string printable_name = "metal weight"; > } Sounds good. Minor point: In normal English I typically say things like "20 kilograms of aluminum" or "10 pounds of rice". Since any weight must have some units, I would think giving "metal" (or maybe "of metal" if some languages would need different qualifiers) would be a better idea."
"On Nov 25, 2012, at 10:24 AM, Andrey Semashev <andrey.semashev_at_[hidden]> wrote: > On Sun, Nov 25, 2012 at 6:57 PM, Matthias Troyer <troyer_at_[hidden]> wrote: >> Dear all, >> >> We have created a new sub list boost-mpi_at_[hidden] for discussion of Boost.MPI development. Those interested can visit http://lists.boost.org/mailman/listinfo.cgi/boost-mpi to sign up. > > There's [no description available] for Boost-mpi at > <http://lists.boost.org/mailman/listinfo.cgi>. Thank you, I've fixed it. Matthias"
"On Wed, 2 Mar 2011 14:16:38 +0000 Christopher Jefferson <chris_at_[hidden]> wrote: > One brief early comment, to help reviewers (and the author). > > The library has a small problem which prevents it compiling with clang > (and possibly other compilers) [...] On lines 85 and 89 of > boost/xint/integer.hpp, remove the 'typename'. [...] Thanks. I've tested this locally, and it caused no problems with MSVC or GCC, so it'll be in the next update. > One serious (but small) issue which will have to be addressed before > the library is accepted. The 'secure' flag at the moment I believe > cannot be trusted to work. [...] Ouch. :-( Thanks for bringing that to my attention, I (obviously) wasn't aware of it. > I am happy to help clean this up, and produce a general solution, if > required. I'd happily accept a patch that corrects the problem. If you'd prefer not to, I'll run the fixed code by you before releasing it."
"On 11/26/07, shunsuke <pstade.mb_at_[hidden]> wrote: > Hi, > > What happens if result_of is not consistent with decltype? > > > struct my_fun_t > { > template<class Sig> > struct result; > > template<class This> > struct result<This(int)> > { > typedef int type; // avoid dangling. > }; > > template<class This> > struct result<This(int const &)> > { > typedef int const & type; > }; > > int const & operator()(int const &i) const > { > return i; > } > }; > > my_fun_t const my_fun = {}; > > int main() > { > boost::result_of<my_fun_t const(int)>::type x = my_fun(10); // ok in C++98. > decltype(my_fun(10)) x_ = my_fun(10); // dangling in C++0x. > } > > I do not think that a polymorphic function object is allowed to lie that way. The result metafunction must return the exact type which is returned by operator(). In fact even in TR1 an implementation is allowed to implement result_of using whatever compiler intrinsic (or trick) and only fall back to result when everything else fail. Of course in C++0x, result_of is required to be implemented with decltype (or equivalent)."
"Hi Mika, > > From the documentation it seems like buffering only works for positive > offsets. Is the complement operation erosion also supported? Erosion > is important when simplifying structures. It is common practice to > first expand and then erode to get rid of minor details in shapes. The building blocks are there. But it is not implemented. Actually, buffering of polygons is also not part of this distribution. > > Also, from the documentation it seems like Douglas-Peucker is the only > available simplification algorithm. Do you have any plans to enlarge > the set of available algorithms? DP is pretty much the worst algorithm > we have available. The Douglas-Peucker is implemented as a strategy, the default strategy, for the simplify algorithm. The design supports specifying other algorithms there, we could add them or library users could add them. At this moment DP is the only one. Most libraries have them as the default or the only one, by the way. > > Triangulation was not mentioned. However, triangulation is an > effective tool for simplifying polygons, once you determine what your > simplification criteria are. Do you have any plans to add > triangulation as an elementary operation? Yes, there are plans, but indeed it is not implemented. All your questions focus on generalization/simplification, it is very interesting and, as a GIS-man, I'm sure willing to go further in that direction. Regards, Barend p.s. John, Vicente, thanks for the questions and clarifications, it makes the process very clear."
"Howard Hinnant wrote: > The "mixed thread safe" semantics I find interesting and a little > worrisome. Having some functionality thread safe and some not could > be seen as confusing. "Mixed thread safe" is the way of the future. :-) Really. One needn't be confused by it. For starters, it's the default thread safety level for all standard types unless specified otherwise. Having some non-const methods be thread safe is also not that uncommon. A lock-free queue for example might offer thread safety for push and pop, but not for operator=. Only atomic types have a thread safe operator=, and atomicity for UDTs comes at a cost that is rarely justified. To get back to std::thread, the reason we want some of its operations to be thread safe is because we have a specific use case where the usual "the user needs to use a mutex" doesn't work. In particular, we want, given a std::thread X, thread A (or threads A1...An) to be able to join it and thread B to be able to cancel it, unblocking A. This can't be achieved by a simple user-level mutex protection because it will deadlock. Thread A will lock the mutex protecting X, join and block with the mutex locked. Thread B will attempt to acquire the mutex in order to invoke cancel and also block. Unless the target thread exits by itself, A and B will wait forever. Given that, we also want to not penalize the non-shared case by introducing more synchronization than needed. The semantics I outlined take care of both. If we make cancel() const, we can now state that shared_ptr<const thread> is a safe and useful solution for the sharing use case. I've no opinion on detach at the moment."
"On 11/11/16 23:16, Andrey Semashev wrote: > On 11/11/16 23:00, Rene Rivera wrote: >> >> One obvious one.. What would happen when someone checks out and old >> version >> and the testing infrastructure has change enough that the old version >> doesn't work any longer? > > Same thing when he does that with libraries - it would probably not work. > >> Do we ignore that possibility and fail in some >> unpredictable way? Do we implement some version checking and fail nicely >> but prevent "users" from running the scripts? Do we want to support >> backward version testing of testing infrastructure to ensure the version >> checking works for all possible past versions against future versions? > > That is up to you, the maintainers of the testing infrastructure. As far > as I'm concerned, it can fail horribly. > > My point is that there should be a reliable way to checkout any Boost > release, I should have said "any Boost version" here, not just release. Potentially, any revision. And it should work the same way it worked when it was tested."
"Thu, Mar 15, 2001 at 05:10:52AM -0800, Jesse Jones ÐÉÛÅÔ: > >> Asserting will let you know something is wrong and let the app continue. > > > >Are you talking about some custom "assert"? The standard one terminates the > >application when it's condition check failed. > > I guess I am. I hardly ever use the C assert. :-) Well, so it seems to me that Boost need portable logging ostream, in addition to std::cout and std::cerr. > I think exceptions are more expensive than you realize. Yes, they are expensive (and I have realized that from the same time when they came into language) - but it just functionality cost, no more, no less. You know, high level languages are expensive compared with assembler language :) > Now you may be willing to pay the price of extra bloat and compromised optimizations Some bloat - yes; speed degradation - unlikely. It is just over-optimization to eliminate exception handling. > in return for catching the few programmer errors that slip out into the field, but most people will not. Ok, let them decide."
"Fernando Cacciola writes: > > ----- Original Message ----- > From: "Glen Knowles" <gknowles_at_[hidden]> > To: "'Boost mailing list'" <boost_at_[hidden]> > Sent: Monday, December 09, 2002 6:42 PM > Subject: RE: [boost] Formal review: Optional library > > > > From: Fernando Cacciola [mailto:fernando_cacciola_at_[hidden]] > > >> > > >> * I'm unsure about the presence of "initialized()". On the one hand, > the > > >> duplication in features (compared to "get/peek() == 0") is something I > > >> think designs should generally avoid. On the other hand, this name is > > >> more meaningful for what precisely "get/peek() == 0" signifies. I > guess > > >> I'm +0 on this one. > > >> > > >To be honest, I dislike it too :-) > > >But some people found the alternative spellings ugly, > > >so I figured that a member function would make them happy. > > > > How about using !empty() instead of initialized() ? > > > The problem William was raising is not about the particular name of the > member-function: empty() or initialized(); but about having a(nother) > member-function to do a job which is already covered by other parts of the > interface. > (note that there is no empty() member function in optional<>) > > OTOH, whether to have 'empty' or 'initialized'... well, I prefer > 'initialized', but that's mainly a matter of personal taste I think. empty() is analogous to containers. Given empty(), I see no need for peek() _and_ get_value() --- if you can get a reference to the value, you can get its address, if necessary. I prefer the member interface to the non-member interface, in this instance. You might like to use the techniques from my StrongStorage class (see the boost files section on yahoo) to ensure integrity in the face of exceptions --- StrongStorage actually provides a very minimal implementation of optional<>. In any case, I say ACCEPT the library. Anthony"
">> As for the original question, this is such a pervasive breaking change, I >> think a new macro is inevitable I'm afraid :-( > > New macro will do exactly what the old macro did, but using C++11 > feature. Code in all Boost libraries will be changed to use new macro. > So the old macro will be required only for users code that use macro > and attempts to take address of constant... > > To me, it looks less obscuring to have one macro and a note for users > to use BOOST_CONSTEXPR_OR_CONST for out-of-line definition; than two > macro (which one shall be used by default?) that do the same thing but > very slightly differ in details. Here's a radical idea: are there any compilers still around that we care about which require the enum workaround? Certainly not VC6 ;-) So we could recomend libraries use: template <class T> struct foo { BOOST_STATIC_CONSTEXPR bool value = some_value; }; template <class T> BOOST_CONSTEXPR_OR_CONST bool foo<T>::value; Thoughts? John."
"At 06:33 PM 11/21/2003, Douglas Gregor wrote: >Okay, fair enough. But can we put them in, say, boost/config/abi_prefix.hpp >and boost/config/abi_suffix.hpp? The boost/ header directory is getting >rather...extensive. Good point. I'll wait until Monday to see if any other comments come in, and then go ahead and add them. --Beman"
"Hello, I've just found out that the following program: #include <boost/static_assert.hpp> int main() { BOOST_STATIC_ASSERT(false); return 0; } compiled with gcc 3.3 produces: sa.cpp:6: error: invalid application of `sizeof' to an incomplete type which is not as nice as sa.cpp:6: `sizeof' applied to incomplete type `boost::STATIC_ASSERTION_FAILURE<false>' that gcc 2.95 generates and sa.cpp:6: `sizeof' applied to incomplete type ` boost::STATIC_ASSERTION_FAILURE<false>' That 3.2 generates. The behaviour of 3.4 is the same as for 3.3. So, there are some questions: 1. Should I bug gcc developers about this? 2. Anybody knows another way to force better diagnostic? 3. Is it possible to make regression tests for static_assert always include compiler messages, so that we know the diagnostic is OK? - Volodya"
"At Monday 2005-01-17 02:19, you wrote: >Sorry, wrong example. Should have been > >cout << strlen(""); > >or > >cout << vector<int>().size(); > >which both give me warnings with /Wp64 > >warning C4267: 'argument' : conversion from 'size_t' to 'unsigned int', >possible loss of data IMO this falls directly in Dinkumware's lap. ALL of the code was written by them (well the headers). It's fairly clear that there should be no restrictions on outputting the return from .size() >_______________________________________________ >Unsubscribe & other changes: http://lists.boost.org/mailman/listinfo.cgi/boost Victor A. Wagner Jr. http://rudbek.com The five most dangerous words in the English language: "There oughta be a law""
"Dean Michael Berris said: (by the date of Thu, 19 Oct 2006 17:09:02 +0800) > > > can it be used for multimethods ? > > > I have an example use (in the accompanying tests) which uses a > boost::tuple<> as the index type. If the aim was to use multiple > values, you can create a tuple from it and use that as an index -- > then couple it with a validation and routing strategy that allows you > to validate and manipulate the index used for the dispatch. > > If you need to call multiple methods, you can use the invoker > interface to the dispatcher -- but still using single dispatch. You > can even use Boost.Signals to register a set of methods and register > it to the dispatcher on a single index. thanks, I will check it out. I have one question though. Currently I am using a 2D matrix to preform dispatching on two virtual base classes. This matrix approach allows fast lookup. Does your method allow a similar solution?"
"> Many thanks for your work on this. Looks promising, but may > be worth also producing the plain const double/float/long double files > as well for the time being at least? > > Paul The plain const was actually less efficient for some platforms. The only problems I see with the template function approach is the extra typing: v = pi is certainly easier than v = constant<pi_tag,double> but it is not amenable to more precise implementations. How about a compromise: v = pi<double>() and so on for all the other constants? I think this can be made to work with even the most brain-dead compilers."
"Nicola, I've checked in changes to RC_1_34_0 last 30 may. I believe these changes should fix the issue you detected. But now I'm not sure as I don't remember the results of the previous tests. Note that I made a change in basic_text_oarchive.hpp in lieu of your suggestion for basic_text_oprmitive.hpp. I believe that this is in the correct place. We're still geting errors however so could you please take another look at this? Robert Ramey Nicola Musatti wrote: >> Robert Ramey wrote: >>> There are a couple of places which might be good to look at here. >>> >>> a) iserializer.hpp line # 190 >>> b) iserializer.hpp line # 326 >>> >>> These two areas have borland specific code related to ensure >>> that pointer de-serialization is instantiated. Perhaps borland >>> has been improved so that it works more like other compilers >>> in this regard. You might try tweaking these areas - using >>> workaround borland version ... etc so that the more modern >>> version uses the standard way. Let me know how this >>> works. >> >> Thanks for your suggestion, it did prove helpful! I enclose a couple >> of >> patches which cause some 30 tests to pass which previously failed. >> Let >> me know what you think and if you want me to apply them. >> >> Cheers, >> Nicola Musatti >> >> > > > >> ******Index: basic_text_oprimitive.hpp >> =================================================================== >> RCS file: >> /cvsroot/boost/boost/boost/archive/basic_text_oprimitive.hpp,v >> retrieving revision 1.12 >> diff -d -u -r1.12 basic_text_oprimitive.hpp >> --- basic_text_oprimitive.hpp 4 Feb 2006 20:35:35 -0000 1.12 >> +++ basic_text_oprimitive.hpp 24 May 2006 20:53:36 -0000 >> @@ -58,6 +58,10 @@ >> >> class save_access; >> >> +#if BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x582)) && >> __BORLANDC__ >= 0x580 +class version_type; >> +#endif >> + >> ///////////////////////////////////////////////////////////////////////// >> // class basic_text_oprimitive - output of prmitives to stream >> template<class OStream> >> @@ -84,6 +88,14 @@ >> os << t; >> } >> >> + #if BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x582)) && >> __BORLANDC__ >= 0x580 + void save(const version_type t){ >> + if(os.fail()) >> + >> boost::throw_exception(archive_exception(archive_exception::stream_error)); >> + os << t.t; + } >> + #endif >> + >> ///////////////////////////////////////////////////////// >> // fundamental types that need special treatment >> void save(const bool t){ >> > > > >> ******Index: iserializer.hpp >> =================================================================== >> RCS file: /cvsroot/boost/boost/boost/archive/detail/iserializer.hpp,v >> retrieving revision 1.30 >> diff -d -u -r1.30 iserializer.hpp >> --- iserializer.hpp 12 Feb 2006 05:45:16 -0000 1.30 >> +++ iserializer.hpp 24 May 2006 21:42:57 -0000 >> @@ -187,7 +187,7 @@ >> public: >> // at least one compiler (CW) seems to require that serialize_adl >> // be explicitly instantiated. Still under investigation. >> - #if !defined(__BORLANDC__) >> + #if ! BOOST_WORKAROUND(__BORLANDC__, < 0x582) >> void (* const m)(Archive &, T &, const unsigned); >> boost::serialization::extended_type_info * (* e)(); >> #endif >> > > > >> _______________________________________________ >> Unsubscribe & other changes: >> http://lists.boost.org/mailman/listinfo.cgi/boost"
"> I'll turn it around the other way. Most instances of > microsecond_clock never > care about the a time_zone to adjust the time. So there is > no reason to drag > in that dependency. But, in fact, the overloading I pointed > out above: > > template<class time_type> > class microsecond_clock { > ... > template<class time_zone_type> > static time_type local_time(shared_ptr<time_zone_type> tz_ptr); > > enables the microsecond clock to use a time zone. When using a > local_date_time type the timezone is required. So it's true, > you'll get a > compile error if you try to call the other overloadings with a > local_date_time, but that's the intent. "... practicality beats purity" It would be nice to have small comment within source code or reference to documentation that explains why this is intent and\or work around to the problem. > Jeff Thanks for help Roman Yakovenko"
"Hi, Wilbur Lang wrote: > Hi, > > As win32 version of shared mutexes are based "spin and wait", which > leads to poor performance and priority inversions*. > I have an idea about simulate PTHREAD_PROCESS_SHARED with > DuplicateHandle() under win32. > > 1. anonymous mutex keeps the process id (e.g. hprocess) where > CreateMutex called and HANDLE of mutex (e.g. hmutex). > 2. if another process want to shared this mutex, it call > DuplicateHandle() with hSourceProcessHandle=hprocess and > hSourceHandle=hmutex, and return hmutex_dup. > 3. the process use hmutex_dup to lock/unlock/try_lock/timed_lock > 4. we can optimize performance with cache hmutex_dup. > > and a specialized scoped_lock required for anonymous mutex under > windows which didn't use handle directly, but DuplicateHandle. The main problem with storing the process id is that I want anonymous mutexes to work with memory mapped files. If a process creates a managed mapped file(which includes a mutex) fills it with data and then unmaps it, it should be able to map it again and continue working. If several processes map it and then unmap it, all references to that mutex are destroyed and Windows would destroy the mutex. We'll need to re-create the windows mutex although the object is still there in shared memory. This behavior is possible with POSIX mutexes with PTHREAD_PROCESS_SHARED attribute and it's the most difficult one to emulate in Windows. Regards, Ion"
"If they are generated intermediate files why check them in at all? On Thu, Dec 6, 2012 at 12:35 PM, Eric Niebler <eric_at_[hidden]> wrote: > On 12/6/2012 1:17 AM, Daniel James wrote: > > Hi, > > > > The snapshot builds and inspect results haven't been running for some > > time, so I've added running the inspect script to the documentation > > build for more up to date results. You can see them at: > > > > http://boost.cowic.de/rc/docs-inspect-trunk.html > > http://boost.cowic.de/rc/docs-inspect-release.html > > > > These are generated after building documentation, which is not exactly > > the same as the final release, but it's close. > > For the accumulators library, the xml files its complaining about are > generated as part of the doc build. Is there some way to get inspect to > ignore them? > > -- > Eric Niebler > BoostPro Computing > http://www.boostpro.com > > _______________________________________________ > Unsubscribe & other changes: > http://lists.boost.org/mailman/listinfo.cgi/boost >"
"> > Hopefully if you then compile your libs with the > (undocumented) "intel-9_0" > toolset the names should then match up. > > Does this help? Yes. Thank you. Goncalo __________________________________ Yahoo! Mail - PC Magazine Editors' Choice 2005 http://mail.yahoo.com"
"If your implementation is single threaded, you don't need to worry about concurrency issues at all. All completion handlers will be scheduled to run sequentially. In other words, no need for a mutex. If you later decide to make your program multi-threaded (i.e. multiple threads per io_context) then the idiomatic method to control concurrency is to use an asio::strand<asio::any_io_executor> as your executor type for each io_enabled concern (such as a connection). In asio, (and net.ts) the strand is a special executor adapter that guarantees that although multiple completion handlers can execute concurrently through the *underlying executor*, they can only complete *sequentially* through the strand which is *adapting* that underlying executor. On Mon, 7 Sep 2020 at 11:54, Jupiter via Boost <boost_at_[hidden]> wrote: > Hi, > > I used boost::asio::io_service for a single thread implementation but > with multiple boost::asio::deadline_timer objects, because it is a > single thread, I don't think I need to use boost::mutex to lock and > unlock tasks running by deadline_timer, am I wrong about it? > > Thank you. > > Kind regards, > > jupiter > > _______________________________________________ > Unsubscribe & other changes: > http://lists.boost.org/mailman/listinfo.cgi/boost >"
"Ulrich Eckhardt wrote: > Hi! > > This is basically the result of a discussion on the STLport > mailinglist. The question came up what this code means: > > #if defined(_BIG_ENDIAN) > 0x7f80 << (sizeof(int)*CHAR_BIT-16), > #else > 0x7f800000, > #endif > > This is from detail/limits.hpp. The puzzling thing is that the result > for big-endian targets is exactly the same, unless the size of an int > is not 32 bit, but the size of the int has nothing to do with > endianess still... > > I dug around a bit, and it was added some time ago by John Maddock > with the comment that it adds support for big-endian SPARC machines, > but later also used for big-endian MIPS and PPC. There also used to > be a comment saying something like: "making this depend on big-endian > targets is wrong, it's the layout of floats we care about, not the > layout of integers when written to memory". This comment was removed > when the ad-hoc endian detection was replaced with the centralized > one. > > Can anybody see what this code is supposed to do? I understand that > 0x7f800000 is an integer with the same bit layout as one of the > special floating point constants, but I can't figure out why it would > be any different on big-endian machines. OK, first off I've never had access to sparc machines, so I would have been applying a patch that someone else had submitted, unfortunately I can't locate the original message at present :-( The reason for there being a difference on *some* big-endian machines is that while the byte order of int's has swapped around, floats retain the same IEEE-specified order. But, that implies this code does indeed look wrong! However, this code was only ever used for gcc-2.95 if I remember correctly, so it's effectly depricated fluff these days... Not sure if this helps, John."
"Robert Ramey wrote: > There are a couple of places which might be good to look at here. > > a) iserializer.hpp line # 190 > b) iserializer.hpp line # 326 > > These two areas have borland specific code related to ensure > that pointer de-serialization is instantiated. Perhaps borland > has been improved so that it works more like other compilers > in this regard. You might try tweaking these areas - using > workaround borland version ... etc so that the more modern > version uses the standard way. Let me know how this > works. Thanks for your suggestion, it did prove helpful! I enclose a couple of patches which cause some 30 tests to pass which previously failed. Let me know what you think and if you want me to apply them. Cheers, Nicola Musatti ******Index: basic_text_oprimitive.hpp =================================================================== RCS file: /cvsroot/boost/boost/boost/archive/basic_text_oprimitive.hpp,v retrieving revision 1.12 diff -d -u -r1.12 basic_text_oprimitive.hpp --- basic_text_oprimitive.hpp 4 Feb 2006 20:35:35 -0000 1.12 +++ basic_text_oprimitive.hpp 24 May 2006 20:53:36 -0000 @@ -58,6 +58,10 @@ class save_access; +#if BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x582)) && __BORLANDC__ >= 0x580 +class version_type; +#endif + ///////////////////////////////////////////////////////////////////////// // class basic_text_oprimitive - output of prmitives to stream template<class OStream> @@ -84,6 +88,14 @@ os << t; } + #if BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x582)) && __BORLANDC__ >= 0x580 + void save(const version_type t){ + if(os.fail()) + boost::throw_exception(archive_exception(archive_exception::stream_error)); + os << t.t; + } + #endif + ///////////////////////////////////////////////////////// // fundamental types that need special treatment void save(const bool t){ ******Index: iserializer.hpp =================================================================== RCS file: /cvsroot/boost/boost/boost/archive/detail/iserializer.hpp,v retrieving revision 1.30 diff -d -u -r1.30 iserializer.hpp --- iserializer.hpp 12 Feb 2006 05:45:16 -0000 1.30 +++ iserializer.hpp 24 May 2006 21:42:57 -0000 @@ -187,7 +187,7 @@ public: // at least one compiler (CW) seems to require that serialize_adl // be explicitly instantiated. Still under investigation. - #if !defined(__BORLANDC__) + #if ! BOOST_WORKAROUND(__BORLANDC__, < 0x582) void (* const m)(Archive &, T &, const unsigned); boost::serialization::extended_type_info * (* e)(); #endif"
">-----Original Message----- >From: boost-bounces_at_[hidden] >[mailto:boost-bounces_at_[hidden]] On Behalf Of Thorsten Ottosen >Sent: 23 July 2007 17:07 >To: boost_at_[hidden] >Cc: boost-test_at_[hidden] >Subject: Re: [boost] Problem with the web page for Boost unit >test library >I was browsing through your excellent docs here: >http://boost.org/libs/test/doc/usage/msvc_net.html > >I stumbled upon a irritating problem: I could not re-run the test >without changing a source file. > >I think I found a solution: I set the custom build step instead of the >the post-build event. Here I set "outputs" to c:\dummy_file.txt >(anything non-empty will do). > >Thus when I hiut F5, I get the errors in the output window in visual >studio :-) Brilliant! This has been bugging me for some time :-) I've refined it a bit by using in Custom build Command line: "$(TargetDir)$(TargetName).exe" (and more perhaps) Description: Autorun "$(TargetDir)$(TargetName).exe" This makes the source filename appear too - a useful feature when you get confused about various versions in different directories. Output: c:\dummy_file_used_by_autorun.txt The dummy_file seems to be deleted after each run so a longer and more unique name might be wiser. How does one write output to it? On rebuild, the output window shows, for example: Compiling... test_cauchy_mean.cpp Linking... Generating code Finished generating code Embedding manifest... Autorun "i:\boost-06-05-03-1300\libs\math\test\Math_test\release\test_cauchy_mean.exe" Running 1 test case... 1.#QNAN errno = 33 errno is EDOM *** No errors detected Build Time 0:08 Alt B U does a re-build. Ctrl F5 re-runs and also shows output in the cmd.exe window. F5 is not so useful - debugs - but you may want this (but there are never any bugs in programs of course ;-). Question: How could on get the date and time (clock or file saved) into this output (without changing the source program)? Paul"
"--- In boost_at_y..., Doug Gregor <gregod_at_r...> wrote: > On Thursday 15 March 2001 09:30, you wrote: > [snip] > > > It builds fine on x86 Linux with a few minor changes: > > > 1) Use forward slashes instead of backslashes when including > > > > headers. > > > > > Windows will support #include <boost/header.hpp>, but not all Unix > > > > systems > > > > > (Linux included) support #include <boost\header.hpp>. > > > > Jeremy Siek already pointed this out to me and I attempted to change > > all of them. Which specific ones did I miss? > > The from threads/boost subdirectory: > atomic.hpp:21:#include <boost\config.hpp> > atomic.hpp:27:# include <boost\fast_mutex.hpp> > condition.hpp:21:#include <boost\config.hpp> > fast_mutex.hpp:21:#include <boost\config.hpp> > fast_mutex.hpp:26:#include <boost\utility.hpp> > fast_mutex.hpp:27:#include <boost\xlock.hpp> > mutex.hpp:21:#include <boost\config.hpp> > mutex.hpp:26:#include <boost\utility.hpp> > mutex.hpp:27:#include <boost\xlock.hpp> > recursive_mutex.hpp:21:#include <boost\config.hpp> > recursive_mutex.hpp:26:#include <boost\utility.hpp> > recursive_mutex.hpp:27:#include <boost\xlock.hpp> > semaphore.hpp:21:#include <boost\config.hpp> > semaphore.hpp:26:#include <boost\utility.hpp> > thread.hpp:21:#include <boost\config.hpp> Wow! Hard to believe I missed this many of them! Thanks for finding them. > From the threads/src directory: > condition.cpp:21:# include <boost\semaphore.hpp> > condition.cpp:22:# include <boost\atomic.hpp> These particular ones occurred because the code originally existed in a Windows specific implementation file. At least I have an excuse for two of them ;). > From the threads/example directory: > monitor.cpp:3:#include <boost\condition.hpp> > monitor.cpp:4:#include <boost\fast_mutex.hpp> > monitor.cpp:5:#include <boost\mutex.hpp> > monitor.cpp:6:#include <boost\recursive_mutex.hpp> And I just didn't pay as much attention to the examples as I did the code... > > > However, I have reproduced the deadlock problem with the example > > > > program. > > > > With what sort of frequency? Do you have any way of telling where it > > deadlocks for me? Obviously I've got a race condition here and will > > have to track it down and fix it. > > Out of 100 runs, it deadlocked three times. I don't know of any easy way of > determining where the deadlock occurs, but I'll take a closer look at it > later. Thanks, you've confirmed my own experience. Definately a subtle race condition in the implementation. I'll have to see if I can track down what it is. > > > A compiler at GCC's highest warning level (-ansi -pedantic - Wall) > > > > results in > > > > > some signed/unsigned comparison warnings in the pthread handling > > > > code. > > > > > Commonly the condition: > > > > > > if (milliseconds == -1) > > > > > > appears, where "milliseconds" is an unsigned int. Is this > > > > safe/intended? > > > > Intended. I'm not 100% sure about safe. If this is not portably > > safe I'll need to change this to use numeric_limits<>::max. > > I'm not sure how to decipher what the C++ standard says in this regard > (4.7/2), though it appears that it won't be safe if the architecture uses > something other than two's complement integer arithmetic. My personal opinion > is that it would be best to replace -1 with, e.g., > enum { FOREVER = std::numeric_limits<unsigned int>::max }; I'll do this. > Here's the list of nitpicks the Comeau compiler found: > - Can't use a ';' after '}' ending a namespace (happens everywhere) My own misunderstanding of C++ syntax. I'll fix this. > - Add an extra line feed at the end of each line (happens everywhere) This one I don't understand. Is it a problem with the \r\n DOS/Windows line endings? > - #include <ctime> to get std::clock_t. (condition.hpp) Thanks. > - Qualify clock_t as std::clock_t (condition.hpp, src/*.cpp) Won't work with VC++, so I'll have to use the usual work arounds. Thanks. > - Nested "impl" classes have to be declared friends of their enclosing > classes (semaphore.hpp, mutex.hpp, fast_mutex.hpp, recursive_mutex.hpp) This one I don't buy. The "nested class" does not use the "enclosing class" in any way while the "enclosing class" uses only public methods of the "nested class". I see no need for friendship in either direction. > - use 0 instead of NULL because many compilers pick up nonportable NULL > definitions (fast_mutex.cpp, mutex.cpp, recursive_mutex.cpp, semaphore.cpp) Dang... this is one that I try not to do but bad habits let some slip through. I'll search out and fix this one as well. > - In the monitor example, a "void*" parameter is casted to "void (*) ()", > which is illegal. The attached monitor.cpp uses a simple dispatch object to > get around this limitation. Thanks. This code will be replaced with proper Boost alternatives in Phase 2, but I should make the "hack" legal code until then. Again, thanks for the comments and pointers. I'll be working on this stuff today and hopefully will have an update posted tonight or tomorrow incorporating things people have mentioned here. Bill Kempf"
"Vladimir Ciobanu wrote: > It would be nice to add "algorithms" similar to > std::list's function members ( like push_back et all). boost::mpl already has those."
"Thanks for the help all :) I've got the graphviz parsing linking for a shared library now. Raphael, you can grab the changes from the sourceforge CVS. However, I would only grab the changes to the src/ directory. I'm making unrelated updates/changes to other parts of BGL. Cheers, Jeremy ---------------------------------------------------------------------- Jeremy Siek www: http://www.lsc.nd.edu/~jsiek/ Ph.D. Candidate email: jsiek_at_[hidden] Univ. of Notre Dame work phone: (219) 631-3906 ----------------------------------------------------------------------"
"It doesn't look as though the post release procedure is working to well: to recap it is the responsibility of anyone who made changes to the release branch to also make those changes on the main trunk. Since no one else has done it, I've just merged the changes in: /status /more /people I also tried to merge /index.htm but there were conflicts - can those responsible for the changes here please sort them out? There may also be unmerged changes in the headers, but to be honest I can't see any easy way of figuring out whether this is the case. John Maddock http://ourworld.compuserve.com/homepages/john_maddock/index.htm"
"On Mon, May 21, 2012 at 9:14 AM, Simonson, Lucanus J < lucanus.j.simonson_at_[hidden]> wrote: > Andrii Sydorchuk wrote: > > >The main point is that this void* data member is not used by the > algorithm at all. And is only exposed to simplify data association with > voronoi primitives. > > Does it currently have any usage at all? > > >From the user perspective the good practice would be to use data > >access functions instead of direct class methods to retrieve associated > >data: > >template <typename T> > >UserDataType* data(const voronoi_edge<T>& edge) { > > return static_cast<UserDataType*>(edge.data()); > >} > > I guess it depends on whether the user wants to traverse the voronoi > diagram data structure as the input to their algorithm or copy it over to > their own graph data structure. I tend to think that copying to their own > data structure will be pretty common. It looks like the user can look up > the input site for each cell in your voronoi_cell data structure. If they > hash or map the site to whatever data they want associated with the site > they can at least make the association between the voronoi diagram and its > input. Unless there is a compelling reason I'd suggest just removing the > user data interface. As you mentioned, the user can always roll their own > voronoi diagram data structure to use with the voronoi builder that they > can extend with whatever additional data they want. > I may have some suggestions on how to implement this user data, but yes, Luke's suggestion looks to be the simplest solution. Andrii, do you have an example use case for storing the data in situ with the voronoi primitive objects? Looking at a concrete use case might help ground the discussion. - Jeff"
"Bjorn Reese <breese_at_[hidden]> writes: > On 04/23/2013 05:45 AM, Rene Rivera wrote: >> On Mon, Apr 22, 2013 at 10:57 AM, Petr Machata <pmachata_at_[hidden]> wrote: > >> It's intentional. As, AFAIK, PA-RISC is the common name for that >> architecture. And also the macros it's based on for the version information >> are also PA_RISC. > > I think he is refering to the RISK versus RISC spelling. Yes, that was my point. >> I can't claim to know much about those.. But is __SYSC_ZARCH__ enough ro >> match any z/Architecture regardless of the s390 defines? If you think those > > Not really. __SYSC_ZARCH__ is only defined by the Dignum Systems/C++ > compiler. Right. What I meant to say was that __SYSC_ZARCH__ is not defined by GCC at all. On GCC, __s390__ is the define for both, and __s390x__ explicitly for the 64-bit one. >>> I always considered the relation betwenn z/Architecture and s390 to be >>> approximately the same as between i386 and x86_64. Maybe it would make >>> sense to have an overarching is-z-system define, similar to >>> BOOST_ARCH_X86? No idea what to call it though. >>> >> >> Hm.. Perhaps. Is that a popular understanding of those architectures? > > z/Architecture is LP64, and is backwards compatible with System/390 > which is ILP32 (well almost, as pointers are only 31-bits wide.) See: Right. To answer the original question, yes, I believe that's a popular understanding. E.g. GCC for s390x can produce s390 binaries when given the -m31 command-line option. strace and ltrace compiled for s390x can "cross-trace" s390 processes. 64-bit s390x Linux kernel supports launching processes in 31-bit execution mode. Etc. Exactly the same as for x86_64/x86 or ppc64/ppc. Thanks, PM"
"On Tue, Sep 1, 2015 at 7:36 PM, Niall Douglas <s_sourceforge_at_[hidden]> wrote: > > This is a complex and lengthy answer if answered in full, and is a > large part of the AFIO value add. The housekeeping done during handle > open is used throughout AFIO to skip work in later operations under > the assumption that handle opens are not common. > > Limiting the discussion to just the problem of race free filesystem > on POSIX, imagine the problem of opening the sibling of a file in a > directory whose path is constantly changing. POSIX does not provide > an API for opening the parent directory of an open file descriptor. > To work around this, you must first get the canonical current path of > the open file descriptor, strip off the end, open that directory and > then use that as a base directory for opening a file with the same > leafname as your original file. You then loop all that if you fail to > open that leafname, or the leafname opened has a different inode. > Once you have the correct parent directory, you can open the sibling. > This is an example of where caching the stat_t of handle during open > saves syscalls and branches in more performance important APIs later > on. > The normal way to do this with POSIX *at APIs would be to just open a handle to the directory in the first place. I suppose the purpose of this more complex approach is to avoid having to keep an extra file descriptor to the directory open, or to allow the user to open a sibling file from an arbitrary AFIO file handle without preparing in advance (as I suppose would be required by your shadow file-based locking approach). It does seem like rather specific and not necessarily all that common functionality to require users to pay for by default. > A similar problem exists for race free file deletions and a long list > of other scenarios. The cause is a number of defects in the POSIX > race free APIs. The Austin Working Group are aware of the problem. > Windows doesn't have problems with race free siblings and deletions > due to a much better thought through race free API, but it does have > other problems with deletions not being actual deletions and > different workarounds are needed there. > Personally, I would prefer an API that lets me pay only for what I need. You could expose the low-level platform-specific behavior but also provide higher-level operations that have added complexity to avoid races or emulate behavior not provided natively. > > You can disable the race free semantics, which are slow, using > > > afio::file_flags::no_race_protection. However AFIO fundamentally > > > assumes that any file system path consuming function is slow and will > > > not be frequently called by applications expecting high performance, > > > so work is deliberately loaded into path consuming functions to keep > > > it away from all other functions. > > > > > > If you have a need to do a lot of file opens and closes and don't > > > care about races on the file system, you are better off not using > > > AFIO. STL iostreams is perfectly good for this as the only OSs which > > > allow async file opens and closes is QNX and the Hurd. > > > > > > > There is certainly a large gap between what is possible with STL > iostreams > > or Boost filesystem and what is possible using platform-specific APIs for > > file system manipulations. While it is obviously your choice what scope > to > > pick, I think it may be possible for it to be usable for everything you > > intend to do with it, e.g. for writing a database backend, but also to be > > much more widely useful. > > It always easy to say "it should do everything optimally". If I had > more resources I could do much better than I intend to do. As it > stands, without sponsorship you get just 350-400 hours per year, > that's just two months full time equivalent. It's very limiting. You > have to rationalise. > I certainly understand. I'm just trying to convey what I"d like to see in a C++ filesystem API. > > > > > Stability with respect to what? Do you expect native handles to be > > > > somehow different on the same platform? > > > > > > AFIO's design allows many backends e.g. ZIP archives, HTTP etc. So > > > yes, native handles can vary on the same platform and I needed to > > > choose one for the ABI. > > > > Perhaps you could provide a less generic API for the native platform > > filesystem, and then once you also have support for ZIP archives, etc. > > create a more generic interface on top. While archive files and > different > > network protocols like WebDAV and FTP can certainly be presented as file > > systems, particularly for read-only access, and indeed it is often > possible > > to access them as file systems through the native platform APIs, they > tend > > to differ sufficiently from file native systems that a different API may > be > > more suitable. > > I think this is another storm in a teacup. Dropping generic > filesystem backends just because native_handle() doesn't return an > int? Seems way overkill. > > Generic filesystem backends could let you do loopback mounts and a > long list of value add scenarios. I would consider them a vital > design point. > I suspect that there may be a relatively easy solution to the particular problem of type safety for native_handle(), e.g. by exposing a platform-specific handle type, but also having some type erasure. I agree that having a generic interface to filesystem-like things is potentially useful. However, I think this is quite a tricky thing, and it is difficult to define such an interface without looking at the capabilities of all of the backends you'd like to support and what functionality different applications would like to use. For instance, some backends might only support reading/writing entire files at once. Some might not allow random access. Some might only allow appending new files. Symlinks, hardlinks, file permissions, modes, flags and other metadata may not be supported or may operate completely differently. (Even if e.g. POSIX file owner/group and mode are supported, the semantics will in general be completely different than for a local filesystem.) Using Boost.Filesystem path doesn't really make sense for anything other than the native OS filesystem APIs. Indeed there are numerous existing libraries/systems that try to do this, and even ways to expose arbitrary things as filesystems to the operating system, e.g. FUSE on Linux, so that individual programs don't need to concern themselves with it. However, there tend to be drawbacks to trying to make these pseudo-filesystems appear as regular filesystems. > Also correct. Delayed allocation means the file system may only try > to actually allocate storage on a first write into that extent, and > that might fail. This would then blow up with a fatal app exit thanks > to AFIO's current implementation. As I said, I am very aware of this, > I just needed lightweight futures done before I could start the ASIO > reactor replacement. > It isn't clear to me why it would be particularly hard to expose this as a regular error rather than a fatal one, but it sounds like you are planning to fix it anyway."
"----- Original Message ----- From: "David B. Held" <dheld_at_[hidden]> > > How many times to I have to reiterate this? I _do not disagree_ with > > many of the abstractions in the MPL. I disagree with the supposed > > need of multiple sequence types. > > But earlier, you said: > > > [...] > > I think that many people are infatuated with the analogy to the STL > > and are thinking that this analogy will prove itself down the road > > (instead of now). > > So is it just sequence abstraction, or also algorithm abstraction that > you think are just "a significant amount of implemenation and design > baggage"? Sequence abstraction. I have yet to see a practical example that shows that it has purpose. I'll that I have seen is a lot of what-if's. > > [...] > > Count me as #4 also. A good example that demonstrates the utitilty > > of the sequence abstraction in the MPL would be a significant > > argument for it. > > I think Dave A's point about the existence of different sequence types > from different libraries is quite compelling. In order to work with different type sequences from other places, those type sequences will still need to be modified. Such a thing is also likely to cause the modification of the algorithms that go with it--not because it is necessary, but because it to make them conform with the MPL's STL-like concept. In such a scenario, it would be easier to map a foreign structure into an MPL structure than permeate the design of the MPL with "what-if" constructs. > > In particular, one that shows that vector-like sequences outperform > > cons-style lists *and* vice-versa in different scenarios. > > But I still think this is a red herring. What is the purpose then? Just as an example that it can be done? > > > [Andrei said...] > > > It's been months. > > Metaprogramming is hard stuff to think about. ;) That's how long it takes > me to understand one metafunction. ;) I think that it is just that functional programming is so foreign to many C++ programmers. I certainly had to get used to it as well. :) > > > I've been glad to see that people realized that using the "STL is cool > > > and MPL is like STL, therefore MPL is cool" argument has some > > > subtle circularity. > > Well, I don't see any circularity there. If we said: "STL is cool because > MPL is cool", then you'd have circularity. And I think the way MPL is > like the STL *is* cool. In particular, I think Terje's factorial example is > an interesting study, and I'd like to see the equivalent type-independent > implementation that doesn't use any MPL facilities. > > > I'd say it isn't subtle at all. :) > > Perhaps you'd like to describe the circularity for the slower readers > (like myself)? Not circularity exactly, just logical leaps and assumptions. The STL concept can be good or bad depending on the situation and environment to which is applied. By the STL concept, I mean containers-iterators-algorithms, not all the little function objects, etc.. As I've said repeatedly, there are many things that I like about the MPL. Some of the abstractions that the STL makes do apply, others don't IMO. I didn't see Terje's factorial example, but I did see his exponentiation example, and I have no problem with that type of thing--including some of the improvements that Terje suggests. However, that is not going to make me unilaterally believe that something is inherently good just because of abstraction or because it is similar syntactically or conceptually to something else (namely the STL). That has to be shown to be valid for the same reasons that they are valid for the STL. That has been done for many of the abstractions in the STL, but it hasn't been done for sequences. External types from preexisting libraries and code is a good example, but that comes down to a question of philosophy. Is it better to be 'backward-compatible' in such a young field? I'm not so sure that it is, and sequence conversion algorithms aren't that difficult to implement if a switch over isn't reasonable. > > The STL is great based on abstractions around certain runtime > > characteristics of various sequences. > > I don't think the STL is great because of containers with different runtime > characteristics. I think it's great because a sequence can come from a > container, a generator, an external source, or another sequence (as > Dave A astutely points out by mentioning subsequences). The fact that > you can create sequence containers with different runtime properties > with the STL is merely an implementation benefit of its clever design. I do not think that it ever would have existed if it weren't for containers with different runtime characteristics. I also don't think that it is "merely an implementation benefit of its clever design." I think that it is primarily the _validity_ of the design, which is, by in large, contrary to OO. > > Do those same reasons that the STL is great apply to template > > metaprogramming, > > Yes. > > > and, more specifically, to the use of multiple sequence types? > > Yes. Maybe not multiple sequence types within MPL itself; but then, I > see the multiple sequence types in MPL as syntactic candy offered by > a clever implementation (and proof that the meta-algorithms are truly > generic). It gives you confidence that using an MPL meta-algorithm > with a Loki typelist is possible and practical. If, for some reason, I > feel the need to create a custom typelist metatype, where am I to turn > when writing common algorithms with which it can operate? So far, > just MPL. Why wouldn't one of the stock typelists suffice? Perhaps > my application takes advantage of additional information in the > custom typelist. Such as what? These arguments aren't any good when they boil down to a lot of "maybe-s", "what-if-s", and "some time down the road-s." What about something like: "I need a custom typelist metatype right now because the MPL doesn't provide what I need."? Something like that would help significantly, both toward your argument and toward the betterment of the MPL in general. > > IMO, the correlation to the STL breaks down at this point. > > That's because you're still stuck on vector vs. list, which isn't the big > picture, IMO. What is the big picture then? That you can incorporate many different implementations of exactly the same thing? I buy the "syntactic sugar" argument far more than this. Paul Mensonides"
"----- Original Message ----- From: "Dean Michael Berris" <mikhailberis_at_[hidden]> To: <boost_at_[hidden]> Sent: Saturday, November 08, 2008 4:56 PM Subject: [boost] Interest in an Active Object CRTP "decorator"? > > Any interest in something like this to be included in Boost? > > --->8-- > [NOTE: untested, licensed under the Boost Software License, > Copyright 2008 Dean Michael Berris] > > template <class Derived> > struct active { > private: > shared_ptr<io_service> queue; > shared_ptr<io_service::work> sentinel; > shared_ptr<thread> lifetime_thread; > > protected: > active() : > queue(new io_service()), > sentinel(new io_service::work(*queue)), > lifetime_thread(new thread(bind(&io_service::run, queue))) > { > static_cast<Derived*>->init(); > }; > > ~active() { > sentinel.reset(); > lifetime_thread->join(); > static_cast<Derived*>->destroy(); > }; > > void post(function<void()> f) { > queue->post(f); > }; > > }; > > --->8-- > > Example usage would be something like this: > > --->8-- > > struct logger : active<logger> { > void init() { }; // required > void destroy() { }; // required > void operator() (string const & message) { > active<logger>::post(bind(&logger::write, this, string(message))); > } > void write(string message) { > cout << message << endl; > } > }; > Why the usual constructor is not enough -- init is called after active is constructed? IMO static_cast<Derived*>(this)->destroy(); is very dangerous. You are calling a function for an object that has already been destructed, so any access to Derived data is undefined. So ath the end whay do you need CRTP? Why do you need the usual constructor is not enough -- init is called after active is constructed? Best, Vicente"
"On 19-02-27 21:01:27, Shardul Parab via Boost wrote: >Hi! I am Shardul Parab, a computer science student from the Birla Institute >of Technology and Science, Pilani. >I am highly interested in contributing to Boost via GSoC 2019 and would >love to contribute to the GIL library(as per the project idea listed). I >believe that I have good practical experience of image processing >techniques and if given the opportunity would be a great learning >opportunity too. I have a decent experience with the library and would like >to ask as to whether there is any particular task that I could begin with >for the project and begin contributing from now itself under the guidance >of a mentor. Here are a few references you should find useful while working on your proposal: 1. I suggest you to read through the Boost GSoC overview, especially the "What students should do now" section and pages linked from there https://github.com/boostorg/boost/wiki/Google-Summer-of-Code%3A-Overview 2. Add overview of your proposal to Boost.GIL section here https://github.com/boostorg/boost/wiki/Google-Summer-of-Code:-2019 3. Check GIL's README; you may consider subscribing to boost-gil list and joining the Gitter room https://github.com/boostorg/gil/blob/develop/README.md#community 4. Become familar with GIL's development guidelines https://github.com/boostorg/gil/blob/develop/CONTRIBUTING.md If you have any specific question related to any of those resources, please, do not hesitate to ask! Good luck! Best regards,"
"This looks to me like some sort of artifact from the test library. Robert Ramey Douglas Gregor wrote: > Boost Regression test failures > Report time: 2007-07-02T06:53:16Z > > This report lists all regression test failures on release platforms. > > Detailed report: > > http://engineering.meta-comm.com/boost-regression/CVS-RC_1_34_0/developer/issues.html > > 1 failures in 1 libraries > serialization (1) > > >> serialization| > test_list_xml_warchive_dll: msvc-8.0 > _______________________________________________ > Unsubscribe & other changes: > http://lists.boost.org/mailman/listinfo.cgi/boost"
"At 10:02 AM 9/17/2002, Martin Schuerch wrote: >The same problems as recently reported for exception.cpp happens in >operations_posix_windows.cpp, when the project is set to unicode. > >It compiles in unicode and multibyte, when the follwing types and functions >are used in the char-version: > ># define BOOST_SYSTEM_DIRECTORY_TYPE WIN32_FIND_DATA: WIN32_FIND_DATA -> >WIN32_FIND_DATAA > >FindFirstFile -> FindFirstFileA > >GetFileAttributes -> GetFileAttributesA > >GetFileAttributesEx ->GetFileAttributesExA > >CreateDirectory-> CreateDirectoryA > >RemoveDirectory->RemoveDirectoryA > >DeleteFile->DeleteFileA > >MoveFile->MoveFileA > >CopyFile->CopyFileA > >GetCurrentDirectory->GetCurrentDirectoryA Thanks, I'll fix it. For those of you wondering what we are talking about, the Win32 API documents a bunch of functions operating on narrow strings, but they are really implemented as macros. So depending on macro definitions, they may unexpectedly start trafficking in wide char strings rather than narrow char. A trap for the unwary. The fix is to avoid the macro names, and use the names of the functions being forwarded to. --Beman --Beman"
"David Abrahams wrote: > While Rene was wrangling fonts I forgot that I went through this whole > process with Bill Venners of Artima. We ended up with a very different > answer, because Bill abhors the idea of specifying a font size; he wants > to respect peoples' preferences. I would appreciate it if everybody > would check out: > > http://www.artima.com/cppsource/metafunctions.html > > and see how it compares with Rene's page at > > http://redshift-software.com/~grafik/boost/index.htm > > on your sundry browsers. I don't have an idea of which one is better, > but we should at least get the benefit of that research. The first page (Aritma) uses the font size *I* specified, while the second page seems to use a smaller font. Obviously, I think the first is preferable. (Firefox 1.0, screen size 1600x1200) Regards, Daniel"
"2011/3/9 Jeffrey Lee Hellrung, Jr. <jhellrung_at_[hidden]>: > On 3/9/2011 11:14 AM, Steven Watanabe wrote: >> >> AMDG >> >> On 03/09/2011 10:11 AM, Joachim Faulhaber wrote: >>> >>> 3.2.3 Specialization of boost::is_integral<T> >>> ============================================= >>> >>> You'd have to provide an instantiation of boost type trait >>> boost::is_integral for xint::integral_t, so meta code that is >>> implemented for all intergal types will be able to work with xint >>> instantly. >> >> I disagree. xint::integer_t is not an integral type >> as defined by the standard. [basic.fundamental] > > +1 that depends ... I am not aware, that boost::is_integral is limited to fundamental types. Maybe there is a degree of freedom for interpretation here, I may be wrong. Anyway, from the perspective of my library I need to identify general type traits, e.g. if a type has a least steppable unit that makes it discrete. As a sufficient condition I can use boost::is_integral<T> on built in types. > > One would need an alternate metafunction for such purposes. > std::numeric_limits<T>::is_specialized && std::numeric_limits<T>::is_integer > ? I wouldn't connect this with numeric_limits (1) bigint is typically limitless ;-) (2) std::numeric_limits couples different metafunctions (depreciated design) that should better be independent."
"On 08-10-2013 00:43, Gavin Lambert wrote: > On 10/7/2013 10:48 PM, Quoth Thorsten Ottosen: >> If the idea is to be 100% shared_ptr interface compatible, it may be >> easier just to extend boost::shared_ptr a little: >> >> typedef boost::shared_ptr<boost::non_nullable<T>> SharedT; > > I don't like that. > > If you're suggesting using a wrapper type without changing shared_ptr, > that won't work because the shared_ptr itself could still be empty, so > you haven't gained anything. I'm not. > If you're suggesting specialising shared_ptr for that subtype, I don't > see any benefit in doing this over defining a new pointer type, since > you have to redefine everything in a specialisation anyway. I'm not. > And there's undoubtedly some existing templated code that operates on > boost::shared_ptr<T> that would be confused by this, Well, wouldn't that code use shared_ptr<T>::element_type? > or at the very > least not operate efficiently by including tests for null. I'm confused. What tests? Anyway, in Boost.PtrContainer you can change the "null behavior" by saying ptr_vector<T> vec_non_nulls; ptr_vector<nullable<T>> vec_with_nulls; The shared_ptr implementation would have to check its template argument and emit special code in a few places. This is very easy to do, and far easier than specializing/wrapping the class. >> typedef boost::shared_ptr<boost::non_nullable<T>> WeakT; > > I assume that was a typo. (Weak pointers are not especially useful > without being able to represent null anyway.) Yes, sorry, a typo. I suppose there is still a need to break cycles. Why would this have changed. -Thorsten"
"Greg Colvin <Gregory.Colvin_at_[hidden]> writes: > At 09:53 AM 1/31/2003, David Abrahams wrote: >>... >>In fact, I have been arguing for years that our smart pointers should >>never have had a public interface which adopts unmanaged resources on >>construction. Instead, we should write: >> >> std::auto_ptr<T> = std::auto_ptr_new<T>(arg1, arg2, arg3); >> >>Voila, a managed T straight out of the box. > > And I proposed something like this years before that, but > foundered on not being able to declare a type-safe variadic > function in C++. The move/forwarding proposals will fix that. In the meantime we have boost::ref(x)... ugly but effective."
"Hi, Miki wrote: > Below is my sample code to use boost string algorithm in VS2005, using > platform Windows Mobile 6 Professional SDK. > > {code} > #define BOOST_NO_STD_LOCALE > #include <boost/algorithm/string.hpp> > > using namespace std; > > void main(){ > vector<string> strList; > string str = "aaa, bbb, ccc"; > using namespace boost::algorithm; > split(strList, str, is_any_of(" ,")); > } > {code} > > The compilation fails, because Windows Mobile 6 Professional SDK > doesn't have <locale> file. > > I found "boost\algorithm\string\classification.hpp" this file always > includes <locale> file, even that BOOST_NO_STD_LOCALE is defined > before. > > Is there any way to use string algorithm without the existence of std > locale file? StringAlgo is highly dependant on the std::locales. So there is no way yo use full functionality without locales. You may use parts of the library, that are not locale dependant, like find/replace algorithms, but you will need to include the specific .hpp files. Best regards, Pavol."
"On Monday, April 07, 2014 05:46 PM, Ben Pope wrote: > On Monday, April 07, 2014 05:20 PM, Andrey Semashev wrote: >> Hi, >> >> I'm seeing ICE in a test on BP x86_64 C++11: >> >> http://www.boost.org/development/tests/develop/developer/output/BP%20x86_64%20C++11-boost-bin-v2-libs-log-test-filt_matches_spirit_qi-test-gcc-4-8-2~c11-debug-threading-multi.html >> >> >> This seems to be happening only in develop. I cannot reproduce this >> with my >> local gcc 4.8.1. Does anyone know what could be the problem? > > I just ran the test and it passed. I should point out that it's my machine running that test. The output was: **passed** ../../../bin.v2/libs/log/test/filt_matches_spirit_qi.test/gcc-4.8.2~c11/debug/threading-multi/filt_matches_spirit_qi.test Also, I just ran the other failing test: **passed** ../../../bin.v2/libs/log/test/util_stp_filter_parser.test/clang-linux-3.4~c11_libc++/debug/threading-multi/util_stp_filter_parser.test Ben"
"On 2008-11-22, Tomas Puverle <Tomas.Puverle_at_[hidden]> wrote: > > Why would you ever want to create an empty container? To add stuff to it, but you can't do that with a range. > Let me give you an > example of one of the ways I use empty ranges, which I've found extremely > useful: > > typedef iterator_range<SomeIterator> MyRange; > > class MyIterator: public boost::iterator_facade<... MyRange > > { > private: > MyRange dereference() const > { > //if the internal representation is point to a valid entry (say > //in a file) return a set of valid iterators, otherwise return > //an empty range > if (...) > { > return MyRange(....); > } > else > { > return MyRange(); > } > } > }; > > typedef iterator_range<MyIterator> Range2; > > Range2 r1(...); > Range2 r2(...); > > Now one can work with these ranges recursively, because of the overloaded > operators of boost::iterator_range, e.g. > > r1 == r2; > or > r1 != r2; > > I can also write generic code which can take list of vectors of iterators or > perhaps can just read the data directly from the file representation or what > not. > > Now, there is no way to reproduce this behaviour with the new > implementation. > What sequence do those iterators iterate? I don't see what it could be that wouldn't let you get at least the PTE iterator even if the representation doesn't "point to a valid entry", so you ought to be able to just return MyRange(end, end); And the iterator range constructor is a perfectly legal container construct too, so it doesn't break your desire to use containers in the same code path. So I don't see how there "no way to reproduce" the behaviour, at least in the outline of code you provided."
"On Fri, May 16, 2008 at 9:03 PM, Daniel Walker <daniel.j.walker_at_[hidden]> wrote: > > It's still a vector of signatures. There are two kinds of signature > here (by convention or protocol): > > * int(int, int) is the usual C/C++ call signature > * plus(_1,_1) is our new emerging polymorphic signature by convention > Ok, now I understand, thanks, but still there is a fundamental difference between int(int, int) and plus(_1,_1), namely the first it's just an interface but the latter does real work, actually adds stuff. I try to explain myself better with an example starting from the normal functions case: int add(int a, int b) { return a + b; } int sub(int a, int b) { return a - b; } bool is_positive(int a) { return a > 0; } bool is_negative(int a) { return a < 0; } msf::function<mpl::vector<int(int, int), bool(int)> > f(add, is_positive); assert( f(3, 2) == 5); assert( f(6) == true ); f = sub; f = is_negative; assert ( f(3, 2) == 1 ); assert( f(6) == false ); Ok. Simple. Now extend to polymorphic case: struct add { template<class T> T operator()(T a, T b) { return a + b; } }; struct minus { template<class T> T operator()(T a, T b) { return a - b; } }; struct is_positive { template<class T> bool operator()(T a) { return a > 0; } }; struct is_negative { template<class T> bool operator()(T a) { return a < 0; } }; Now what I would expect for this generalization is: msf::function<mpl::vector<_1(_1, _1), bool(_1)> > f(plus, is_positive); assert( f(3, 2) == 5); assert( f(3.5, 2.5) == 6.0); assert( f(6) == true ); assert( f(6.7) == true ); f = minus; f = is_negative; assert ( f(3, 2) == 1 ); assert ( f(3.5, 2.5) == 1 ); assert( f(6) == false ); assert( f(6.7) == false ); So here we have: msf::function<mpl::vector<_1(_1, _1), bool(_1)> > not msf::function<mpl::vector<plus(_1, _1), is_positive(_1)> > because the vector of function signatures define the interface that function should have to be wrapped by the overload set, as you prefer to call it ;-), so also in polymorphic case the vector should keep "polymorphic signatures" that different polymorphic classes with the proper polymorphic signature should match to be _wrapped_ by the overload set, not to be the underlying function, replacing boost::function as you suggested. In this case boost::function should be replaced by a wrapper of polymorphic functors, not by _a_ polymorphic functor defined in mpl::vector at msf::function instantiation. Am I missing something? BTW I don't even figure up how this wrapper of poly objects looks like ! or if it even exist. >> This is _really_ totally different also from an implementation point >> of view. Indeed a MSF boils down to a hierarchy of operator=() each >> one defined on a given signature and each one forwarding to a >> corresponding boost::function > > I started looking more closely at your implementation, and I like the > way you do the class hierarchy. But the important part here is the > hierarchy of operator()s right? Yes. I meant that. It was a silly typo, I meant " a hierarchy of operator()" > This won't compile yet, but the change I'm think of > (starting from the msf_27_4_2008.zip version) would be something like > This is very old, now is out msf-1.1.zip and in few hours it will be out msf-1.2.zip with the improved interface for poly objects, namely the remove of set_polymorphic_object() and use of operator=() instead. I suggest to download one of the above because they are very different from the version you have. > > I'm sure there's more to it, but that gives you an idea. Of course, > the first thing you need is an nary version of polymorphic_function. > If you're serious about this and that's the direction you'd like to go > in, I'd be glad to start working on it tomorrow! > Great!! I'm very interested in polymorphic generalization too, but I would think is difficult stuff, too difficult for me alone ;-) Marco"
""Michael Glassford" <glassfordm_at_[hidden]> writes: >> FWIW, we're going to have problems doing that for the threads >> library if nobody can find Bill Kempf. > > I was going to mention this, too. FWIW, I'm still trying (to contact > him, that is). > > Also FWIW, I just added my name to the list. Great! Do you already have code in Boost with a different license?"
"On Thu, Oct 12, 2017 at 3:17 PM, Marcel Raad via Boost <boost_at_[hidden]> wrote: >> -----Original Message----- >> From: Boost [mailto:boost-bounces_at_[hidden]] On Behalf Of Klaim - >> JoÃ«l Lamotte via Boost >> Sent: Donnerstag, 12. Oktober 2017 15:10 >> To: Boost Developers List <boost_at_[hidden]> >> Cc: Klaim - JoÃ«l Lamotte <mjklaim_at_[hidden]> >> Subject: Re: [boost] MSVC 15.5 support >> >> +1, this have been discussed before and I believed this PR did fix it but >> it didn't. >> https://github.com/boostorg/config/pull/177/files > > This PR fixed it for the previous compiler update (in Visual Studio 2017 Update 3). Update 5's _MSC_VER is 1912. Shouldn't the config tests be ran and incorporated though?"
""Chris M. Thomasson" <cristom_at_[hidden]> wrote in message news:hgfqaj$k90$1_at_ger.gmane.org... > "Helge Bahmann" <hcb_at_[hidden]> wrote in message > news:alpine.DEB.1.10.0912101115460.456_at_m65s28.vlinux.de... >> On Wed, 9 Dec 2009, Anthony Williams wrote: >> >>>> So far I have not yet met any 64-bit platform that provides 64 bits of >>>> (user-space!) address space (the same cannot be said of 32-bit >>>> platforms), so I would say that any use of spare bits on 64 bit is >>>> safe (for user-space!). >>> >>> As Chris also noted, I would be wary of using them for ABA checking >>> though: it's easy to overflow a 16-bit counter quite quickly, and that's >>> all you've got even if the OS only uses 48 of your 64 bits for address >>> space. >> >> This concern is certainly valid for basically any algorithm that uses >> "generation counters" or similar constructs for disambiguation (it could >> be argued that even 32 bits may not be enough). Using spare bits at all >> should however be considered a valid technique. >> >>>> FWIW there are other ways to avoid ABA than tagging pointers, and >>>> without DCAS on 32-bit, see e.g. this sample implementation of a >>>> lock-free stack: >>>> >>>> http://www.chaoticmind.net/~hcb/projects/boost.atomic/stack.hpp >>> >>> Yup. Incidentally, you don't even need to count the nodes in push, >>> provided you're careful when reclaiming nodes in pop. >> >> hm, I'm not sure what you mean, I don't think I am counting anything but >> the number of threads in the critical section? >> >>> The downside of this technique is that if the traffic is too heavy then >>> the ref count never reaches zero, so the nodes can never be reclaimed. >> >> Right, and although I would argue that such a highly contended hotspot is >> a design flaw in itself, > > You have created a proxy garbage collector that reminds me of one I did a > long time ago which also suffered from this exact same problem. FWIW Helge, here is a new proxy garbage collector algorithm of mine that I am currently experimenting with: http://groups.google.com/group/comp.programming.threads/browse_frm/thread/a53f24de178b419f is basically a simplified version of the following lock-free algorithm: http://webpages.charter.net/appcore/misc/pc_sample_h_v1.html The new algorihtm is a *wait-free solution to the ABA problem and memory reclamation issues in general wrt non-blocking algorithms. The usage pattern is basically identical to you're collector wrt the following code: http://www.chaoticmind.net/~hcb/projects/boost.atomic/stack.hpp you do it like: __________________________________________________________________ bool pop(T &data) throw() { enter_crit(); node * n=stack.pop(); if (n) { data=n->data; expired.push(n); } leave_crit(); return n!=0; } ___________________________________________________________________ The equivalent code for my collector would be: ___________________________________________________________________ bool pop(T& data) throw() { proxy_type::collector& c = m_proxy.acquire(); node* n = m_stack.pop(); if (n) { data = n->m_data; m_proxy.collect(c, n); } m_proxy.release(c); return (n != NULL); } ___________________________________________________________________ [*] The algorithm is wait-free in practice on systems with native fetch-and-add and swap instructions like x86-32/64. If the architecture forces you to implement fetch-and-add with a damn LL/SC or CAS loop, well, then it's not really wait-free now is it? No, I am afraid it's lock-free, or whatever semantics the LL/SC is which could even be obstruction-free. Sad... ;^(..."
"On Mon, Jan 13, 2014 at 12:36 PM, Peter A. Bigot <pab_at_[hidden]> wrote: > On 01/13/2014 06:28 AM, Gennadiy Rozental wrote: > >> Peter A. Bigot <pab <at> pabigot.com> writes: >> >> Below is an annotated sequence of (bash) command-line git operations >>> that I used in a local copy of Boost.Test to understand what was >>> happening in it, with no intention of proposing this be what the >>> maintainers actually do with the module. >>> >> Thank you. I need to get my hands dirty and finally switch to git >> locally. At >> some point I'll need this (I hope ;)) >> > > In the interests of reducing pain: I recommend against using those steps. > > The problem, of course, is that your procedure is overwhelmingly complex for a new git user. That's why the docs we've been working on try to stick to very basic git. Since Gennadiy hasn't even begun to use git, he might be better off starting with https://svn.boost.org/trac/boost/wiki/ModularBoost --Beman"
"Long time ago I asked whether operator.hpp could support the other version of non-commutative operators like friend T operator-(const U& x, const T& y) { T x1(x); return x1 -= y; } --- In boost_at_y..., "David Abrahams" <david.abrahams_at_r...> wrote: > > ----- Original Message ----- > From: <helmut.zeisel_at_a...> > > > I would appreciate an additional related > > family of operator templates. > > Why don't you submit a proposed patch (including one for the documentation)? Below are the additional operators struct I use in my current implementation of big_int (already using the additions of Daryle Walker from May 2001 to operators.hpp). subtractable2_left, dividable2_left and ordered_field_operators could also be used to simply interfaces such as rational.hpp. For the structs you accept for operators.hpp, I will add the necessary documentation. If you prefer different names for some structs, it will probably be no problem for me. Helmut template <class T,class B=::boost::detail::empty_base> struct ring_operators1 : additive1<T , multipliable1<T, B > > {}; template <class T,class B=::boost::detail::empty_base> struct field_operators1 : additive1<T , multiplicative1<T, B > > {}; template <class T,class B=::boost::detail::empty_base> struct ordered_field_operators1 : field_operators1<T , totally_ordered1<T, B > > {}; template <class T,class B=::boost::detail::empty_base> struct euclidian_ring_operators1 : ring_operators1<T , dividable1<T , modable1<T,B > > > {}; template <class T,class B=::boost::detail::empty_base> struct integer_operators1 : totally_ordered1<T , euclidian_ring_operators1<T , unit_steppable<T,B > > > {}; template <class T,class B=::boost::detail::empty_base> struct bitwise_integer_operators1 : integer_operators1<T , bitwise1<T,B > > {}; // // "left" means that the argument of other class U // is applied from left. // template <class T, class U, class B = ::boost::detail::empty_base> struct subtractable2_left : B { friend T operator-(const U& x, const T& y) { T result(x); return result -= y; } }; template <class T, class U, class B = ::boost::detail::empty_base> struct dividable2_left : B { friend T operator/(const U& x, const T& y) { T result(x); return result /= y; } }; template <class T, class U, class B = ::boost::detail::empty_base> struct modable2_left : B { friend T operator%(const U& x, const T& y) { T result(x); return result %= y; } }; template <class T, class U, class B = ::boost::detail::empty_base> struct ring_operators2 : additive2<T,U , subtractable2_left<T,U , multipliable2<T,U,B > > > {}; template <class T, class U, class B = ::boost::detail::empty_base> struct field_operators2 : ring_operators2<T,U , dividable2<T,U , dividable2_left<T,U,B > > > {}; template <class T, class U, class B = ::boost::detail::empty_base> struct ordered_field_operators2 : field_operators2<T,U , totally_ordered2<T,U,B > > {}; template <class T, class U, class B = ::boost::detail::empty_base> struct euclidian_ring_operators2 : ring_operators2<T,U , dividable2<T,U , dividable2_left<T,U , modable2<T,U , modable2_left<T,U,B > > > > > {}; template <class T, class U, class B = ::boost::detail::empty_base> struct integer_operators2 : totally_ordered2<T,U , euclidian_ring_operators2<T,U,B > > {}; template <class T, class U, class B = ::boost::detail::empty_base> struct bitwise_integer_operators2 : integer_operators2<T,U , bitwise2<T,U,B > > {};"
"--- Thomas Witt <witt_at_[hidden]> wrote: > -----BEGIN PGP SIGNED MESSAGE----- > Hash: SHA1 > > John Maddock wrote: > | > | One final point - there was a reason that I moved > regex to use automatic > | library selection and ABI fixing - without it I > was getting a tonne of > | support requests along the lines of "Your library > doesn't work, it just > | crashes when I call anything", which almost always > turned out to be caused > | by ODR violations (either the user had changed an > ABI option, or had > linked > | to the wrong runtime-library-build variant), these > basically stopped > | overnight once I modified my code to stop those > (this was all in pre-boost > | days BTW). > > FWIW I do believe that automatic library selection > is a broken concept > in praxis. It causes no end of problems when there > is more than one > library that does it. In the end you end up with the > same situation as > before the user has to know about the different > runtime libraries and > how to handle them. > > Furthermore I do believe that dependencies should be > something that the > programmer is aware of and that they should be > actively managed by the > programmer. Automatic library selection hides > dependencies sometimes up > to the point that dll's aren't shipped to the > customer. > > Said that I can see your point John. I agree with John. I'd be much better if boost provided a clear description on how to build the library manually. I am having a bunch of problems with automatic boost builds especially when they include dlls. I also think that exporting C++ classes is a broken concept too. It is even worse than the automatic builds. Just my $0,02 Eugene __________________________________ Do you Yahoo!? Yahoo! SiteBuilder - Free, easy-to-use web site design software http://sitebuilder.yahoo.com"
"shunsuke wrote: > Hi, > > For some msvc-7.1 bug, if you pass an array to boost::begin, > a form `range_iterator<const T>` in > > template< class T > > inline BOOST_DEDUCED_TYPENAME range_iterator<const T>::type begin( const T& r ); > > knocks down the partial specialization system of msvc-7.1. > > I might find a workaround. Well, my local complicated tests passed. The patch for range/iterator.hpp has been uploaded. http://svn.boost.org/trac/boost/ticket/1309 Regards,"
"Hi Alex! You can check out http://cpp-netlib.wiki.sourceforge.net/ -- we have some documentation there. We already also have a mailing list, and are discussing some pertinent issues which might be interesting to you as well. As for the structure, we're currently building upon a common message type -- and Peter Simons has already implemented an RFC2822 (?) parser, which I think will grow to include a lot more parsers for other RFC's. We're looking at moving network-protocol specific implementations in their own namespaces -- HTTP parsers are in something like network::http::parser for example. There are other things which need some more attention, and we're currently discussing them in the cpp-netlib developers mailing list. If you're interested in joining that discussion as well, you can hop on over to http://tinyurl.com/32tyzd (links to cpp-netlib-devel sourceforge mailing list archives) and subscribe to the mailing list. :) Thank you very much for the interest! (I should be able to add you to the project if you want to be part of the effort). :)"
"On February 16, 2014 5:13:24 PM EST, Vladimir Batov <Vladimir.Batov_at_[hidden]> wrote: >On 02/16/2014 08:35 AM, Andrzej Krzemienski wrote: >> >> I have a suggestion regarding the documentation. It is abut the first >page. >> I am expressing my preference, but I am pretty sure I am not the only >> person here with this expectation. I am a very impatient man and I >expect >> of the first page a number of answers quickly, or otherwise I will be >not >> interested. When I see "Conversion" in the name of the library, I >will need >> the following questions answered quickly (I guess I am not more >arrogant >> than an average stressed programmer): >> >> 1. Is it only string to T and T to string conversions, or arbitrary T >to U >> conversion? >> 2. Will it consider locale? >> 3. Will it return optional<T> (or some such) so that I can decide >myself >> how to deal with conversion failure? >> 4. How will I use it. Give me a minimum example. >> >> In other words, I need to see from the first page what this library >will >> and will not give me. > >I've extended the Introduction section to address your #1&2 comments. >As >for #3&4 I suspect I am lacking the ability to express myself >succinctly >enough to squeeze those into the Introduction... without turning it >into >"War and Peace"... which would work against me with the impatient kind. >;-) > >> I would also suggest not to start with the comparison with >lexical_cast. >> Your users may not even know lexical_cast. Also, there is something >> discouraging when I read how your library differs from some other >library >> rather than learning what your library is. >I see your point. Unfortunately, I feel somewhat paranoid as >lexical_cast comparisons dogged my V1 proposal all the way through. >Back >then people's reactions were quite natural -- we already have a >conversion API which seems to be a potentially suitable foundation; why > >not use it? They were at the beginning of the "road" I already went >but >I had to answer the same (not always kind and polite) questions about >lexical_cast over and over again. And youngsters are usually "quick >shooters" -- quick and easy with grandiose statements and opinions, >slow >and reluctant with their own research beforehand. So, now I put in >(indeed) a lot of stuff related to lexical_cast -- design, performance, > >functionality comparisons... just in case... in fact, if we get to the >review/discussion stage, I am sure people will be asking -- why not >lexical_cast, why does not it behave like lexical_cast? >> Two other suggestions for the initial page. 1. Mention that it works >with >> non-DefaultConstructibel types. It is unusual (in the positive sense) >for a >> conversion library. 2. Since you mentioned that convert can be used >without >> specifying the second (streamer) argument, show this in the initial >> example: let it be really simple. >I hope I've addressed your #1 in the Introduction section. Please see >if >you find it satisfactory. As for #2 I have to admit I reconsidered my >original position. Indeed, I had the converter parameter in >convert<T>::from(value_in, converter) defaulted to sstream_converter in > >my own code. Because I was lazy and did not care for its performance (I > >have other chunks "eating" so much more). > >Now, as I put it up for everyone to see, it's a different story. My >original lazy approach had two drawbacks -- convert/api.hpp had >sstream_converter.hpp included (an unnecessary coupling) and >convert<T>::from was creating a converter every time it was called. As >I >described in the Performance section it has quite a detrimental effect >on performance. As I said, *I* am not concerned (for my current >applications)... but I do not want to give that loophole to people to >explore, discover that performance sucks in their settings and come >back >swinging... just the same why I took the implicit converter to T from >convert<T>::result as soon as you mentioned it -- I *personally* find >it >very convenient (no need for "value") but defending it is a loosing >battle IMO. > >> And one other thought (it is not really a suggestion for >Boost.Convert, but >> a general observation regarding string conversions). Your library is >mainly >> about converting string to T. T to string will be less common. >Hmm, here with all due respect I really have to disagree on various >levels. :-) > >In my neck of the woods, string-to-T and T-to-string are represented >quite equally. Say, we consider the management of configuration files. >Reading values (string-to-T) from cfg files is (to me, anyway) on the >same scale as writing updated values back (T-to-string). Same goes for >a >component in a processing pipe or a node in a network -- >reading/converting a lot of XML, converting/writing a lot of XML. >> And I find >> it hard to imagine that someone would use it as T to U conversions. >Again, I am far from sure about that. I do currently have to have >OS-native MBCS (MSWin and Solaris) to UCS-2 and UCS-4 string >conversions. They are a separate lib. Can't immediately see anything >wrong in incorporating it into the 'convert' framework. Then I remember > >Vicente having a 'conversion' proposal to address that T-to-U >conversion >in a generic way. So, he must have had a need for it also. I am not >saying you are wrong. I just do not know. Consider the templates >example. Stroustrup purposefully designed them in a generic way. Their >deployment exploded often in surprising ways. I am certainly no >Stroustrup but you get the idea. >> When >> converting from T to string, you do not really need to return >optional<T>, >> because it is not possible that this conversion can fail. Any T >always has >> a string representation, doesn't it? I wonder (but I do not have a >good >> answer) if conversion in this direction should have the same >interface. >Uhm, I would not be that quick saying that T-to-string conversion can >never fail. It depends on complexity of the conversion and the used >character set, etc. What if T is a complex class which in its >conversion >depends on other classes to behave and they don't? What if the >conversion depends on, say, formatting specification and it is not met >or is invalid? > >On top of it, uniformity (and, therefore, predictability) of API and >behavior is quite important IMO. Special (and questionable I might say) > >handling of one special case IMO is not worth it (again IMO). > >V. > > > > > > > >_______________________________________________ >Unsubscribe & other changes: >http://lists.boost.org/mailman/listinfo.cgi/boost"
"Eric Niebler <eric_at_[hidden]> writes: > Maurizio, I didn't see this message the first time because for some > reason, all your messages appear out of order on GMane. Is the clock on > your computer wrong? Is it something you can fix? Should be fixed now. I noticed the problem yesterday when I started backing up to Amazon S3. > Maurizio Vitale wrote: >> I don't know if it is a bug or not, but I was surprised by the effect >> of a seemingly minor code change. >> > <snip> >> So I said to myself: let's get rid of all those operators and replace them with >> a single templatized version, like: >> >> template <typename Expr> >> struct my_expression : proto::extends<Expr, my_expression<Expr>, my_domain> { >> typedef proto::extends<Expr, my_expression<Expr>, my_domain> base_type; >> >> my_expression (Expr const& expr = Expr()) : base_type (expr) {}; >> >> using base_type::operator =; >> >> template<typename T> >> operator T () const { >> return static_cast<T>(proto::eval(*this, my_context<Expr> ())); >> } >> }; > > > OK, your expression wrapper has an implicit conversion to any type T. > That is, IMO, a bad idea, but nevertheless, proto shouldn't stop you > from doing that. The full plan is to later limit to a set of user specified (builtin) types. I cannot boost::enable_if the operator itself, but since I'll need a number of transformations as part of eval (among those quantization and overflow handling), I'll fail with as a meaningful error message as possible somewhere in the pipe. At least this is what I hope. So builtin_type v = expression should pass through the operator T() above, but my_int v = expression should not. I hope this will work without ambiguities, otherwise I'll clearly remove operator T () here. Does the plan still sound bad? > I think I have fixed the problem in CVS. Thanks a lot. > Incidentally, you were running into an ambiguous conversion deep in the > guts of callable_context, which uses an implicit conversion to a hidden > type to detect whether your context has an overload of operator() that > accepts the current expression. The code now uses a less-preferred > conversion, avoiding the ambiguity with yours. I take this is the explanation why operator T() above had problems. Best regards, Maurizio"
"The idea of segmented fusion sequences and algorithms has been discussed here several times, and Joel has made some reference to some earlier work I did in this area. I had done some tests at the time that suggested that a segmented sequences and algorithms could significantly outperform nonsegmented variants Fusion currently uses. Per Joel's suggestion, I went ahead and checked my code into CVS HEAD. All segmented-specific code is quarantined in separate ext_ directories. What I've just checked in: - fusion/algorithm/iteration/ext_/for_each_s.hpp for_each_s algorithm that works with segmented sequences - fusion/algorithm/query/ext_/find_if_s.hpp find_if_s algorithm that works with segmented sequences, and returns segmented iterators - fusion/sequence/container/ext_/tree.hpp Experimental segmented fusion tree - fusion/sequence/intrinsic/ext_/segments.hpp The segments() intrinsic for getting a segmented sequences' segments. - fusion/sequence/view/ext_/multiple_view.hpp Makes a value v appear as a tuple<V,V,V...>(v,v,v...) - fusion/sequence/view/ext_/segmented_iterator.hpp A generic segmented iterator that remembers its place in the traversal of any segmented sequence. - fusion/sequence/view/ext_/segmented_iterator_range.hpp Makes iterator_range of segmented_iterators a segmented range. - fusion/support/ext_/is_segmented.hpp The is_segmented trait. I've also checked in some basic tests for this stuff, and marked them "explicit" in the test Jamfile so they won't interfere with regular regression testing. I have not changed *any* standard Fusion files. If we decide to rip this out, it's as simple as nuking all the ext_ directories. Caveat: this stuff is half-baked. Use at your own risk. The hope is that by checking this in, others will take an interest and help flesh the implementation out, so dig in!"
"On Apr 22, 2014, at 1:51 AM, Steven Watanabe <watanabesj_at_[hidden]> wrote: > AMDG > > On 04/21/2014 02:28 PM, John Salmon wrote: >> <snip> >> I would love to see a boost implementation that captured and exposed >> this capability for general use. Thus, I think a better approach is >> as follows: >> >> - define a new "RandomFunction" concept that dscribes/enforces the >> essential, common features of the randomizing function in Threefry, >> Philox, ARS and other counter-based random generators. > > I don't think this is a particularly useful > abstraction. Most users should not care at > all about this, since they should be using > the predefined engine typedefs. If more > similar generators are added later, then the > implementation can be adjusted to factor > out the common boilerplate, but I really > don't see the point of creating a whole new > concept for this. > I'm still working a bit on the boilerplate and at some point it should be correct, then John and/or I could use it as a template for other similar engines and factor out the common elements. Additional engines should be easier because a lot of time is spend on the boilerplate and that will indeed be very similar across these engines. Since John knows all about the algorithmic parts and has implementations it should be easier to add those too. How about the following steps: * first finalize the current threefry submission and make sure that all aspects are boost compliant. That would finalize my initial mission. * check the scalability of the naming convention of the predefined typedefs. * then work on additional engines, possibly factoring our common boilerplate. For this I think John should take the lead? > In Christ, > Steven Watanabe > > > _______________________________________________ > Unsubscribe & other changes: http://lists.boost.org/mailman/listinfo.cgi/boost"
"Den 03-11-2011 09:12, Sergey Voropaev skrev: > Jeffrey Lee Hellrung, Jr.<jeffrey.hellrung<at> gmail.com> writes: > >> >> This came up just recently, e.g., >> >> http://comments.gmane.org/gmane.comp.lib.boost.devel/224758 > Sorry, I miss it. Good discussion. And now we have my example with compilation > error. >> >> I think the end result was an agreement that >> >> typedef typename boost::make_unsigned< difference_type>::type size_type >> >> would be a valid definition of size_type, so the only argument against >> making the change that I can see is breaking existing code (probably >> unlikely...?) and...inertia. Well, its /not/ unlikely that it will break code. > I did not find authors of "Range" in the discussion. I am afraid your fix will > be missed. It is good idea to write formal bug. Can you do it? I think the most obvious reason we (probabl me) did it like that is that iterator traits have no notion of unsigned types. The above make_signed<> thing could work, but still it will break code. The min() example that fails to compile is tricky. Even if we make it unsigned, size_types may differ (e.g. a 32 bit unsigned int and a 64 bit size_t). One could change min/max to use mpl::identity<T>::type to avoid a second conflicting type deduction, but then you get a warning inside min/max instead. In the end this means that you might as well make the conversion up-front, in your call to min/max. -Thorsten"
"Hello, attached is a patch that fixes a problem with the compile time GCD algorithm in the pool allocator library when BOOST_NO_INCLASS_MEMBER_INITIALIZATION is defined. The problem is, the value of a BOOST_STATIC_CONSTANT() is used as an argument for a nontype template parameter. The nontype template parameter is expected to have the type unsigned, which is only true if BOOST_NO_INCLASS_MEMBER_INITIALIZATION ist NOT defined. Otherwise, the type is an unnamed enum and the compile (vacpp 5) doesn't find the correct specialization for the template. A static cast fixes this. Unfortunately, the test for the pool allocator still doesn't pass. "/usr/local/src/boost-1.29.0-rc/boost/pool/pool_alloc.hpp", line 129.26: 1540-1108 (S) "void &" is not a valid type. "/usr/vacpp/include/list", line 48.31: 1540-0700 (I) The previous message was produced while processing "class boost::fast_pool_allocator<void,boost::default_user_allocator_new_delete,boost::details::pool::null_mutex,32>". The source line in <list> that triggers the error reads typedef typename _A::template rebind<void>::other::pointer _Genptr; Doesn't the pool allocator need a specialization for void? Markus *** ct_gcd_lcm.hpp.~1.5.~ Sat Aug 4 16:31:37 2001 --- ct_gcd_lcm.hpp Tue Oct 1 12:33:10 2002 *************** *** 33,49 **** template <unsigned A, unsigned B, bool Bis0> struct ct_gcd_helper; template <unsigned A, unsigned B> ! struct ct_gcd_helper<A, B, false> { ! BOOST_STATIC_CONSTANT(unsigned, A_mod_B_ = A % B); ! BOOST_STATIC_CONSTANT(unsigned, value = ! (::boost::details::pool::details::ct_gcd_helper<B, A_mod_B_, ! ::boost::type_traits::ice_eq<A_mod_B_, 0>::value>::value) ); }; template <unsigned A, unsigned B> ! struct ct_gcd_helper<A, B, true> { ! BOOST_STATIC_CONSTANT(unsigned, value = A); }; } // namespace details --- 33,51 ---- template <unsigned A, unsigned B, bool Bis0> struct ct_gcd_helper; template <unsigned A, unsigned B> ! struct ct_gcd_helper<A, B, true> { ! BOOST_STATIC_CONSTANT(unsigned, value = A); }; template <unsigned A, unsigned B> ! struct ct_gcd_helper<A, B, false> { ! BOOST_STATIC_CONSTANT(unsigned, A_mod_B_ = A % B); ! BOOST_STATIC_CONSTANT(unsigned, value = ! (::boost::details::pool::details::ct_gcd_helper< ! B, static_cast<unsigned>(A_mod_B_), ! ::boost::type_traits::ice_eq<A_mod_B_, 0>::value ! >::value) ); }; } // namespace details"
"> -----Original Message----- > From: boost-bounces_at_[hidden] [mailto:boost- > bounces_at_[hidden]] On Behalf Of Vladimir Prus > > > It was discussed on boost-build list previously -- that's the way it > works > now -- adding custom variants derived from 'debug' makes 'd' disappear. Sorry. I was not aware of the discussion. > Where does "Getting Started" talk about custom variants? > Section 6.3 and footnote 7 talk about when "d" is added. "debug" variant was never mentioned there. The bottom line is the naming convention should be consistent with autolinking. Thanks, Sean"
"msvc-10 test results are now shown (thank you John): http://www.boost.org/development/tests/trunk/developer/type_traits.html Same as intel-linux 12: issue with deprecated ++ for bool. I have just pushed a patch to trunk (r74841) which makes has_{pre,post}_increment< bool >::value==false Works for me on gcc-4.6.1 and intel-linux 11.1 and 12.0. Hope everything is fine with msvc. If it is the case, I think it would be ready to merge to branch/release. Frédéric"
"On 5/6/2013 1:53 PM, Adrian_H wrote: > I've got a really annoying and difficult to track down PP error. I'm > attempting to use wave to see the expansion, but it is slow going. The > output is correct, in both the g++ PP and the wave parser. g++ states: > *error: macro "BOOST_PP_SEQ_ELEM_III" requires 2 arguments, but only 1 > given*, wave states *warning: too few macro arguments: > BOOST_PP_SEQ_ELEM_III*, but when I try using the tracer it doesn't say when > this occurs. > > Is it possible to turn this on? Or is there no 'on' and I have to go into > the wave code and code it on? If the latter, where would I do this? You should be able to look at wave's output and see exactly the sequence of macro expansions which cause the error you are seeing."
"Jeffrey Bosboom wrote: > DE wrote: >> looking at traits class specialization i have a question: >> is there a reason defining integral constants as following? >> >> static cont int dim = 42; >> >> i mean if you do not take address of that member a better solution >> (imho) is to define an anonymous enum like >> >> enum { >> dim = 42 >> }; >> >> or in one line >> >> enum { dim = 42 }; >> >> rather than defining a global object >> > > An optimizing compiler will perform constant propagation, substituting > the value of the variable (in this case, 42) everywhere it is used. > If > the address of the variable is never taken, the compiler need not > actually have a memory location to hold it. I've had bad experience with optimizing compilers failing to perform constant propagation for static const int the way I expected and prefer enum to avoid such problems. I avoid all static declarations when possible. Regards, Luke"
"Vladimir Prus-3 wrote: > > vicente.botet wrote: > >>> On 11/17/2010 2:03 PM, vicente.botet wrote: > >> Do you mean that we need to update the bjam version when we update the >> Boost version? Is this >> written somewhere? > > The official procedure to build each release is: > > ./bootstrap.sh > ./bjam > > If you're using system-wide bjam, you should be prepared that eventually, > it will cease > to work. There will be better checking and reporting of required version > in future. > > Thanks Volodya, I will use it next time. Best, Vicente"
"Hello, I'm hoping to use boost voronoi to construct the (internal) medial axis for closed shapes (with holes). I need to work out which vertices of the voronoi are inside, outside and on a boundary. So my first goal is to determine which vertices correspond to the ends of the input segments (boundary vertices). The way I do this at the moment, is to look at each edge and test if its source vertex, vertex0(), is equal to either end point of the segment contained by the edge's cell. (1) If it is then it's a boundary vertex otherwise it's not. Is that correct? (2) When comparing a vertex with an input point can I do an exact compare (==) or should I use a tolerance (epsilon)? Thanks, fuzzy."
"On 24/03/2011 19:21, Gruenke, Matt wrote: > MSVC defines _M_IX86_FP, to indicate whether /arch was specified, and whether for SSE or SSE2. Unfortunately, it does not (currently) go beyond SSE2. > > Source: http://msdn.microsoft.com/en-us/library/b0084kay.aspx > > > > One possibility would be to require the user to manually define a macro, when using such compilers. > > > Matt Which I already said. It is also completely orthogonal; /arch is more like an equivalent of the -mfpmath GCC option. It does not control availability of instructions, but rather what instructions are generated for the floating point operations (as the name _M_IX86_FP clearly reflects)"
"Might I suggest that a useful approach for Boost to take in making a GUI library would be to create a number of reusable components that would be useful to anyone writing any kind of application framework. Since he released ZooLib, its author Andy Green has had some interest in doing this sort of thing, making a low-level library for use in application frameworks. While some application frameworks have advantages over others, choosing a particular one sets some major design decisions in stone from the very start of a project. It is advantageous that there should be a number of different frameworks so that the different alternatives can be explored and possibly be readily used. But every application framework author faces the same issues when they set out to write a new one or bind to a new platform - one common thing everybody does is write a wrapper of some sort around operating-system-specific windows. Another example that would be useful to any GUI developer would be the bitmap iterators I'd like to develop. While I will be writing mine for ZooLib, one could make such things adaptable to any bitmap definition using a traits parameter to a template, and make adapters to enable their use in any application framework. I haven't looked at it yet, but the Netscape Portable Runtime looks like it would be this sort of thing too: http://www.mozilla.org/docs/refList/refNSPR/ it provides platform-independence to non-GUI operating system facilities, as described on this page: http://www.mozilla.org/docs/refList/refNSPR/moddesc.html Mike"
"Andy Little wrote: > "Tobias Schwinger" wrote > Andy Little wrote > >>>I have just been reading n1792 "A modest proposal fixing ADL". In it Herb >>>Sutter states that only two compilers of those tried VC8 and Com4.3.3 do ADL >>>correctly, so maybe this is behind your problems. >> >>It definitely isn't - the case cited is much clearer than the one in the article. >>Further, ADL *is* working correctly on the same operator and the same types in >>a different context. > > Sorry about that. I've been going round and round trying to find out what I did > wrong, but this time it does seem that I am right that the compiler is wrong > ... so to speak. If so its very disappointing. I had been looking forward to > using VC8 I'm sure it can be worked around (the one way or the other). > I tried out the example. VC8 doesnt seem to like operator + much does it? or - / > * for that matter. Well, we're talking about two (probably closely related) bugs here: 1) The deduction in boost::spirit::operator+ fails (which can -for some odd reason- be worked around by overloading the operator). 2) ADL doesn't work. When using the commented line (instead of "using namespace...") in this part // using boost::spirit::anychar_p; using namespace boost::spirit; // ADL doesn't seem to work, either but I could live with this problem ;-) of the code, the operator isn't found at all. The commented line is perfectly enough in the non-templated case, though (the case you get if MAKE_THINGS_FAIL is not defined). Also note that these problems are not limited to operators -- they applly to functions in general. > > What should be done about it. Should someone start reporting this to the folks > at Microsoft or what? > Definitely. But we should first minimize the case and try to find out what exactly causes VC8 to turn off ADL (the same situation probably also activates bug1, above). How does the declaration of your operator- look like? Does it instantiate templates that use sizeof- or conditional tricks (as BOOST_TYPEOF_TPL does)? There must be /something/ going on, because for "pure expression templates" (e.g. Spirit without Typeof) ADL works fine. There would be problems with other Boost libraries as well, I figure. Here's a suggestion for a rather pragmatic solution: // at root namespace #if BOOST_WORKAROUND(BOOST_MSVC,BOOST_TESTED_AT(1400)) && BOOST_MSVC >= 1400 using [...] operator [...]; using [...] operator [...]; [...] #endif if that won't help, define the operators at root namespace for that compiler. Of course you should use restricted parameters rather than fully general templates that match everything: // This one means trouble when injected into the root namespace template<typename T0,typename T1> typename result<T0,T1>::type operator-(T0 const &, T1 const &); // This one should be mostly (because implicit conversion ctors in // boost::pqs::some_template could still cause trouble) harmless. template<typename T0,typename T1> typename result<T0,T1>::type operator-(boost::pqs::some_template<T0> const &, T1 const &); Regards, Tobias"
"On 17 Sep 2013 at 16:36, Beman Dawes wrote: > * While we might want help packaging maintainers, do we actually want to > host package management on Boost? If so, which package management tools? > There are a number of popular ones out in the wild. > > * How does NuGet relate to Ryppl? AFAIK, NuGet is just for Windows/Visual > Studio users. So while we wish NuGet well, our long term interest is in > something much broader than any one platform and much broader that just > package management. It seems to me that if you could convert bootstrap.bat to MSBuild, then packaging up Boost as NuGet ought to be fairly straightforward. Niall"
"I click on http://groups.yahoo.com/group/boost/files/YANL.zip and I get a yahoo groups page saying, "The requested file or directory is not found on the server." Could you just email it to me? <danw@(nospam)raytron-controls.com> I got sources I wrote years ago for angle types and trig functions. My primary intent was speed, rather than portability, and most functions are implemented in MMX/3DNow! inline assembly :), but they work, and you might find useful stuff in them. I defined also a type of fixed.point arithmetic, mod 2pi angle type (that can accumulate angle differentials ad-infinitum without losing precision) and that re-computes and caches sine and cosine values, for use with angles that seldom change, but often need trig values taken from. My question about angles was a bit philosophical, though: They use units (cycles, quarter-cycles, radians, degrees) but they are dimension-less. Are there any other such animals, besides angles?"
"Hi, ----- Original Message ----- From: "Jeffrey Hellrung" <jhellrung_at_[hidden]> To: <boost_at_[hidden]> Sent: Saturday, October 24, 2009 9:53 PM Subject: Re: [boost] [conversion] Motivation for two NEW generic conver_to and assign_to functions > > vicente.botet wrote: >>> Two comments (for now): >>> >>> 1) It's not uncommon that conversion to a "To" type from a "From" type >>> needs more information than just an instance of a From. One example >>> would be when dynamic memory allocation is necessary to construct the To >>> type, e.g., when converting from a boost::array to a std::vector. >> >> How do you know the To to which do you want to convert, if not given explictly? > > It is given explicitly. > >>> In my >>> application, I have to "upgrade" (i.e., convert) extended-but-fixed >>> precision floats (which are statically allocated) to arbitrary precision >>> floats (which are dynamically allocated), and the allocator_type of the >>> arbitrary precision float shouldn't generally be default-constructed. >>> I've worked around this by requiring my generic convert function to take >>> a ConvertPolicy parameter (defaulted to some empty struct >>> null_convert_policy_t), whose interpretation is up to the particular >>> overload chosen for the conversion. I wouldn't mind seeing a better >>> system in place. Have you considered this situation? >> >> >> I'm interested on seen how you have solved the problem you found. and please could you post your example and show why it can not be specialized with the proposed convert_to or assign_to interface? Non conforming use case will improve the final library. > > I use overloads of the following signature: > > template< class From, class To, class ConvertPolicy > > To convert(const From& from, type_tag<To>, const ConvertPolicy& > convert_policy) > > struct type_tag is just an empty struct used to avoid having to provided > the "To" template parameter explicitly. I thought maybe a function > signature which didn't require explicit template parameters to call > might be more ADL-friendly, but admittedly I have nothing to back this > up with... Do you mean that in order to use ADL you need to include the type_tag<To>? > For (one of) my specific use cases, I need to convert among user-defined > numeric types, some of which are statically allocated and some of which > are dynamically allocated. Or even a conversion from double to some > dynamically-allocated numeric type might be desired. Either way, > converting to a dynamically-allocated numeric type (think an > arbitrary-precision rational) needs an allocator to construct it, so how > would you convert a double to an arbitrary_precision_rational< T, > allocator_type > without additionally providing an instance of > allocator_type? The convert function work well from converting one type in another. Well I would try wit this conversion arbitrary_precision_rational< T, allocator_type > convert_to<arbitrary_precision_rational< T, allocator_type >, std::pair<double, allocator_type > >( std::pair<double, allocator_type > from); And use it as double d; arbitrary_precision_rational< T, allocator_type > apr = convert_to<arbitrary_precision_rational< T, allocator_type > >(make_pair(d, allocator_type())); So the general case don't pay for the specific one. Do you find something wrong with this approach? > To get around this issue, I ultimately pass an instance of the > allocator_type as the ConvertPolicy parameter, and it is interpreted > appropriately by the specific overload that implements the conversion > from double to arbitrary_prec...< T, allocator_type >. > > Of course, this begs the question: How does the code that calls > "convert" know to pass allocator_type as the ConvertPolicy? It > generally doesn't, of course, so it also needs to be provided a > ConvertPolicy parameter by *its* client. At some point up the call > hierarchy (even if this has to be at main scope), it is known what > family of types one needs to convert among, hence the appropriate > ConvertPolicy would be known and initiated then. > > Is that an adequate explanation? Yes. I understand now your use case, and how you have solved it. >>> 2) Assuming I understand the Conversion library correctly, what are the >>> advantages to using both overloading via ADL and function template >>> specialization as opposed to just the former? I'm not familiar of any >>> other free functions used in boost (or anywhere else, for that matter) >>> that rely on (perhaps I should say "allow"?) function template >>> specialization, so I'm wondering what the motivation and pros/cons are >>> (cons other than compiler support). I would guess that function >>> template specializations must reside in the same namespace as the >>> primary template...? >> >> The single think I can answer is that the same question is already on the documentation, unfortuantley with no answer. >> The answer I can give you now is that I don't master ADL to the point of using it to imlement what I have in mind. I'm unable to saying you if this is possible or not. The question of using partial specializations of template functions is for the moment secondary, if there is a better way to achieve the same goal. My main concern is if we need the generic functions convert_to and assign_to. If this can be implemented in a better way using only ADL, we could do this way. Of course I'm intersted in knowing how this can be implemented using only ADL, even if this is evident for most of you. >> >>> This is definitely a problem that needs to be solved (correctly) in a >>> generic fashion, so I'll try to follow your progress. >> >> I'm open to any sugestion. If we can implement it using only ADL, I will do it once I'll know how. > > You might want to read Herb Sutter's GotW articles on ADL, linked from > Wikipedia: > > http://en.wikipedia.org/wiki/Argument_dependent_name_lookup Thanks for the pointer. >> BTW, can we add functions on the 'std' namespace? > > I've got the feeling that this is generally frowned upon, but not sure... :/ If it is not possible, how can ADL help to convert std::pair<A,B> to std::pair<C,D>? IMO, we need partial specialization to cover this case. I start to understand how ADL can simplify things. Maybe I can do as the bosst::swap function does. Either: * A function with the signature convert_to<Target>(Source const&) is available via argument dependent lookup Or: * A template specialization of boost::conversion::convert_to exists for Target and Source Or: * Target is copy constructible from Source (default implementation) namespace boost { namespace conversion { // include here my current implementation of convert_to template <typename Target, typename Source> Target convert_to(const Source& val) { return Target(from); } }} namespace boost_convert_to_impl { template <typename Target, typename Source> Target convert_to(Source const& from) { using namespace boost::conversion; //use boost::conversion::convert_to if ADL fails convert_to<Target>(from); } } namespace boost { template <typename Target, typename Source> Target convert_to(Source const& from) { ::boost_convert_to_impl::convert_to<To>(from); } } And use the tag_type<Target> trick if needed for ADL. Do you think that this interface is more satisfactory? Best, Vicente"
"Hello Matt, Take a look at http://www.hpl.hp.com/personal/Hans_Boehm/c++mm/atomics.h.txt and at http://www.hpl.hp.com/personal/Hans_Boehm/c++mm/ in general before you start. The first page describes the atomic library interface which we discussed in April at the Berlin meeting. A stable implementation of the proposed API would definitely be useful although this API may change later. I am also not sure how much can be achieved until compilers support the proposed memory model. Valentin Sunday, April 30, 2006, 9:09:36 PM, you wrote: MC> For the past month or so I've been working on a concurrency library which MC> brings active types, atomic types, and parallel loop constructs and MC> algorithms to C++. I am familiar with some of the concurrency projects MC> already underway, though I'm sure my library would be able to coexist. MC> I plan on proposing through SoC sometime later this week. MC> Over the past two days I've also begun writing up some documentation using MC> QuickBook to give a general idea as to the design of the MC> library. Though I do have a lot of features already implemented, there MC> is still a very large amount of work to be done prior to completion. MC> Some feedback before I make the formal MC> proposal would be nice, and it'd also be great to see if anyone is MC> interested. Keep in mind that the documentation is only a rough outing and MC> so there are a few unconnected links, but I do include a brief introduction MC> and some basic usage examples including code snippets. The library is MC> reference to as Surge.Act as that is the namespace I use for my personal MC> libraries, though it will of course be changed to Boost.Act if it were to be MC> accepted. MC> http://members.gamedev.net/Rivorus/surge/html/index.html MC> For those familiar with the concept of futures and are confused as to why MC> they are not mentioned, I will be adding all of that information to the MC> rationale over the upcoming few days. I also apologize for not having better MC> code examples. MC> -- MC> -Matt Calabrese MC> _______________________________________________ MC> Unsubscribe & other changes: MC> http://lists.boost.org/mailman/listinfo.cgi/boost Valentin Samko http://val.samko.info"
"> joel falcou wrote: > > > Artyom wrote: > >>> Sure, boost ABI changes from release to release but unless > >>> you want to provide a "one-for-all" binary release of your > >>> library, what is the issue? Even libstdc++ ABI changes every > >>> now and then. > >>> > >> > >> Not correct. GCC keeps ABI since gcc-3.4... And this is > >> now about 6 years... Not bad? > >> > > Were people upset back then then ? > > Yes. What's your point though? It's surely impossible to hope > that a given binary library will be usable for decades. But breaking > ABI once in 6 years (if not more) is surely better than potentially > breaking ABI 4 times per year? > But these are different matters. The gcc ABI was changed to reflect the standard ABI back then. Boost, however, claims to be a working ground to establish practises to be eventually standardized. So ABI breaking comes with the terrain and is probably even useful in order to find the best practises which deserve standardization. Best regards, Isidor"
"> All the operations of linked_ptr are O(1). > > The time required to make a call to release() is constant, it does not > matter if there are 2 nodes or 2 million nodes in the linked_ptr list. > > It is true that because of a call to release, each node in the list > might have to do a tiny bit of work at some later time, this still does > not account into the efficiency of the individual operation. Each of > the subsequent operations is also O(1). Well, let's agree to disagree on accounting policy. Maybe this best sums it up: - operation time O(1) associated overhead O(N) (7..20)/100 * N by your figures associated side effect O(N) small constant. I'm more interested in the amortized effect that an operation has on the algorithm from which it is invoked (which is O(N)). Gavin"
"William E. Kempf wrote: > > Theoretically at least, I don't see why this would cause a problem. You > intentionally leak, but the leak is benign since it occurs only right > before the application exits. But most users won't code this way, nor do > I want to have to deal with the support requests/questions this would > cause. So, unless you have some suggestion as to how I can enable this > usage with out causing confusion, I'm not sure I'd care to re-enable > static builds. But you could probably fairly easily hack things to build > that way yourself. > No, I wasn't going to ask you to re-enable static linking because of this. As you rightly pointed out in the other thread, you have to make the library safe for all possible cases which is what you are doing. If we did decide to go this route, then we would certainly handle building the lib ourselves. Our problem with DLLs is this: We work on many projects. Some are in maintenance only mode, so don't get many updates. The next project may use boost-1.30.0 and then go into maintenance. I may then be working on a project which uses boost-1.32.0 and would like to keep both dlls available on the system. Current idea for doing this is re-naming the boost dlls to boost_thread-1.30.0.dll etc so that I can have 1 bin directory with all the dlls in, and each project would link and use the correct dll. I wonder if support for this could be built into the builds? Cheers Russell"
"At 03:09 AM 9/14/2002, Terje Slettebø wrote: >I think OP's point was to alert us to the fact that although this one was >benign (it wouldn't do anything unless you pressed the button), it's easy >to imagine JavaScripts that are _not_ benign, and that does things without >consent. The latest beta of Mailman apparently has a option to convert all messages to plaintext, including stripping out ECMA/JavaScript. We will convert that when possible, but the exact timing depends on our hosts at the University of Indiana, who have to be concerned about system stability. --Beman"
"> Just found another boost open source user, I could not yet find any > statement about which libraries they use. The berlios svn-view service > seems to be out of order > > Yake - http://www.yake.org/ > The Yake Engine is a component-based, object-oriented engine written > in > C++ and primarily designed for VR applications and games. It abstracts > typical low-level and middleware APIs and provides various low, mid > and application level functionality as well as tools to create and > import content. OK added to cvs. John."
"I would appreciate some help in including the logging libs into the boost compilation process. I am using the recent SVN trunks, Cygwin 1.7.9 and g++ (GCC) 4.3.4. Unfortunately there is nor README or INSTALL docs as I am used to in a GNU automake environment. So I tried my best based on what I found google-ing it: I downloaded the current boost SVN trunk and the current boost-log SVN trunk. Then I linked the log directories into the boost trunk: $ ln -s boost-log/trunk/boost-log/libs/log/ boost-trunk/libs/ $ ln -s boost-log/trunk/boost-log/boost/log/ boost-trunk/boost/ Compiling boost with normal ./bjam does not recognise the log components at all: ... Component configuration: - chrono : building - date_time : building - exception : building - filesystem : building - graph : building - graph_parallel : building - iostreams : building - math : building - mpi : building - program_options : building - python : building - random : building - regex : building - serialization : building - signals : building - system : building - test : building - thread : building - wave : building ...patience... Explicitly including it gets me an error message: $ ./bjam.exe target-os=cygwin --with-log error: wrong library name 'log' in the --with-<library> option. What am I missing? Is there an easier way to do it? Thanks a lot for any help. -- Bernd"
"On 13/05/13 22:35, Michael Marcin wrote: > There are also parameters where the names do not encoding important > settings. If the code is compiled for x86 or x64 for instance. The user > is just expected to build and use the libraries they need. A linker will automatically reject linking together code that was built for two different incompatible architectures"
"On Sep 13, 2004, at 1:54 AM, Aleksey Gurtovoy wrote: > Given that there is still some work on regressions to be done, > I'd like to aim for the end of the week, let's say Friday, > September 17th. Does that sound OK to everybody? > > I'm assuming that at this point all library authors/maintainers are > finished with the tasks they wanted to perform before the release, > minor regression fixes aside. If not, please scream loudly! Sure, I think I can handle that. Doug"
"At 06:02 PM 7/13/2003, Matthias Troyer wrote: >it now works again ... It broke again for Win32 due to a Sun fix from Jens that inadvertently broke Win32 compiles. That is now fixed. Also Dave fixed an iterator_facade glitch, so filesystem is working for more compilers. On Win32, there still seem to be iterator_facade issues for como-win32 and VC++ 6.0 See below. --Beman como-win32: "C:\boost\site\boost/iterator/iterator_facade.hpp", line 285: error #864: iterator_facade is not a template BOOST_ITERATOR_FACADE_RELATION(==) msvc: C:\boost\site\boost/iterator/iterator_facade.hpp(365) : error C2899: typename cannot be used outside a template declaration"
"On 10/31/06, Rene Rivera <grafikrobot_at_[hidden]> wrote: > Martin Knoblauch Revuelta wrote: > > > How about a sequence container (like a vector) with the advantage of > > logarithmic time insertion/removal at any point of the sequence? The > > disadvantage is that random access takes logarithmic time too (instead > > of the usual constant time random access of a vector). > > Sorry if these where already mentioned, but I just got around to looking > at the implementation: > > * There's no need for the m_next and m_prev fields. You can do inorder, > preorder, postorder, and others without them. Yes, I could, but operators ++ and -- would become O(log n). Many operations benefit from the posibility of fast iteration through m_next and m_prev. For example: begin() and end() are O(1). > * I suspect you don't need the m_height either. But I don't know what > you are using it for yet. For balance. IMO, the logic of re-balancing becomes simpler by having m_height instead of the usual {-1,0,+1}. > * In my rank tree implementation the only extra field per node is the > count, what you call width (as separate node and total). If I remember > correctly in CLRS they describe the possibility of the count not > directly reflecting the subtree+1 size to allow for sparse trees. I > suspect that you can remove the need for the different m_node_width and > m_total_width, using one only, by deducing the m_node_width from "count > - left_count - right_count". The width is based on the same concept as count, but they are not related at all. Note that W might be float, for example. I might deduce m_total_width from m_node_width by recursing through the whole subtree every time. Obviously, this would spoil the whole thing. > * Overall you need to make use of STD utilities more. I think someone > already mentioned something to this effect. Another example is using the > iterator tags and other meta information. This is important to help out > type specific algorithms. I'll study this. > * Also putting implementations out-of-line would help in reading what > the various interfaces do. I agree. I'll do so. > I also dislike the use of abbreviations and > single letter symbols, as it makes it harder to read. But this is mostly > a matter of taste :-) Yes, we might discuss this for ages. I try not to abuse them, using longer names on variables that will live longer, or will be passed by reference. Though, IMHO long names turn complex expessions unreadable as operators get buried under lots of letters. > * I don't see how not having a static allocator prevents moving nodes > across equally typed containers. It shouldn't, but it depends on how correct is the allocator class. I read in the documentation of SGI that allocators must be fully static, allowing deallocation of something by a different object of that one used for allocation (perhaps even destructed in the meantime). Is this true for _all_ std and boost allocators too? > * I get the impression that there's is way more code than needed to > implement this data structure. I'm trying to refactorize some things, but it's a large interface... ;-) > * You should use the allocator types instead of making types out of the > value type directly. I don't understand. Do you mean the rebind trick? I thought this was the standard way. > * Not sure why you would want the various unsigned/int/long vs size_type > variations of methods. Having those extra methods just confuses the > interface for users and introduces extra use cases to account for in the > implementation. It helps avoiding ambiguities when T is an unsigned/int/long. This is how other container implementations solve it. > * operator=(o) can't be O(max(N,M)). You have to both construct the new > elements and destroy the existing elements which makes it O(M+N) Right. > and keeping exceptions in mind you do a swap in between :-) Exceptions? Swap? Currently, it looks like this: clear (); // delete old contents construct_nodes_list (..); // copy (T constr. might throw) build_known_size_tree (..); // still here? ok, build the tree Do you mean I should do it this way instead? construct_nodes_list (..); // copy (T constr. might throw) clear (); // still here? ok, delete old contents build_known_size_tree (..); // and build the tree > * You have a variety of C style casts, and you happen to be casting > "this". That's frowned upon, and truthfully I can't see why you do it. I'll change them to C++ casts. With this trick, neither iterators nor tree nodes need to contain a pointer to the avl_array object where they "belong", while the interface allows working with iterators without requiring references to the corresponding avl_array objects. > * Algorithms rarely have a place in STL containers. You might want to > move the various binary_search, sort, etc. methods to functions. > Preferably having them use the same interface as the STD versions. I'll study this too. > * I would make the value sorted aspect a separate container, possibly as > an adaptor to the rank container but possibly also some other form of > tree. Sorted ordering is orthogonal to rank statistics. Why? I wouldn't like to restrict the hybrid use of a container object. I mean, using it as a sorted container for a while, then using it as unsorted for a while, then sorting it again, maybe with a different criterion, and so on... Note that iterators would remain valid through the whole process... > * You seem to be using a sentinel node as a hybrid root and tail node > but making the avl_array itself that sentinel node. To say the least > this is a bit strange to me. In version 1.0, the sentinel was a member of the avl_array. I had to use some ugly non-portable macros to get the avl_array from the sentinel address. It's much better with inheritance. > Why not have just a root pointer to a real > root node? An embedded sentinel (aggregated, or inherited) is IMHO far more consistent with the idea of an "end" position. Additionally, it simplifies the implementation. > Now for naming... > > I don't think I'll ever be able to refer to this as anything other than > a rank tree, even with the addition of a sparse version. Obviously you > named it avl for the type of balancing you are doing. As for some of the > other suggested names they fall into two categories: structure > (log_list, llist, larray, chain, random_list, rlist, ralist, > ra_sequence) and category (os_tree, order statistics dictionary, and the > variety of synonyms for sequence). > > The category terms fail to account for implementations of other > exemplars from that category. This is the reason why STL doesn't have a > "container" class... I know it's an exaggerated example :-) > > The STL tends to stick closely to using implementation related terms > which would fit more closely with using structure terms. Programmers > find this intuitive because they learn data structures and algorithm, > and hence they can use the names as an indication of what to expect from > the implementation of the containers. Unfortunately this rules out all > the proffered terms as they suggest implementations other than an > augmented binary tree. I would be pleased with anyone of the suggested names, including rank tree if you don't mind. Thanks a lot for your suggestions. Best regards, Martin"
"Andrew Chinkoff wrote: > > Below is the typical realization of A::Instance(): > > static A& Instance() > { > if (instance_ == NULL) > { > boost::mutex::scoped_lock locker(mtx_); // this > is the thread safe cost! > instance_ = new A(); > } > return *instance_; > } > > You should note that: > 1) Cost for thread safe synchronization is paid only once. > After instance had created this cost is no longer paid. That code has a race condition, so it appears more efficient than it should. > 2) Cost for function call (A::Instance()) is replaced with > smart_ptr::get() one. > > Did I miss the point? Yes. The smart pointer's operators are inlined functions that merely access a pointer data member. Zero overhead. Your function cannot be inlined and, depending upon how you manage the synchronization, it can be fairly costly, but most certainly includes function call overhead. _____ Rob Stewart robert.stewart_at_[hidden] Software Engineer, Core Software using std::disclaimer; Susquehanna International Group, LLP http://www.sig.com IMPORTANT: The information contained in this email and/or its attachments is confidential. If you are not the intended recipient, please notify the sender immediately by reply and immediately delete this message and all its attachments. Any review, use, reproduction, disclosure or dissemination of this message or any attachment by an unintended recipient is strictly prohibited. Neither this message nor any attachment is intended as or should be construed as an offer, solicitation or recommendation to buy or sell any security or other financial instrument. Neither the sender, his or her employer nor any of their respective affiliates makes any warranties as to the completeness or accuracy of any of the information contained herein or that this message or any of its attachments is free of viruses."
""Peter Dimov" <lists_at_[hidden]> writes: > The easiest fix I can think of is to change > > return px[ i ]; > > to > > return static_cast< typename boost::detail::sp_array_access< T >>::type >>( px[ i ] ); Ah, clever, thanks! Do you want to track this issue somehow? Do I open a trac ticket, or create a pull request, or...? > This seems to work for me with the current develop (master should be > the same). I get no other errors. Those other errors were caused by wrong (missing) -I flags. Nothing of interest. Thanks, Petr."
"On Sat, 22 May 2004 20:20:07 +1000, Arash Partow wrote > Hi all, > > I was wondering if there would be any interest in a template > library based around producers and consumers. Sure, but.... > I've developed something already and have a series of working > examples, I propose a library that consist of 3 basic entities, a > producer a consumer and a hybrid entity called an interchange. > > the entities themselves will be threaded and will be linked together Making each element of the processing chain a thread is rather constraining. What if I want to use a leaders / followers approach to threading my chain of transformers? So when I get a callback on my socket I chain thru all the transformations in the callback thread thus avoiding several thread context switches just to process the data. > via a linking mechanism that is itself a base template but which can > be extended to provide data transfer between same system processes > and threads and also extended versions which provide data transfer over > pipes, sockets, serial lines etc.. > > the idea of the producer-consumer is very simple the producer > produces a type of data ie: string, a class, a struct etc.. and a > consumer that is instantiated as a consumer of the type will consume > the data provided by the producer and do something with it. How does this differ from the signals and slots library? http://www.boost.org/doc/html/signals.html Couldn't we just create a slot endpoint for the various types? Can I connect 2 or more consumers to a particular interchange? For this to be useful, I should be able to. >...snip detail... > > The link mechanism is a basically a type that supports the common > type between a producer and its consumer, it is a one way flow of > data, the consumer is signaled when data is ready for it to collect Again, seems like signals and slots to me... >...snip... > > A link has a basic get and add functionality but depending what > entity is being implemented they will only see it via an interface > and hence only be able to invoke 1 kind of method, a producer can > only invoke "add" where-as a consumer can only invoke a get, an > interchange can invoke both because it is instantiated with both a > consumer and producer link interface, but the links are separate for > an interchange, because it requires 2 links, one link for the > incoming data and one link for the out going data. both link maybes > of different types, ie: > > Producer <string> ----> Interchange <string, AClass> ----> Consumer <AClass> > > I need some opinions, about whether or not people will find this > library useful and hence have it as part of Boost, if so could people > give me their opinions about my design, its just a simple first trial > run at designing it, i intended for the producers and interchange > entities to be policy driven as far as production of data is > concerned. Well, I think it could be useful and wouldn't mind having it in boost, but it seems like we need other basic infrastructure like a reactor, callback timers, and sockets before there will be much advantage. > I think this library can be used in distributed computing, in network > packet assembly, and also for interfacing and passing data up and > down threaded software layers. Yes, it is a useful design in 'data flow' systems. Distributed publish-subscribe type systems which have various data transformers use this type of design (or they should). Jeff"
"Ohh, forgot to answer this one. David Abrahams writes: > vertex descriptor (you didn't throw out operator[] for property-accessors, > did you?) It makes complete sense to me (of course ;)), and I think that The property accessors class in the library currently provide operator[]. However, the library no longer uses operator[]. I had been using an adaptor/proxy to turn operator[] into put/get inside the algorithms, but it was fragile on VC++. Also, there are no property accessor concepts that mention operator[]. I've thought about adding them in... I suppose adding them to LvaluePropertyAccessor would be harmless with regards to Dietmars arguments against operator[]. Cheers, Jeremy"
"I continue to make progress with format, but seem to fail most tests the format a hex value. In particular, if I want to format an 8 digit hex number to display as: 0x00001234 I am currently getting 00000x1234 I beleive this is some test code that does roughly something similar to the library implementation: int main() { std::cout.setf( std::ios::showbase ); std::cout << "BCB hex test: " << std::setfill( '0' ) << std::setw( 8 ) << std::internal << std::hex << 0x1234 << std::endl; } Is this a correct simplification on the library algorithm for this test case? I'm not sure about relying on 'internal' to separate 0x from 1234 before padding. Is this the technique format uses? And if so, is it correct? Or am I missing something else in the library? [I'm no streams expert, and will happily file a bug report with borland if someone can quote me a relevent section of the standard, if that is indeed the case]"
"El 10/09/2010 8:13, joaquin_at_[hidden] escribió: > Ion Gaztañaga escribió: >> The lazy init does not work because somehow get() is being called in a >> static object (static_initializer()->init()), so it's lazily but *too >> early* instantiated. > > This is aspect of Boost.Flyweight is by design, instantiation of the > singleton class is made > during the program dynamic initialization phase so as to avoid > concurrency problems > to a large extent (see http://tinyurl.com/38jknra ). Threading shouldn't be a problem, because lazy initialization is serialized through mutexes (even the non-lazy initialization, because non-lazy is just using lazy initialization in a static object). Two threads calling get() shouldn't lead to a race condition when obtaining a pointer to the singleton. Further concurrent usage should be of course protected by the user. Best, Ion"
"2018-02-05 3:16 GMT+01:00 charleyb123 . via Boost <boost_at_[hidden]>: > # Boost.Outcome.v2 REVIEW REPORT > > In conclusion to the review for Boost.Outcome(v2) (19-Jan to 28-Jan, 2018): > The library is ACCEPTED (conditions below). > Wow. Congratulations Niall for getting Outcome accepted into Boost. But at this point I would really like to congratulate Charley on managing the review and coming with the verdict. It is my perception that this review was particularly hard and controversial. One can learn a lot only from reading the justification of the verdict. The beclouded discussion appeared at times to exhibit violent agreement: > > Quoting reviewer (voting to reject): > > However it looks like Outcome provides a solution for most of the > practical > > cases, while leaving the general case unsolved. Boost.Outcome is a set > of > > tools (rather than just one) and you are expected to choose one that > best > > solves your particular problem. > > Quoting response by library author: > > I was just about to say the same thing, but more pointed. <...> > Knowing that > > a piece of code will never, ever see stack unwinding lets you skip > handling > > stack unwinding. Hence `noexcept`. > > > > Furthermore, unlike with exception specifications which were > unhelpfully checked > > at runtime, Outcome fails at compile time. .... You can't successfully > compile code > > if your E types don't have interop specified for them. > > > > Outcome is of particular use in a lower-level layer of code (closer to > bare metal, > > or in server contexts), where explicit deterministic error handling > warrants > > increased tedium or inconvenience in explicit checks for > success/failure. > I would like to clarify one thing. In the quoted discussion above it was actually me talking to Niall, and I voted to conditionally accept the library. It does not change the conclusion though, as indeed there were points in the discussion where those voting to reject did agree on the scope and limitations of the library. Regards, &rzej;"
"On Saturday 22 August 2009, John Maddock wrote: > For now, I'm just trying to build the HTML from within > libs/signals2/doc, it builds cleanly with apparently no errors, but > there were some "failed to load external entity" XSLT warnings that lead > to the HTML having no code snippets in it > The program that extracts the code snippets seems to run OK, I just > don't see any generated XML files anywhere? > > This is on Windows BTW. When I build on linux, the snippets get put in bin.v2/libs/signals2/doc/gcc-4.3.2/debug/ and "bjam -d2" shows it running xsltproc with a --path "../../../bin.v2/libs/signals2/doc/gcc-4.3.2/debug" option: xslt-xsltproc ../../../bin.v2/libs/signals2/doc/gcc-4.3.2/debug/signals.docbook XML_CATALOG_FILES=../../../bin.v2/boostbook_catalog.xml export XML_CATALOG_FILES "xsltproc" --stringparam boost.libraries "../../../libraries.htm" --stringparam boost.root "../../../.." --stringparam html.stylesheet "../../../../doc/html/boostbook.css" --path "../../../bin.v2/libs/signals2/doc/gcc-4.3.2/debug" --xinclude -o "../../../bin.v2/libs/signals2/doc/gcc-4.3.2/debug/signals.docbook" "/home/fhess/svn/boost_trunk/tools/boostbook/xsl/docbook.xsl" "signals.xml""
"In the FAQ page, the first answer says: "... that a sub_range do propagate const-ness" ^^ I believe it should say "does" Pablo"
"On Fri, Aug 8, 2008 at 12:59 PM, Beman Dawes <bdawes_at_[hidden]> wrote: > Thanks to Dave for putting in all the administrivia time it took to make > this happen! > > --Beman > _______________________________________________ > Unsubscribe & other changes: > http://lists.boost.org/mailman/listinfo.cgi/boost > Yes quite, thanks to Dave, and indeed Joel & Eric & Steven W & numerous others for all the time and effort they put into making Boost a great place to be. We'd be a poorer community without them. - Rob."
"Hi, i learnt that it was > implemented in a previous year's GSoC. But i could not find it in the boost > package i downloaded(i beg your pardon if i am wrong). That library has not yet been included into Boost. You might want to view this GSoC 2007 page for Boost: http://code.google.com/soc/2007/boost/about.html Regards, Eugene Wee"
"Hello community I want work on project : Boost.Polygon edge, polyline and edge set concepts. Could anyone provide me some weblinks to learn about polyline and edge set algorithms? Monish Gupta"
"On Mon, Mar 04, 2002 at 07:45:45AM -0500, John Maddock wrote: > > >Works for me. What's missing? > > You're right, I've updated the jamfile to turn threading support on for > config_test. > > BTW -pthread isn't the right flag on all gcc platforms - FreeBSD uses > -pthreads if memory serves me right, and cygwin uses -mthreads, and some > platforms need -lrt as well as -lpthread. Any idea how we can handle this? http://ac-archive.sourceforge.net/Installed_Packages/acx_pthread.html -S"
"On 5/5/2011 6:46 PM, Erik Erlandson wrote: > On Wed, 2011-05-04 at 17:17 -0500, Rene Rivera wrote: > >> It looks like Bernhard stopped development 1.5 years ago. Which sure >> sounds like it's orphaned. Given that I've copied it over to >> sandbox/tree location (the last trunk state for it). I'm willing to help >> out in moving the library forward, especially since it's based on some >> of the core concepts I suggested. Who else is willing to help out in >> improving and finishing this lib? Note, that helping out involves >> thinking about adjusting the TR proposal so that it can be submitted for >> the soon to start up again TR2. >> >> > > I have a few questions regarding the TR2 tree iterators > > 1) I would recommend a breadth-first iterator Right. There are many additional traversal algorithms possible. And the specification of the pre-defined ones is one of the week points of the current TR. > 2) What is the semantic of in-order traversal for a non-binary tree? Even though it's only implied I think it's left-to-right in-order traversal. > 3) I don't feel like I'm understanding the motivation for cursors versus > iterators. Is there an "elevator pitch" for that? Single sentence: Cursors provide an abstraction for *all* the possible traversals of trees vs. the linear only traversals of iterators in a single object making it possible to base the expanse of tree algorithms solely on cursors. Longer: Because of the additional cardinality of trees the current std model of iterators doesn't allow for a compact mapping to trees. Even though it's possible to define a group of iterator, node, and function interfaces to accomplish the same task it makes it harder to conceptualize algorithms when one has to deal with two or three types of iterators at once. Essentially it's possible to write generic algorithms entirely on the single cursor concept without really having to think about the particular context. And I'm not talking only about user visible algorithms here. I'm also including usually internal algorithms. For example it's possible to write generic tree balancing algorithms using cursors that would be rather mind bending with just iterators (and usually would require direct access to the nodes). Note, it's likely the current TR doesn't actually deliver on the entirety of the above though ;-) > Also, a question regarding the definition of 'multi-way' tree: My > reaction to 'multi-way' is: 'synonym for n-ary', but that appears to not > be the idea. What makes a binary tree "multi-way" and an nary tree not > multi-way? Don't have an answer for that.. multi-way is a term Bernhard came up with. Which I never really understood either. So I'll have to get back to you on that."
"> We've created a second release candidate to fix a few issues. The three > fixes since RC1 are listed at the end of this mail. > > The files for 1.56.0 RC2 are available at: > http://boost.cowic.de/rc/ Builds successfully on: 1. OSX 10.9.4, x64, clang 3.4 (C++03, C++11) 2. Ubuntu 14.04, x64, gcc 4.8.2, (C++03, C++11) Glen"
">> While you only state a preference over V2, it's hard to see that you are >> unhappy with it. >> > I think your library needs to do better than coming up with a slightly > different syntax than V1, otherwise I don't see the point of having it. Indeed, but I claim more than a slightly different syntax. The fixed-arity stuff is quite a different syntax. The other stated goals of the design, in the change-log, are, amongst other things, to bring these improvements: 1- Code reuse because deque and put share the same crtp 2- Code decoupling (modularity) 3- Open for extension (albeit not enough, see my response to) Do I have to argue that these objectives worthwhile?! No, so I please ask whether they are were met, and if not, what is lacking. PS: maybe I did not state 3-. Let's assume I get paid for writing a TPS report, every day, involving 100 unit-tests such as the one below. STL approach: std::deque<int> cont; const int n = 2; int x = log10( 1 ); for(int i = 0; i < n; i++) { cont.push_front( x ); } x = log10( 10 ); for(int i = 0; i < n; i++) { cont.push_front( x ); } x = log10( 100 ); for(int i = 0; i < n; i++) { cont.push_front( x ); } x = log10( 1000 ); for(int i = 0; i < n; i++) { cont.push_front( x ); } assert( boost::range::equal( cont, csv_deque( 3, 3, 2, 2, 1, 1, 0, 0 ) ) ); PS: No need to argue that a nested loop would made the job easier. Your boss can make it as arcane as he likes and he might have as well re-arranged 1, 10, 100, 1000 in a different order. Assign 2.0: BOOST_AUTO( _r, ( _repeat = 2 ) ); typedef function<int(int)> f_; BOOST_AUTO( _d, ( _data = f_( log10 ) ) ); assert( boost::range::equal( csv( deque<int, push_front_>( _nil) % _d % _r, 1, 10, 100, 1000 ), csv_deque( 3, 3, 2, 2, 1, 1, 0, 0 ) ) ); Does Assign (1.0-2.0) begins to add positively to your well being? Assume, further, that you have to do the same thing all over again, but you have to drop the function altogether, and replace push_front by push_back. Is it better to write a function or use Assign? As for 2.0, specifically, do we agree about *decoupling* of features (_r,_d and push_front_)? The same code above requires very minor modification if used with put() rather than deque(), are we on the same page about *code reuse*? Finally, let's say you want something other than repeat, that does not already exits. You can write write a small class, that conforms to a concept (ConceptModifier), and invoke two mere macros, and the job is done. Do you agree about *open for extension*? https://svn.boost.org/svn/boost/sandbox/assign_v2/boost/assign/v2/option/modifier/repeat.hpp Please have a bit mercy and give me your updated impressions based on these clarifications."
"Four weeks ago: 144 open bugs Three weeks ago: 117 open bugs Two weeks ago: 96 open bugs Last week: 94 open bugs Today: 93 open bugs Thanks to everyone who dealt with the bugs! [ But we're slowing down - I blame the 1.33.1 release process ;-) ] If you think that a bug has been assigned incorrectly, please let me know. Bugs by assignee: Doug Gregor 16 Mike Glassford 14 Beman Dawes 12 John R. Bandela 7 Stephen Cleary 5 Jonathan Turkanis 5 Rene Rivera 4 Joerg Walter 4 Jeff Garland 3 Joel de guzman 3 Jeremy Siek 2 Mark Rodgers 2 <nobody> 2 Robert Ramey 2 Gennadiy Rozental 2 Vladimir Prus 2 Thorsten Ottosen 1 Darryl Walker 1 Eric Friedman 1 Jens Maurer 1 John Maddock 1 Samuel Krempp 1 Here are the currently opened bugs, sorted by assignee. P.S. I need someone to fix the bugs in the tokenizer library!! Assignee: az_sw_dude <http://sourceforge.net/users/az_sw_dude/> Summary: wrong usage of ios_base::narrow Bug #: 989487 <http://sourceforge.net/tracker/index.php?func=detail&aid=989487&group_id=7586&atid=107586> Assignee: az_sw_dude <http://sourceforge.net/users/az_sw_dude/> Summary: date_time type conversion warning Bug #: 1069225 <http://sourceforge.net/tracker/index.php?func=detail&aid=1069225&group_id=7586&atid=107586> Assignee: az_sw_dude <http://sourceforge.net/users/az_sw_dude/> Summary: local_adjustor::utc_to_local throws 'Time label invalid' Bug #: 1220011 <http://sourceforge.net/tracker/index.php?func=detail&aid=1220011&group_id=7586&atid=107586> Assignee: beman_dawes <http://sourceforge.net/users/beman_dawes/> Summary: filesytem::directory_iterator portability Bug #: 735403 <http://sourceforge.net/tracker/index.php?func=detail&aid=735403&group_id=7586&atid=107586> Assignee: beman_dawes <http://sourceforge.net/users/beman_dawes/> Summary: boost::filesystem fails in posix with files containing ':' Bug #: 776146 <http://sourceforge.net/tracker/index.php?func=detail&aid=776146&group_id=7586&atid=107586> Assignee: beman_dawes <http://sourceforge.net/users/beman_dawes/> Summary: clock is not portable Bug #: 788762 <http://sourceforge.net/tracker/index.php?func=detail&aid=788762&group_id=7586&atid=107586> Assignee: beman_dawes <http://sourceforge.net/users/beman_dawes/> Summary: Boost::Filesystem fails when last character in path is ':' Bug #: 875970 <http://sourceforge.net/tracker/index.php?func=detail&aid=875970&group_id=7586&atid=107586> Assignee: beman_dawes <http://sourceforge.net/users/beman_dawes/> Summary: filesystem::directory_iterator returns incorrect listing Bug #: 937606 <http://sourceforge.net/tracker/index.php?func=detail&aid=937606&group_id=7586&atid=107586> Assignee: beman_dawes <http://sourceforge.net/users/beman_dawes/> Summary: xtime_cmp: use comparison not subtraction Bug #: 993272 <http://sourceforge.net/tracker/index.php?func=detail&aid=993272&group_id=7586&atid=107586> Assignee: beman_dawes <http://sourceforge.net/users/beman_dawes/> Summary: boost::filesystem::exists is broken on cygwin Bug #: 1010681 <http://sourceforge.net/tracker/index.php?func=detail&aid=1010681&group_id=7586&atid=107586> Assignee: beman_dawes <http://sourceforge.net/users/beman_dawes/> Summary: boost::filesystem is systematically broken Bug #: 1012135 <http://sourceforge.net/tracker/index.php?func=detail&aid=1012135&group_id=7586&atid=107586> Assignee: beman_dawes <http://sourceforge.net/users/beman_dawes/> Summary: boost::filesystem::native() should reject '/' on non-Win32 Bug #: 1151823 <http://sourceforge.net/tracker/index.php?func=detail&aid=1151823&group_id=7586&atid=107586> Assignee: beman_dawes <http://sourceforge.net/users/beman_dawes/> Summary: boost::filesystem::exists has bugs with UNC paths Bug #: 1164057 <http://sourceforge.net/tracker/index.php?func=detail&aid=1164057&group_id=7586&atid=107586> Assignee: beman_dawes <http://sourceforge.net/users/beman_dawes/> Summary: boost::filesystem::equivalent does not work on w98 Bug #: 1235262 <http://sourceforge.net/tracker/index.php?func=detail&aid=1235262&group_id=7586&atid=107586> Assignee: beman_dawes <http://sourceforge.net/users/beman_dawes/> Summary: path and directory_iterator doesn't handle windows root path Bug #: 1259176 <http://sourceforge.net/tracker/index.php?func=detail&aid=1259176&group_id=7586&atid=107586> Assignee: dgregor <http://sourceforge.net/users/dgregor/> Summary: no conversion from type to const_type Bug #: 547743 <http://sourceforge.net/tracker/index.php?func=detail&aid=547743&group_id=7586&atid=107586> Assignee: dgregor <http://sourceforge.net/users/dgregor/> Summary: EdgeListS = setS for adjacency_list does not work Bug #: 1163077 <http://sourceforge.net/tracker/index.php?func=detail&aid=1163077&group_id=7586&atid=107586> Assignee: dgregor <http://sourceforge.net/users/dgregor/> Summary: adjacency_matrix should model BidirectionalGraph Bug #: 1168411 <http://sourceforge.net/tracker/index.php?func=detail&aid=1168411&group_id=7586&atid=107586> Assignee: dgregor <http://sourceforge.net/users/dgregor/> Summary: LEDA graph adaptors for undirected graphs Bug #: 1168420 <http://sourceforge.net/tracker/index.php?func=detail&aid=1168420&group_id=7586&atid=107586> Assignee: dgregor <http://sourceforge.net/users/dgregor/> Summary: LEDA adaptors for node_array, edge_array Bug #: 1168424 <http://sourceforge.net/tracker/index.php?func=detail&aid=1168424&group_id=7586&atid=107586> Assignee: dgregor <http://sourceforge.net/users/dgregor/> Summary: LEDA graph adaptors do not handle hidden nodes properly Bug #: 1168431 <http://sourceforge.net/tracker/index.php?func=detail&aid=1168431&group_id=7586&atid=107586> Assignee: dgregor <http://sourceforge.net/users/dgregor/> Summary: Generate patches for Graph bugs in 1.32.0 Bug #: 1169920 <http://sourceforge.net/tracker/index.php?func=detail&aid=1169920&group_id=7586&atid=107586> Assignee: dgregor <http://sourceforge.net/users/dgregor/> Summary: Investigate other kinds of heaps for dijkstra_shortest_paths Bug #: 1170106 <http://sourceforge.net/tracker/index.php?func=detail&aid=1170106&group_id=7586&atid=107586> Assignee: dgregor <http://sourceforge.net/users/dgregor/> Summary: function.hpp breaks assign.hpp Bug #: 1181272 <http://sourceforge.net/tracker/index.php?func=detail&aid=1181272&group_id=7586&atid=107586> Assignee: dgregor <http://sourceforge.net/users/dgregor/> Summary: vertex bundle properties do not work with VC++.NET 2003 Bug #: 1190394 <http://sourceforge.net/tracker/index.php?func=detail&aid=1190394&group_id=7586&atid=107586> Assignee: dgregor <http://sourceforge.net/users/dgregor/> Summary: BGL graph types do not support allocators Bug #: 1193883 <http://sourceforge.net/tracker/index.php?func=detail&aid=1193883&group_id=7586&atid=107586> Assignee: dgregor <http://sourceforge.net/users/dgregor/> Summary: random_vertex/random_edge are unnecessarily inefficient Bug #: 1204684 <http://sourceforge.net/tracker/index.php?func=detail&aid=1204684&group_id=7586&atid=107586> Assignee: dgregor <http://sourceforge.net/users/dgregor/> Summary: Document copy_component Bug #: 1204688 <http://sourceforge.net/tracker/index.php?func=detail&aid=1204688&group_id=7586&atid=107586> Assignee: dgregor <http://sourceforge.net/users/dgregor/> Summary: reverse_graph and constness of property maps Bug #: 1246336 <http://sourceforge.net/tracker/index.php?func=detail&aid=1246336&group_id=7586&atid=107586> Assignee: dgregor <http://sourceforge.net/users/dgregor/> Summary: html docs frequently missing key words Bug #: 1294420 <http://sourceforge.net/tracker/index.php?func=detail&aid=1294420&group_id=7586&atid=107586> Assignee: dgregor <http://sourceforge.net/users/dgregor/> Summary: EdgeListS = has_setS for adjacency_list does not work Bug #: 1352049 <http://sourceforge.net/tracker/index.php?func=detail&aid=1352049&group_id=7586&atid=107586> Assignee: djowel <http://sourceforge.net/users/djowel/> Summary: Miss ' = ParserT()' Bug #: 907299 <http://sourceforge.net/tracker/index.php?func=detail&aid=907299&group_id=7586&atid=107586> Assignee: djowel <http://sourceforge.net/users/djowel/> Summary: spirit insert_key_actor.hpp Bug #: 1059936 <http://sourceforge.net/tracker/index.php?func=detail&aid=1059936&group_id=7586&atid=107586> Assignee: djowel <http://sourceforge.net/users/djowel/> Summary: Another config correction for Sun C++ Bug #: 1220782 <http://sourceforge.net/tracker/index.php?func=detail&aid=1220782&group_id=7586&atid=107586> Assignee: dlwalker <http://sourceforge.net/users/dlwalker/> Summary: template problems with common_factor.hpp Bug #: 491637 <http://sourceforge.net/tracker/index.php?func=detail&aid=491637&group_id=7586&atid=107586> Assignee: ebf <http://sourceforge.net/users/ebf/> Summary: boost::blank - missing operators Bug #: 1191356 <http://sourceforge.net/tracker/index.php?func=detail&aid=1191356&group_id=7586&atid=107586> Assignee: glassfordm <http://sourceforge.net/users/glassfordm/> Summary: timeconv.inl to_duration() nsec error Bug #: 548104 <http://sourceforge.net/tracker/index.php?func=detail&aid=548104&group_id=7586&atid=107586> Assignee: glassfordm <http://sourceforge.net/users/glassfordm/> Summary: Solaris - once.cpp compile error Bug #: 549162 <http://sourceforge.net/tracker/index.php?func=detail&aid=549162&group_id=7586&atid=107586> Assignee: glassfordm <http://sourceforge.net/users/glassfordm/> Summary: pthread_delay_np() parm incorrect Bug #: 551157 <http://sourceforge.net/tracker/index.php?func=detail&aid=551157&group_id=7586&atid=107586> Assignee: glassfordm <http://sourceforge.net/users/glassfordm/> Summary: Bosot.Thread.condition(win32).notify_all Bug #: 551308 <http://sourceforge.net/tracker/index.php?func=detail&aid=551308&group_id=7586&atid=107586> Assignee: glassfordm <http://sourceforge.net/users/glassfordm/> Summary: AIX 4.3 SIGSEGV at thread termination Bug #: 551577 <http://sourceforge.net/tracker/index.php?func=detail&aid=551577&group_id=7586&atid=107586> Assignee: glassfordm <http://sourceforge.net/users/glassfordm/> Summary: boost::threads uses msvc only function? Bug #: 568951 <http://sourceforge.net/tracker/index.php?func=detail&aid=568951&group_id=7586&atid=107586> Assignee: glassfordm <http://sourceforge.net/users/glassfordm/> Summary: threads unnecessary #include Bug #: 571615 <http://sourceforge.net/tracker/index.php?func=detail&aid=571615&group_id=7586&atid=107586> Assignee: glassfordm <http://sourceforge.net/users/glassfordm/> Summary: BCB6 throw EExternelException Bug #: 596149 <http://sourceforge.net/tracker/index.php?func=detail&aid=596149&group_id=7586&atid=107586> Assignee: glassfordm <http://sourceforge.net/users/glassfordm/> Summary: thread_cleanup problems Bug #: 649291 <http://sourceforge.net/tracker/index.php?func=detail&aid=649291&group_id=7586&atid=107586> Assignee: glassfordm <http://sourceforge.net/users/glassfordm/> Summary: Mac implementation of threads is CPU hog Bug #: 885045 <http://sourceforge.net/tracker/index.php?func=detail&aid=885045&group_id=7586&atid=107586> Assignee: glassfordm <http://sourceforge.net/users/glassfordm/> Summary: condition variables and recursive_mutex Bug #: 1072605 <http://sourceforge.net/tracker/index.php?func=detail&aid=1072605&group_id=7586&atid=107586> Assignee: glassfordm <http://sourceforge.net/users/glassfordm/> Summary: compiler error on Mac implementation of threads Bug #: 1201779 <http://sourceforge.net/tracker/index.php?func=detail&aid=1201779&group_id=7586&atid=107586> Assignee: glassfordm <http://sourceforge.net/users/glassfordm/> Summary: timeconv.inl line 116 copy/paste error Bug #: 1239052 <http://sourceforge.net/tracker/index.php?func=detail&aid=1239052&group_id=7586&atid=107586> Assignee: glassfordm <http://sourceforge.net/users/glassfordm/> Summary: Exception safety in class 'thread' Bug #: 1305885 <http://sourceforge.net/tracker/index.php?func=detail&aid=1305885&group_id=7586&atid=107586> Assignee: grafik <http://sourceforge.net/users/grafik/> Summary: 'failed fileclone' when building with -j on 1.32.0 Bug #: 1102389 <http://sourceforge.net/tracker/index.php?func=detail&aid=1102389&group_id=7586&atid=107586> Assignee: grafik <http://sourceforge.net/users/grafik/> Summary: boost jam problem with parallel builds Bug #: 1234224 <http://sourceforge.net/tracker/index.php?func=detail&aid=1234224&group_id=7586&atid=107586> Assignee: grafik <http://sourceforge.net/users/grafik/> Summary: crach build bjam from mingw 3.4.4 Bug #: 1341560 <http://sourceforge.net/tracker/index.php?func=detail&aid=1341560&group_id=7586&atid=107586> Assignee: grafik <http://sourceforge.net/users/grafik/> Summary: crach build bjam from mingw 3.4.4 with python Bug #: 1341568 <http://sourceforge.net/tracker/index.php?func=detail&aid=1341568&group_id=7586&atid=107586> Assignee: jbandela <http://sourceforge.net/users/jbandela/> Summary: tokenizer fails with wchar_t Bug #: 446155 <http://sourceforge.net/tracker/index.php?func=detail&aid=446155&group_id=7586&atid=107586> Assignee: jbandela <http://sourceforge.net/users/jbandela/> Summary: tokenizer not works with Dinkumware 308 Bug #: 458236 <http://sourceforge.net/tracker/index.php?func=detail&aid=458236&group_id=7586&atid=107586> Assignee: jbandela <http://sourceforge.net/users/jbandela/> Summary: boost::tokenizer implicit typename Bug #: 912368 <http://sourceforge.net/tracker/index.php?func=detail&aid=912368&group_id=7586&atid=107586> Assignee: jbandela <http://sourceforge.net/users/jbandela/> Summary: Tokenizer.hpp doesn't work with BOOST_ENABLE_ASSERT_HANDLER Bug #: 972406 <http://sourceforge.net/tracker/index.php?func=detail&aid=972406&group_id=7586&atid=107586> Assignee: jbandela <http://sourceforge.net/users/jbandela/> Summary: Compiler error for tokenizer on Solaris Bug #: 976241 <http://sourceforge.net/tracker/index.php?func=detail&aid=976241&group_id=7586&atid=107586> Assignee: jbandela <http://sourceforge.net/users/jbandela/> Summary: tokenizer and signed char Bug #: 1003889 <http://sourceforge.net/tracker/index.php?func=detail&aid=1003889&group_id=7586&atid=107586> Assignee: jbandela <http://sourceforge.net/users/jbandela/> Summary: token_iterator::at_end() result is inversed Bug #: 1338326 <http://sourceforge.net/tracker/index.php?func=detail&aid=1338326&group_id=7586&atid=107586> Assignee: jmaurer <http://sourceforge.net/users/jmaurer/> Summary: Diff in state of mersenne_twister gen between GCC3.41 &amp; CW9 Bug #: 1115124 <http://sourceforge.net/tracker/index.php?func=detail&aid=1115124&group_id=7586&atid=107586> Assignee: joerg_walter <http://sourceforge.net/users/joerg_walter/> Summary: bug in ublas/storage.hpp Bug #: 1095697 <http://sourceforge.net/tracker/index.php?func=detail&aid=1095697&group_id=7586&atid=107586> Assignee: joerg_walter <http://sourceforge.net/users/joerg_walter/> Summary: dead links in uBLAS page Bug #: 1169273 <http://sourceforge.net/tracker/index.php?func=detail&aid=1169273&group_id=7586&atid=107586> Assignee: joerg_walter <http://sourceforge.net/users/joerg_walter/> Summary: Documentation not available on web site: Bug #: 1228242 <http://sourceforge.net/tracker/index.php?func=detail&aid=1228242&group_id=7586&atid=107586> Assignee: joerg_walter <http://sourceforge.net/users/joerg_walter/> Summary: uBLAS::subslice doesn't work Bug #: 1292635 <http://sourceforge.net/tracker/index.php?func=detail&aid=1292635&group_id=7586&atid=107586> Assignee: johnmaddock <http://sourceforge.net/users/johnmaddock/> Summary: Adding boost::is_complex to type_traits.hpp Bug #: 1315712 <http://sourceforge.net/tracker/index.php?func=detail&aid=1315712&group_id=7586&atid=107586> Assignee: jsiek <http://sourceforge.net/users/jsiek/> Summary: invalid result for File Dependency Examp Bug #: 551110 <http://sourceforge.net/tracker/index.php?func=detail&aid=551110&group_id=7586&atid=107586> Assignee: jsiek <http://sourceforge.net/users/jsiek/> Summary: Spelling of Edmonds-Karp-Algorithm Bug #: 1226292 <http://sourceforge.net/tracker/index.php?func=detail&aid=1226292&group_id=7586&atid=107586> Assignee: mark_rodgers <http://sourceforge.net/users/mark_rodgers/> Summary: Cannot compile octonion_test.cpp because of bug in sinc.hpp Bug #: 751269 <http://sourceforge.net/tracker/index.php?func=detail&aid=751269&group_id=7586&atid=107586> Assignee: mark_rodgers <http://sourceforge.net/users/mark_rodgers/> Summary: Cannot compile octonion_test.cpp because of bug in sinc.hpp Bug #: 751289 <http://sourceforge.net/tracker/index.php?func=detail&aid=751289&group_id=7586&atid=107586> Assignee: nesotto <http://sourceforge.net/users/nesotto/> Summary: boost.range and 'const char[]'. Bug #: 1272315 <http://sourceforge.net/tracker/index.php?func=detail&aid=1272315&group_id=7586&atid=107586> Assignee: nobody Summary: failure in boost jam unit tests on cygwin Bug #: 940941 <http://sourceforge.net/tracker/index.php?func=detail&aid=940941&group_id=7586&atid=107586> Assignee: nobody Summary: Can't build on cygwin Bug #: 1145183 <http://sourceforge.net/tracker/index.php?func=detail&aid=1145183&group_id=7586&atid=107586> Assignee: ramey <http://sourceforge.net/users/ramey/> Summary: Compiler warning with gcc on Linux Bug #: 1337412 <http://sourceforge.net/tracker/index.php?func=detail&aid=1337412&group_id=7586&atid=107586> Assignee: ramey <http://sourceforge.net/users/ramey/> Summary: warning caused by size_t to unsigned int conversion on vc++8 Bug #: 1338178 <http://sourceforge.net/tracker/index.php?func=detail&aid=1338178&group_id=7586&atid=107586> Assignee: rogeeff <http://sourceforge.net/users/rogeeff/> Summary: typo in Boost.Test document Bug #: 629685 <http://sourceforge.net/tracker/index.php?func=detail&aid=629685&group_id=7586&atid=107586> Assignee: rogeeff <http://sourceforge.net/users/rogeeff/> Summary: Don't work multilevel hierarchy of test suites in dll. Bug #: 1076691 <http://sourceforge.net/tracker/index.php?func=detail&aid=1076691&group_id=7586&atid=107586> Assignee: samuel_k <http://sourceforge.net/users/samuel_k/> Summary: format: assert when parsing invalid pattern Bug #: 1326132 <http://sourceforge.net/tracker/index.php?func=detail&aid=1326132&group_id=7586&atid=107586> Assignee: shammah <http://sourceforge.net/users/shammah/> Summary: ct_gcd_lcm.hpp compilation error Bug #: 558174 <http://sourceforge.net/tracker/index.php?func=detail&aid=558174&group_id=7586&atid=107586> Assignee: shammah <http://sourceforge.net/users/shammah/> Summary: test_pool_alloc.cpp not compile CW8.1 Bug #: 586779 <http://sourceforge.net/tracker/index.php?func=detail&aid=586779&group_id=7586&atid=107586> Assignee: shammah <http://sourceforge.net/users/shammah/> Summary: pool::purge_memory() does not reset next_size Bug #: 984124 <http://sourceforge.net/tracker/index.php?func=detail&aid=984124&group_id=7586&atid=107586> Assignee: shammah <http://sourceforge.net/users/shammah/> Summary: Borland compiler error with Pool, boost::pool_allocator Bug #: 988124 <http://sourceforge.net/tracker/index.php?func=detail&aid=988124&group_id=7586&atid=107586> Assignee: shammah <http://sourceforge.net/users/shammah/> Summary: perfomance: memory cleanup for pool takes too long Bug #: 995270 <http://sourceforge.net/tracker/index.php?func=detail&aid=995270&group_id=7586&atid=107586> Assignee: shammah <http://sourceforge.net/users/shammah/> Summary: boost::pool_allocator breaks with vector of vectors Bug #: 1179641 <http://sourceforge.net/tracker/index.php?func=detail&aid=1179641&group_id=7586&atid=107586> Assignee: turkanis <http://sourceforge.net/users/turkanis/> Summary: Self division wrong in template rational Bug #: 504411 <http://sourceforge.net/tracker/index.php?func=detail&aid=504411&group_id=7586&atid=107586> Assignee: turkanis <http://sourceforge.net/users/turkanis/> Summary: Rational sum not optimal for overflows Bug #: 519635 <http://sourceforge.net/tracker/index.php?func=detail&aid=519635&group_id=7586&atid=107586> Assignee: turkanis <http://sourceforge.net/users/turkanis/> Summary: rational operator&amp;lt; can overflow Bug #: 798357 <http://sourceforge.net/tracker/index.php?func=detail&aid=798357&group_id=7586&atid=107586> Assignee: turkanis <http://sourceforge.net/users/turkanis/> Summary: boost::rational documentation typos(?) Bug #: 1043616 <http://sourceforge.net/tracker/index.php?func=detail&aid=1043616&group_id=7586&atid=107586> Assignee: turkanis <http://sourceforge.net/users/turkanis/> Summary: no Boolean conversion for boost::rational Bug #: 1239906 <http://sourceforge.net/tracker/index.php?func=detail&aid=1239906&group_id=7586&atid=107586> Assignee: vladimir_prus <http://sourceforge.net/users/vladimir_prus/> Summary: call to split_winmain raises exception for 8-bit locale Bug #: 1206663 <http://sourceforge.net/tracker/index.php?func=detail&aid=1206663&group_id=7586&atid=107586> Assignee: vladimir_prus <http://sourceforge.net/users/vladimir_prus/> Summary: multitoken broken in program_options 1.33 Bug #: 1266877 <http://sourceforge.net/tracker/index.php?func=detail&aid=1266877&group_id=7586&atid=107586>"
"I forgot to answer your question. My version is boost_1_53_0. Kind regards, Philip Bennefall"
"Thorsten Ottosen wrote: > Doug Gregor wrote: >> On May 2, 2006, at 1:01 PM, Neal Becker wrote: >> >> >>> David Abrahams wrote: >>> >>>> Actually it's not a virtual call, it's a call through a function >>>> pointer. That's one less indirection. >>>> >>> Do you think a smart compiler might optimize this to a direct call? >> >> I have yet to see a compiler smart enough to optimize this indirection. > > IOW, the overhead might be *significant* for small functions that would > otherwise be inlined (and insignificant for larger functions). > Exactly. I've done some tests in the past trying to quantify the cost of virtuals, direct functions (inlined and not) and indirect functions. The cost of an indirect function is in practice not distinguishable from a non-inlined direct function. A virtual is (very) slightly costlier. The real difference is in inlining."
"Frank Mori Hess wrote: > -----BEGIN PGP SIGNED MESSAGE----- > Hash: SHA1 > > On Tuesday 09 March 2010, Michael Caisse wrote: > >> Also, I think signals2/signal.hpp should also include >> shared_connection_block.hpp. >> > > Why? Are you confusing boost/signals2.hpp with boost/signals2/signal.hpp? > > Wow. Must have been a bad night for me. I did confuse the two. Sorry for the noise. michael"
"Hello, I am using the CVS version tagged RC_1_34_0. I put all the BOOST_CLASS_EXPORT statements into a header file that also contains all the serialization functions. This header is included by two separate .cpp files, each of which implements the loading and saving of archives for a different subset of the classes that can be serialized. These are all compiled into a single DLL. All of this compiles under VC8.0 (but I have not yet verified that it runs properly). But when linking with gcc (in Linux), I get multiple definition errors when linking. What's the best way to deal with this? (assuming that this is a problem that you recognize and know how to fix) Deane"
"Joaquín Mª López Muñoz wrote: > 1. Syntax and semantics > Since bimap follows as closely as possible the interface of std::map, > there's little IMHO to add or remove from here. The added constraint > of bidirectionality imposes some behavior that diverges from regular > maps, though. I don't think there's an alternate way to handle the > following > issues: > * operator[], when used for inspection on a non-existent value, throws > bimap_base::value_not_found. std::maps, on the other hand, automatically > > insert a default value. This I cannot do in bimap, since it would > violate > the bidirectionality. What about when operator[] is used for an assignment to a unique value? I have to imagine that there are scenarios where inserting a temporary value wouldn't be all that bad. Is it possible to make this a policy of some kind? Or possibly an template parameter to a "default value" generator function? The template parameter could default to a function that throws the exception... > * bimap_base::duplicate_value is thrown whenever an assignment is > attempted to a value already present in the bimap: this again stems from > > the preservation of the bidirectionality invariant."
"On Sun, Jan 22, 2017 at 10:35 AM, Louis Dionne <ldionne.2_at_[hidden]> wrote: > Hi, > > I know this has been discussed in the past, but I would like to revive the > discussion about moving away from SourceForge as Boosts' release hosting > provider. One thing that we found that couldn't be replicated at any of the other major OSS hosting sites was the ability to have the windows binaries in the same location. These files are quite large (200MB x 12 visual studio version + 1.4GB for the combined archive), and none of the sites that we looked at could support them. There was also (I believe) a general consensus that we wanted to keep those at the same place as the source distribution. That said, I think we have other (secondary?) locations that serve the source distro, so maybe it would be worthwhile to point your travis jobs there instead of sourceforge? Tom"
"Hi, I was wondering if there's any reason not to include make_shared_array() / allocate_shared_array() in boost/make_shared.hpp (or maybe add boost/make_shared_array.hpp), along with the already existing make_shared() and allocate_shared() functions? Regards, Roman."
"I wrote some code to show how hard link support could be added to the boost.filesystem library. It is included in the attached patches. The patches add three functions to operations.hpp and operations_posix_windows.cpp: bool equivalent(path const &lhs, path const &rhs); Tests if the two arguments refer to the same file. This is useful even outside the context of hard links, since it avoids the problem of having to compare paths syntactically. Throws if either of the paths does not exist or is inaccessible. unsigned int link_count(path const &ph); Returns the number of hard links to the file specified by the argument. (On platforms that do not support hard linking, this always returns 1.) Throws if the path does not exist or is inaccessible. void link(path const &existing_path, path const &new_path); Creates a hard link from `new_path' to the file referred to by `existing_path'. Throws if `existing_path' does not exist, if `new_path' does exist, or if the operation fails for any of a variety of reasons. Note that the code in the attached patches has not been tested on Windows, and due to the use of CreateHardLink, it may be the case that it does not compile or run on versions of Windows older than Windows 2000. It would be convenient if there were a way to provide a unique identifier for a file, for use in an associative container. Unfortunately, although Windows does provide a 64-bit identifier for a file, the documentation indicates that these identifiers are only valid while there is an open handle to the file. I suppose it would be possible to keep an open handle to the file as part of the identifier, but such a system seems highly resource intensive."
"On 12/12/2013 2:05 PM, Cox, Michael wrote: > On Thu, Dec 12, 2013 at 6:09 AM, Peter Dimov <lists_at_[hidden]> wrote: > >> Cox, Michael wrote: >> >>> I don't expect the criteria to merge changes from a feature branch to the >>> develop branch to be successful builds/tests for *all *supported >>> compilers/platforms (that sounds like a good criteria for merging the >>> develop branches into the master branches). I would expect something along >>> the lines of an incremental build of a freshly pulled set of repositories >>> and running the tests for your compiler/platform. >>> >> >> Sure, that's just common sense and basically what we've been already >> doing. A change to the public develop branch (the svn trunk in the old >> world) implies that local testing *of the submodule* has been done. Not of >> all of Boost; this takes too much time even on a single compiler/platform. >> (This doesn't specify whether the local change to the develop branch has >> been a feature branch merge or something else; it doesn't matter.) >> > > Yes, but common sense is just so uncommon these days :-). > > Does "local testing * of the submodule*" include running the unit-tests of > the the other submodules to see if you've broken anything in someone elses > submodule that depends on yours? The other way around. If you have dependencies on other libraries you can run your 'develop' tests with the 'develop' branch of those other libraries. Then you can notify some dependent library if their changes break your own tests. I would also run the 'develop' tests against 'master' for all libraries also at some time. This is no difference in principal than developing any other software. > And BTW, I was Googling and looking > through Boost.Build documentation and couldn't figure out how to easily run > all the tests for all the libraries. I would assume there is a target you > could pass b2 to run all the unit-tests. What is it? No one except regression testers is tasked with this. > > >> In practice, a single compiler is not enough; on Windows, one needs at >> least one version of MSVC, at least one version of GCC, at least one >> non-C++11 compiler, at least one C++11 compiler. > > Wow, that's a lot of combinations. Is that the "official" Boost policy, > i.e. is there a link on the web-site I can read this? Will that be the > official policy for all Boost libraries or can individual libraries define > their own? It's just a suggestion, I believe. In Windows I use various releases of gcc and VC++. In Linux various releases of gcc, clang, Intel C++, and occasionally Sun C++, although the latter is a bit buggy. If you have C++03 aned C++0x features you try to test both sides."
"Jason, This is part of the rat-hole I was hoping to direct you away from in the thread discussing your Singleton design in late March: http://aspn.activestate.com/ASPN/Mail/Message/2531666 I am still of the opinion that the mechanism you're trying to develop to protect against unwanted multiple instantiations of the singleton object is orthogonal to the design of the singleton, and is clunky besides. My two cents. dr On 5/9/05, Jason Hise <chaos_at_[hidden]> wrote: > Tobias Schwinger wrote: > > > Jason Hise wrote: > > > >> AFAIK, a pure virtual function is the only way to automatically make > >> any derived classes un-instantiable. > > > > Have you considered a protected (or even private if you want complete > > uninstantiability) constructor? > > This will not automatically make derived classes uninstantiable. Client > code should not be forced to provide a protected constructor if they > wouldn't naturally need one... the uninstantiability, if that's a word, > should be inherited automatically. A protected constructor would allow > a public client default constructor to be generated automatically. > > Rob Stewart wrote: > > >Nope. The derived class dtor would be virtual > >automatically. (12.4/7) > > > In that case I'll apply the changes and get the new version online as > soon as possible. > > -Jason > > > _______________________________________________ > Unsubscribe & other changes: http://lists.boost.org/mailman/listinfo.cgi/boost >"
"Daryle Walker <darylew_at_[hidden]> writes: |> The printf syntax explicitly mentions the type and formatting |> options for each parameter. C++'s better type checking eliminates |> the need for the explicit typing, and the ability to add manipulator |> objects eliminates the need for explicit formatting. The first isn't quite true, and won't be as long as there are implicit conversions. Probably the most frequent error in using printf was to pass a constant 0 to something like a "%6.2f". A C/C++ user expects this to be allowed, since I can normally use an integral constant where ever a floating point is needed, and a good formatting function will know that a floating point is expected, and do the conversion. As for the second, ask any programmer who has used both printf and manipulators which he prefers. With regards to the i18n aspects, I'm of two minds here, but it isn't difficult to think of cases where the width or precision should vary according to the locale. [...] |> By the way, Robert's approach doesn't mention about how to write |> brackets. Maybe we can have "%[" be a literal open square bracket, |> "%]" be a literal close square bracket, and "%%" be a literal |> percent. Would it be too much to ask why boost is trying to re-invent the wheel. The extended printf format defined by X/Open works quite well, thank you, and unless someone can point out some fatal flaw with it, I would argue for sticking with it."
"AMDG Kenny Riddile wrote: > Yes, I had that thought too, especially since I believe __FILE__ gives > the entire path of the file. Still, I didn't know if there was some > magical way to extract the desired section of the __FILE__ output > using boost preprocessor or something. I've never used that library > before. There is not. __FILE__ is a character array literal. There is no way to introspect such a beast. Also see http://www.boost.org/doc/html/typeof/refe.html#typeof.incr In Christ, Steven Watanabe"
"----- Original Message ----- From: "Samuel Krempp" <krempp_at_[hidden]> To: <boost_at_[hidden]> Sent: Saturday, June 30, 2001 6:30 AM Subject: Re: [boost] Review : format2, yet another 'printf class' > > > The second is "short-positional-notation", in which we > > > can indicate the number of the argument, nothing more. > > > > > > %2% for second argument.. > > > etc.. > > > > This was the one I wanted most in my challenge. I don't like the idea that > > such a simple usage gets cluttered with extra % signs. Could we move the > > extra % to the printf syntax somehow? > > Obviously no.. if we want to support printf-like syntaxe, we'd rather stick > to its precise specification. > And then, "%10" can either be followed by some text, say > "%10, " > or chars from printf specs; like "%10s" or "%10$2d", or "%10d", ... > So a short-positional notation can not be just "%N". > > Still it's clearly practical to be able to designate arguments with just 2 > letters. > > One solution is to use another special char for this, say "$", like shell > syntax.. > format(" $1s : $2=$$ $3") %"Taxe" %"Total" %"1500" > => " Taxes : Total=$ 1500" > The inconvenient is that another char ($ here) has to be escaped for > litteral usage. > And that the syntax of format becomes a bit bicephal.. > But I think it is a good solution. providing both short and complex > notations satisfy both common but opposed needs > (quick printing of a few vars, VS basic formatted printing with alignment, > and all printf features like hexa printing etc..) > > Would everybody be happy with these 2 forms coexisting ? > (in fact it makes 3, considering printf-like items can be positional : > "%1$s", or not : "%s" .. ) > > If yes, I'll do that, the parsing should not be hard to adapt at all. > > I think using both $1 and %2$5d in the same format-string will even be > easy to implement. > (for cases when we just want a formatting stuff on 1 or 2 items, and want to > simply print the others..) > Within a loop of long computations, say changing x, and y, it's often > practical to keep the values aligned : > format("$1, with ratio=$2. found point [%3$4d, %4$4d]. \n") %fileName > %ratio %x %y; > -> > toto.bmp, with ratio=0.83. found point [ 0, 0]. > toto.bmp, with ratio=0.83. found point [ 5, 17]. > toto.bmp, with ratio=0.83. found point [ 28, 176]. > ... > you get the point. > (even if I was too lazy to aligned by hand the numbers, with this stupid > Outlook using non-fixed font ..) > I wouldn't mind $, but I've done a bit of shell programming, so it's not foreign to me. > > > then, could the "format-as-a-function" previous implementation be > accepted > > > into boost ? > > > > I guess so. Maybe somebody else will have a counterargument. I like the > lack > > of arg limitations in your implementation. > > well, the only concrete thing I see against the function approach, is the > few restrictions it imposes (const operators<< only, and 9 arguments max), > that feels a bit unfounded. > > Also, lots of different function signatures get instantiated by the compiler > If we use format on 20 different types, with varying ordering of types in > 5-arguments calls, we can get up to > 20^5=3.200.000 different signatures. (ahh, I like the spectacular grandeur > of exponential growth..) > So basically,even if we rarely use more than 4 or 5 arguments, each call > will use a new signature, and there will be as many signatures as calls. > And this can maybe have some bad impact. In case not everything is fully > inlined, it would be catastrophic, wouldn't it ? > > With the operator approach, only 5 different signatures of the operator% are > needed in this case. > > I dont know enough of the internal structure of the compiled objects to know > if this can really lead to an undiscutable argument against the function.. > > Those points aside, the choice between operator and function approach is > merely up to tastes, and in this matter we're at least 2 to like the > operator.. > > Is there anybody willing to fight for the function-approach ? > I like the function approach, mostly because that's what I've been using for the last 6 months :-) I think that the code just looks more obvious with what it's doing. It's also easy to learn and understand. I also see the advantages of the non-function approach. format could support both. format could be a generator function (like std::back_inserter). If it's called with one char * argument it generates the format class that will apply the % arguments, and if it's called with more than one argument, it will generate the function type format class that wouldn't work with the % operator. --Dan Nuffer"
"AMDG On 08/26/2011 02:51 PM, Larry Evans wrote: > On 08/26/11 15:24, Dave Abrahams wrote: >> >> No, sorry, but that's just silly. Array indexing is entirely >> consistent: >> >> f[0] => returns int(&)[1][1] >> f[0][0] => returns int(&)[1] >> f[0][0][0] => returns int& >> > Then so is (using haskell notation): > > f :: X -> Y -> Z -> int > > f x => returns Y -> Z -> int > f x y => returns Z -> int > f x y z => returns int > > which is Eric's point. IOW, when supplied with enough arguments, > the function returns the result_type of the function, just as, > when a multi-dimensional array is supplied enough arguments > (or indices) it returns the value type of the array. > That's just how functions that take multiple arguments work in Haskell. It isn't how C++ works. Trying to create the same behavior in a language that supports multi-argument functions directly seems like it would cause more confusion than good. In Christ, Steven Watanabe"
"On 9/11/09, Bo Persson <bop_at_[hidden]> wrote: > DE wrote: >> on 11.09.2009 at 3:19 >> Cory Nelson wrote : >>> I'm curious, have you actually tried to look at the generated >>> instructions? >> of course >> >>> Because on a 686+ this should compile this into two >>> non-branching instructions for min(): >>> cmp a, b >>> cmova a, b >>> And the same thing but with cmovb for max(). >> neither icc11 nor msvc80 generate such instructions >> msvc generates a conditional jump and icc generates code "without >> branches but with the sbb asm instruction" (c) Joel Falcou >> > > I believe the conditional move introduces a dependency that is about > as bad as a conditional jump. Conditional jumps actually break dependencies, as the processor can speculate beyond them and execute code at the jump target even before computing the condition. Conditional moves do introduce dependencies as any other if-conversions, including an indexed load, thus an if-conversion should only be used if the CPU has no chance to predict the jump as it otherwise limit any out-of-order capabilities of the CPU. Cmov and other predicated instructions should be as fast or faster than if-conversions done with bitwise instructions or other instruction combinations. > It also limits the code to the latest > processor models. > > The compilers generally try to avoid this situation. :-) > cmov on x86 has been available since the first pentium pro, which has been launched almost 15 years ago. It is guaranteed to exist on x86_64. By default, some compiles still produce code compatible with the original 386, so you might need to use appropriate compiler flags. HTH,"
"Aleksey Gurtovoy wrote: > Jaakko, > > Could you please take a look/comment on the following failure in > "bind_tests_simple_f_refs" (from http://tinyurl.com/52xlg): > > "C:\MinGW341\bin\g++" Jaakko if this can help, I can run some tests separately on this compiler. Just email me privately. B."
"At 7:17 AM +0100 3/10/06, Pavel Vozenilek wrote: >One option may be to use Cygwin (or use similar approach >as Cygwin does but this doesn't feel attractive neither. No, I don't think Cygwin is really an option here either."
"Den 18-01-2011 18:20, Steven Watanabe skrev: > AMDG > What exactly is wrong with > BOOST_ASSERT( !foo() || assertion ) > or > BOOST_ASSERT( foo() ? assertion : true ) > > IMHO, the last thing we need is lots of > minor variations that don't add any > real utility. I beg to differ. Code needs to be clear and meaningful to read, and the obscure rewrite rule makes the code harder to write and read. Simplifying logic is one of the best ways to simplify code and ensure it is correct. What is clear to experts might not be so clear to those of us that are mentally challenged when facing cryptic logic. As programmers we have enough other things to worry about. -Thorsten"
"Daniel James wrote: > 2008/7/31 Michael Marcin <mike.marcin_at_[hidden]>: > >> However the documentation says that objects have to model the Regular >> concept in order to model the Movable concept. This seems unfortunate as >> Regular puts a lot of requirements on types that don't seem necessary to >> gain moving. It requires Assignable which requires a copy constructor and it >> requires EqualityComparable which seems unnecessary. > > Sorry, the documentation is out of date, I haven't updated it for the > changes I've made. The library does supports noncopyable types. If you > can decipher it there is an example in the unit tests (in y.hpp - I'll > probably rename that file). You have to implement it a little > differently to your normal noncopyable type. The signature is > something like: Fantastic. I sort of figured it does since I'm using them just wanted to make sure it was a feature and not a bug. > > class noncopyable > { > // Private constructor to make it noncopyable. > // Note that it's a non-const reference > noncopyable(noncopyable&); > public: > noncopyable(); > ~noncopyable(); > noncopyable(boost::move_from<noncopyable>); // Move constructor > noncopyable& operator=(noncopyable); // Move assignment > operator boost::move_from<noncopyable>() { > return boost::move_from<noncopyable>(*const_cast<noncopyable*>(this)); > } > }; The implicit conversion to move_from seems very dangerous to me. > > I should warn you that the library will probably change to support > other types and hopefully rvalue references. I'll be resuming work on > it soon after this release is done. > I'm looking forward to it. Thanks, Michael Marcin"
"JÃ¼rgen Hunold <jhunold <at> gmx.eu> writes: > Hi, > > revision 86597 changed boost/multi_index/detail/bucket_array.hpp > [...] > Now gcc (4.8.1) reports multiple definition errors when using multi_index > in different translation units: > [...] Thanks for spotting this. Hopefully fixed in https://svn.boost.org/trac/boost/changeset/86651 Can you check this really solves the problem? Thank you, JoaquÃn M LÃ³pez MuÃ±oz TelefÃ³nica Digital"
"Why don't we have single BOOST_GCC macro which defines version of gcc compiler. In numerous places around boost we need to check for specific versions on gcc and required to use complex expressions involving up to 3 gcc variables. Gennadiy"
"I'm using current boost cvs. Building with bjam -sTOOLS=gcc stage, builds only archive (.a) versions of serialization libs. I need shared (.so). What needs to be done?"
"Viktor Peters wrote: > And someone should look at the random library. There are some issues I > stumble regulary: > > 1) <cmath> must be included before <boost/random.hpp> (GCC 3.4.2), > otherwise some errors arise: "'std::pow' has not been > declared" and friends I think I've committed such a change some time ago, after running into a trouble myself. Do you still get errors on 1.32 release candidate? - Volodya"
"on 02.05.2010 at 20:05 vicente.botet wrote : > On the documentation you say " Some of these numbers can get huge, > making copying an expensive proposition, and even move semantics (at > least as emulated by Boost.Move at the time of this writing) aren't as fast" > Why do you say on Boost.Move is not as fast as COW? can i reply? please can i? can i? for example if you make 10 copies of an object cow (or implict sharing) aware objects will share only one representation among all instances, i.e. there is only one allocation, initialization and no copy processes at all in this circumstances move enabled objects would not act as efficient supposing none of that ten copies are temporary you get ten "deep" copies of the first object this involves ten allocations, initializations and costs associated with them so in some circumstances implicit sharing (or cow) will always be faster even if move semantics is implemented otherwise"
"| -----Original Message----- | From: boost-bounces_at_[hidden] | [mailto:boost-bounces_at_[hidden]]On Behalf Of Andy Little | Sent: Friday, October 17, 2003 3:48 AM | To: boost_at_[hidden] | Subject: [boost] Re: Physical Quantities revisited | | "Almost everyone" includes ... well you presumably. You can 'Google' your way through the previous discussions about this, but I think I speak for the majority of the opinions expressed. | As usual embedded developers are ignored. | (In embedded its relatively common to scale during a calc to prevent | overflow. That is sometimes more important than absolute accuracy) So your strategy may suit your applications better. | In the U.K.... but not Cumbria | I guess every road sign is in ...er. miles per hour ... Yup! < many examples snipped - the list could be endless! > | | Unit conversion is a real problem now! Absolutely - and we need better tools to deal with them, but also to avoid serious mistakes in calculation which led, for the most spectacular example, to the Mars Lander to be a Mars Crasher instead. The current discussion about Dimensional Analysis is primarily directed at this aspect, with emphasis on near-zero run-time cost, something especially important to you embedders. It is obviously essential that any units system works with any dimensional analysis system, something we haven't cracked yet. Watch this space. Meanwhile have fun with your package. Paul Paul A Bristow, Prizet Farmhouse, Kendal, Cumbria, LA8 8AB UK +44 1539 561830 Mobile +44 7714 33 02 04 mailto:pbristow_at_[hidden]"
